{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.AnnotateCommunicationService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Language_Types as Language_Types
import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Entities_Types as Entities_Types
import Data.Concrete.Autogen.Situations_Types as Situations_Types
import Data.Concrete.Autogen.Ex_Types as Ex_Types
import Data.Concrete.Autogen.Email_Types as Email_Types
import Data.Concrete.Autogen.Twitter_Types as Twitter_Types
import Data.Concrete.Autogen.Audio_Types as Audio_Types
import Data.Concrete.Autogen.Communication_Types as Communication_Types


import Data.Concrete.Autogen.Annotate_Types as Annotate_Types
import qualified Data.Concrete.Autogen.AnnotateCommunicationService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Annotate_args = Annotate_args  { annotate_args_original :: Communication_Types.Communication
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Annotate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotate_args_original record  
instance QC.Arbitrary Annotate_args where 
  arbitrary = M.liftM Annotate_args (QC.arbitrary)
  shrink obj | obj == default_Annotate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Annotate_args{annotate_args_original = annotate_args_original obj} then P.Nothing else P.Just $ default_Annotate_args{annotate_args_original = annotate_args_original obj}
    ]
from_Annotate_args :: Annotate_args -> T.ThriftVal
from_Annotate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("original",Communication_Types.from_Communication _v2))) $ annotate_args_original record
  ]
write_Annotate_args :: (T.Protocol p, T.Transport t) => p t -> Annotate_args -> P.IO ()
write_Annotate_args oprot record = T.writeVal oprot $ from_Annotate_args record
encode_Annotate_args :: (T.Protocol p, T.Transport t) => p t -> Annotate_args -> LBS.ByteString
encode_Annotate_args oprot record = T.serializeVal oprot $ from_Annotate_args record
to_Annotate_args :: T.ThriftVal -> Annotate_args
to_Annotate_args (T.TStruct fields) = Annotate_args{
  annotate_args_original = P.maybe (annotate_args_original default_Annotate_args) (\(_,_val4) -> (case _val4 of {T.TStruct _val5 -> (Communication_Types.to_Communication (T.TStruct _val5)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Annotate_args _ = P.error "not a struct"
read_Annotate_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Annotate_args
read_Annotate_args iprot = to_Annotate_args <$> T.readVal iprot (T.T_STRUCT typemap_Annotate_args)
decode_Annotate_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Annotate_args
decode_Annotate_args iprot bs = to_Annotate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Annotate_args) bs
typemap_Annotate_args :: T.TypeMap
typemap_Annotate_args = Map.fromList [(1,("original",(T.T_STRUCT Communication_Types.typemap_Communication)))]
default_Annotate_args :: Annotate_args
default_Annotate_args = Annotate_args{
  annotate_args_original = Communication_Types.default_Communication}
data Annotate_result = Annotate_result  { annotate_result_success :: Communication_Types.Communication
  , annotate_result_ex :: P.Maybe Ex_Types.ConcreteThriftException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Annotate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotate_result_success record   `H.hashWithSalt` annotate_result_ex record  
instance QC.Arbitrary Annotate_result where 
  arbitrary = M.liftM Annotate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Annotate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Annotate_result{annotate_result_success = annotate_result_success obj} then P.Nothing else P.Just $ default_Annotate_result{annotate_result_success = annotate_result_success obj}
    , if obj == default_Annotate_result{annotate_result_ex = annotate_result_ex obj} then P.Nothing else P.Just $ default_Annotate_result{annotate_result_ex = annotate_result_ex obj}
    ]
from_Annotate_result :: Annotate_result -> T.ThriftVal
from_Annotate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8 -> (1, ("ex",Ex_Types.from_ConcreteThriftException _v8))) <$> annotate_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8 -> P.Just (0, ("success",Communication_Types.from_Communication _v8))) $ annotate_result_success record
    , (\_v8 -> (1, ("ex",Ex_Types.from_ConcreteThriftException _v8))) <$> annotate_result_ex record
    ]
    )
write_Annotate_result :: (T.Protocol p, T.Transport t) => p t -> Annotate_result -> P.IO ()
write_Annotate_result oprot record = T.writeVal oprot $ from_Annotate_result record
encode_Annotate_result :: (T.Protocol p, T.Transport t) => p t -> Annotate_result -> LBS.ByteString
encode_Annotate_result oprot record = T.serializeVal oprot $ from_Annotate_result record
to_Annotate_result :: T.ThriftVal -> Annotate_result
to_Annotate_result (T.TStruct fields) = Annotate_result{
  annotate_result_success = P.maybe (annotate_result_success default_Annotate_result) (\(_,_val10) -> (case _val10 of {T.TStruct _val11 -> (Communication_Types.to_Communication (T.TStruct _val11)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  annotate_result_ex = P.maybe (P.Nothing) (\(_,_val10) -> P.Just (case _val10 of {T.TStruct _val12 -> (Ex_Types.to_ConcreteThriftException (T.TStruct _val12)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Annotate_result _ = P.error "not a struct"
read_Annotate_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Annotate_result
read_Annotate_result iprot = to_Annotate_result <$> T.readVal iprot (T.T_STRUCT typemap_Annotate_result)
decode_Annotate_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Annotate_result
decode_Annotate_result iprot bs = to_Annotate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Annotate_result) bs
typemap_Annotate_result :: T.TypeMap
typemap_Annotate_result = Map.fromList [(0,("success",(T.T_STRUCT Communication_Types.typemap_Communication))),(1,("ex",(T.T_STRUCT Ex_Types.typemap_ConcreteThriftException)))]
default_Annotate_result :: Annotate_result
default_Annotate_result = Annotate_result{
  annotate_result_success = Communication_Types.default_Communication,
  annotate_result_ex = P.Nothing}
data GetMetadata_args = GetMetadata_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetadata_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMetadata_args where 
  arbitrary = QC.elements [GetMetadata_args]
from_GetMetadata_args :: GetMetadata_args -> T.ThriftVal
from_GetMetadata_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMetadata_args :: (T.Protocol p, T.Transport t) => p t -> GetMetadata_args -> P.IO ()
write_GetMetadata_args oprot record = T.writeVal oprot $ from_GetMetadata_args record
encode_GetMetadata_args :: (T.Protocol p, T.Transport t) => p t -> GetMetadata_args -> LBS.ByteString
encode_GetMetadata_args oprot record = T.serializeVal oprot $ from_GetMetadata_args record
to_GetMetadata_args :: T.ThriftVal -> GetMetadata_args
to_GetMetadata_args (T.TStruct fields) = GetMetadata_args{

  }
to_GetMetadata_args _ = P.error "not a struct"
read_GetMetadata_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetMetadata_args
read_GetMetadata_args iprot = to_GetMetadata_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMetadata_args)
decode_GetMetadata_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetMetadata_args
decode_GetMetadata_args iprot bs = to_GetMetadata_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetadata_args) bs
typemap_GetMetadata_args :: T.TypeMap
typemap_GetMetadata_args = Map.fromList []
default_GetMetadata_args :: GetMetadata_args
default_GetMetadata_args = GetMetadata_args{
}
data GetMetadata_result = GetMetadata_result  { getMetadata_result_success :: Metadata_Types.AnnotationMetadata
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetadata_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMetadata_result_success record  
instance QC.Arbitrary GetMetadata_result where 
  arbitrary = M.liftM GetMetadata_result (QC.arbitrary)
  shrink obj | obj == default_GetMetadata_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMetadata_result{getMetadata_result_success = getMetadata_result_success obj} then P.Nothing else P.Just $ default_GetMetadata_result{getMetadata_result_success = getMetadata_result_success obj}
    ]
from_GetMetadata_result :: GetMetadata_result -> T.ThriftVal
from_GetMetadata_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v20 -> P.Just (0, ("success",Metadata_Types.from_AnnotationMetadata _v20))) $ getMetadata_result_success record
  ]
write_GetMetadata_result :: (T.Protocol p, T.Transport t) => p t -> GetMetadata_result -> P.IO ()
write_GetMetadata_result oprot record = T.writeVal oprot $ from_GetMetadata_result record
encode_GetMetadata_result :: (T.Protocol p, T.Transport t) => p t -> GetMetadata_result -> LBS.ByteString
encode_GetMetadata_result oprot record = T.serializeVal oprot $ from_GetMetadata_result record
to_GetMetadata_result :: T.ThriftVal -> GetMetadata_result
to_GetMetadata_result (T.TStruct fields) = GetMetadata_result{
  getMetadata_result_success = P.maybe (getMetadata_result_success default_GetMetadata_result) (\(_,_val22) -> (case _val22 of {T.TStruct _val23 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val23)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetMetadata_result _ = P.error "not a struct"
read_GetMetadata_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetMetadata_result
read_GetMetadata_result iprot = to_GetMetadata_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMetadata_result)
decode_GetMetadata_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetMetadata_result
decode_GetMetadata_result iprot bs = to_GetMetadata_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetadata_result) bs
typemap_GetMetadata_result :: T.TypeMap
typemap_GetMetadata_result = Map.fromList [(0,("success",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata)))]
default_GetMetadata_result :: GetMetadata_result
default_GetMetadata_result = GetMetadata_result{
  getMetadata_result_success = Metadata_Types.default_AnnotationMetadata}
data GetDocumentation_args = GetDocumentation_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDocumentation_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetDocumentation_args where 
  arbitrary = QC.elements [GetDocumentation_args]
from_GetDocumentation_args :: GetDocumentation_args -> T.ThriftVal
from_GetDocumentation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetDocumentation_args :: (T.Protocol p, T.Transport t) => p t -> GetDocumentation_args -> P.IO ()
write_GetDocumentation_args oprot record = T.writeVal oprot $ from_GetDocumentation_args record
encode_GetDocumentation_args :: (T.Protocol p, T.Transport t) => p t -> GetDocumentation_args -> LBS.ByteString
encode_GetDocumentation_args oprot record = T.serializeVal oprot $ from_GetDocumentation_args record
to_GetDocumentation_args :: T.ThriftVal -> GetDocumentation_args
to_GetDocumentation_args (T.TStruct fields) = GetDocumentation_args{

  }
to_GetDocumentation_args _ = P.error "not a struct"
read_GetDocumentation_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetDocumentation_args
read_GetDocumentation_args iprot = to_GetDocumentation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDocumentation_args)
decode_GetDocumentation_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetDocumentation_args
decode_GetDocumentation_args iprot bs = to_GetDocumentation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDocumentation_args) bs
typemap_GetDocumentation_args :: T.TypeMap
typemap_GetDocumentation_args = Map.fromList []
default_GetDocumentation_args :: GetDocumentation_args
default_GetDocumentation_args = GetDocumentation_args{
}
data GetDocumentation_result = GetDocumentation_result  { getDocumentation_result_success :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDocumentation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDocumentation_result_success record  
instance QC.Arbitrary GetDocumentation_result where 
  arbitrary = M.liftM GetDocumentation_result (QC.arbitrary)
  shrink obj | obj == default_GetDocumentation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDocumentation_result{getDocumentation_result_success = getDocumentation_result_success obj} then P.Nothing else P.Just $ default_GetDocumentation_result{getDocumentation_result_success = getDocumentation_result_success obj}
    ]
from_GetDocumentation_result :: GetDocumentation_result -> T.ThriftVal
from_GetDocumentation_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v31 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v31))) $ getDocumentation_result_success record
  ]
write_GetDocumentation_result :: (T.Protocol p, T.Transport t) => p t -> GetDocumentation_result -> P.IO ()
write_GetDocumentation_result oprot record = T.writeVal oprot $ from_GetDocumentation_result record
encode_GetDocumentation_result :: (T.Protocol p, T.Transport t) => p t -> GetDocumentation_result -> LBS.ByteString
encode_GetDocumentation_result oprot record = T.serializeVal oprot $ from_GetDocumentation_result record
to_GetDocumentation_result :: T.ThriftVal -> GetDocumentation_result
to_GetDocumentation_result (T.TStruct fields) = GetDocumentation_result{
  getDocumentation_result_success = P.maybe (getDocumentation_result_success default_GetDocumentation_result) (\(_,_val33) -> (case _val33 of {T.TString _val34 -> E.decodeUtf8 _val34; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetDocumentation_result _ = P.error "not a struct"
read_GetDocumentation_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetDocumentation_result
read_GetDocumentation_result iprot = to_GetDocumentation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDocumentation_result)
decode_GetDocumentation_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetDocumentation_result
decode_GetDocumentation_result iprot bs = to_GetDocumentation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDocumentation_result) bs
typemap_GetDocumentation_result :: T.TypeMap
typemap_GetDocumentation_result = Map.fromList [(0,("success",T.T_STRING))]
default_GetDocumentation_result :: GetDocumentation_result
default_GetDocumentation_result = GetDocumentation_result{
  getDocumentation_result_success = ""}
data Shutdown_args = Shutdown_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Shutdown_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Shutdown_args where 
  arbitrary = QC.elements [Shutdown_args]
from_Shutdown_args :: Shutdown_args -> T.ThriftVal
from_Shutdown_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> Shutdown_args -> P.IO ()
write_Shutdown_args oprot record = T.writeVal oprot $ from_Shutdown_args record
encode_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> Shutdown_args -> LBS.ByteString
encode_Shutdown_args oprot record = T.serializeVal oprot $ from_Shutdown_args record
to_Shutdown_args :: T.ThriftVal -> Shutdown_args
to_Shutdown_args (T.TStruct fields) = Shutdown_args{

  }
to_Shutdown_args _ = P.error "not a struct"
read_Shutdown_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Shutdown_args
read_Shutdown_args iprot = to_Shutdown_args <$> T.readVal iprot (T.T_STRUCT typemap_Shutdown_args)
decode_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Shutdown_args
decode_Shutdown_args iprot bs = to_Shutdown_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Shutdown_args) bs
typemap_Shutdown_args :: T.TypeMap
typemap_Shutdown_args = Map.fromList []
default_Shutdown_args :: Shutdown_args
default_Shutdown_args = Shutdown_args{
}
data Shutdown_result = Shutdown_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Shutdown_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Shutdown_result where 
  arbitrary = QC.elements [Shutdown_result]
from_Shutdown_result :: Shutdown_result -> T.ThriftVal
from_Shutdown_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> Shutdown_result -> P.IO ()
write_Shutdown_result oprot record = T.writeVal oprot $ from_Shutdown_result record
encode_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> Shutdown_result -> LBS.ByteString
encode_Shutdown_result oprot record = T.serializeVal oprot $ from_Shutdown_result record
to_Shutdown_result :: T.ThriftVal -> Shutdown_result
to_Shutdown_result (T.TStruct fields) = Shutdown_result{

  }
to_Shutdown_result _ = P.error "not a struct"
read_Shutdown_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Shutdown_result
read_Shutdown_result iprot = to_Shutdown_result <$> T.readVal iprot (T.T_STRUCT typemap_Shutdown_result)
decode_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Shutdown_result
decode_Shutdown_result iprot bs = to_Shutdown_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Shutdown_result) bs
typemap_Shutdown_result :: T.TypeMap
typemap_Shutdown_result = Map.fromList []
default_Shutdown_result :: Shutdown_result
default_Shutdown_result = Shutdown_result{
}
process_annotate (seqid, iprot, oprot, handler) = do
  args <- read_Annotate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.annotate handler (annotate_args_original args)
        let res = default_Annotate_result{annotate_result_success = val}
        T.writeMessageBegin oprot ("annotate", T.M_REPLY, seqid)
        write_Annotate_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Annotate_result{annotate_result_ex = P.Just e}
        T.writeMessageBegin oprot ("annotate", T.M_REPLY, seqid)
        write_Annotate_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("annotate", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getMetadata (seqid, iprot, oprot, handler) = do
  args <- read_GetMetadata_args iprot
  (X.catch
    (do
      val <- Iface.getMetadata handler
      let res = default_GetMetadata_result{getMetadata_result_success = val}
      T.writeMessageBegin oprot ("getMetadata", T.M_REPLY, seqid)
      write_GetMetadata_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getMetadata", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getDocumentation (seqid, iprot, oprot, handler) = do
  args <- read_GetDocumentation_args iprot
  (X.catch
    (do
      val <- Iface.getDocumentation handler
      let res = default_GetDocumentation_result{getDocumentation_result_success = val}
      T.writeMessageBegin oprot ("getDocumentation", T.M_REPLY, seqid)
      write_GetDocumentation_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("getDocumentation", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_shutdown (seqid, iprot, oprot, handler) = do
  args <- read_Shutdown_args iprot
  (X.catch
    (do
      Iface.shutdown handler
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "annotate" -> process_annotate (seqid,iprot,oprot,handler)
  "getMetadata" -> process_getMetadata (seqid,iprot,oprot,handler)
  "getDocumentation" -> process_getDocumentation (seqid,iprot,oprot,handler)
  "shutdown" -> process_shutdown (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
