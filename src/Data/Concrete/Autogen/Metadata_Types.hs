{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Metadata_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Twitter_Types as Twitter_Types
import Data.Concrete.Autogen.Email_Types as Email_Types
import Data.Concrete.Autogen.Nitf_Types as Nitf_Types


data TheoryDependencies = TheoryDependencies  { theoryDependencies_sectionTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_sentenceTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_tokenizationTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_posTagTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_nerTagTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_lemmaTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_langIdTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_parseTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_dependencyParseTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_tokenAnnotationTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_entityMentionSetTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_entitySetTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_situationMentionSetTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_situationSetTheoryList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , theoryDependencies_communicationsList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TheoryDependencies where
  hashWithSalt salt record = salt   `H.hashWithSalt` theoryDependencies_sectionTheoryList record   `H.hashWithSalt` theoryDependencies_sentenceTheoryList record   `H.hashWithSalt` theoryDependencies_tokenizationTheoryList record   `H.hashWithSalt` theoryDependencies_posTagTheoryList record   `H.hashWithSalt` theoryDependencies_nerTagTheoryList record   `H.hashWithSalt` theoryDependencies_lemmaTheoryList record   `H.hashWithSalt` theoryDependencies_langIdTheoryList record   `H.hashWithSalt` theoryDependencies_parseTheoryList record   `H.hashWithSalt` theoryDependencies_dependencyParseTheoryList record   `H.hashWithSalt` theoryDependencies_tokenAnnotationTheoryList record   `H.hashWithSalt` theoryDependencies_entityMentionSetTheoryList record   `H.hashWithSalt` theoryDependencies_entitySetTheoryList record   `H.hashWithSalt` theoryDependencies_situationMentionSetTheoryList record   `H.hashWithSalt` theoryDependencies_situationSetTheoryList record   `H.hashWithSalt` theoryDependencies_communicationsList record  
instance QC.Arbitrary TheoryDependencies where 
  arbitrary = M.liftM TheoryDependencies (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TheoryDependencies = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TheoryDependencies{theoryDependencies_sectionTheoryList = theoryDependencies_sectionTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_sectionTheoryList = theoryDependencies_sectionTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_sentenceTheoryList = theoryDependencies_sentenceTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_sentenceTheoryList = theoryDependencies_sentenceTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_tokenizationTheoryList = theoryDependencies_tokenizationTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_tokenizationTheoryList = theoryDependencies_tokenizationTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_posTagTheoryList = theoryDependencies_posTagTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_posTagTheoryList = theoryDependencies_posTagTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_nerTagTheoryList = theoryDependencies_nerTagTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_nerTagTheoryList = theoryDependencies_nerTagTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_lemmaTheoryList = theoryDependencies_lemmaTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_lemmaTheoryList = theoryDependencies_lemmaTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_langIdTheoryList = theoryDependencies_langIdTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_langIdTheoryList = theoryDependencies_langIdTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_parseTheoryList = theoryDependencies_parseTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_parseTheoryList = theoryDependencies_parseTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_dependencyParseTheoryList = theoryDependencies_dependencyParseTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_dependencyParseTheoryList = theoryDependencies_dependencyParseTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_tokenAnnotationTheoryList = theoryDependencies_tokenAnnotationTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_tokenAnnotationTheoryList = theoryDependencies_tokenAnnotationTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_entityMentionSetTheoryList = theoryDependencies_entityMentionSetTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_entityMentionSetTheoryList = theoryDependencies_entityMentionSetTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_entitySetTheoryList = theoryDependencies_entitySetTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_entitySetTheoryList = theoryDependencies_entitySetTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_situationMentionSetTheoryList = theoryDependencies_situationMentionSetTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_situationMentionSetTheoryList = theoryDependencies_situationMentionSetTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_situationSetTheoryList = theoryDependencies_situationSetTheoryList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_situationSetTheoryList = theoryDependencies_situationSetTheoryList obj}
    , if obj == default_TheoryDependencies{theoryDependencies_communicationsList = theoryDependencies_communicationsList obj} then P.Nothing else P.Just $ default_TheoryDependencies{theoryDependencies_communicationsList = theoryDependencies_communicationsList obj}
    ]
from_TheoryDependencies :: TheoryDependencies -> T.ThriftVal
from_TheoryDependencies record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("sectionTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v4 -> Uuid_Types.from_UUID _v4) $ Vector.toList _v2))) <$> theoryDependencies_sectionTheoryList record
  , (\_v2 -> (2, ("sentenceTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v6 -> Uuid_Types.from_UUID _v6) $ Vector.toList _v2))) <$> theoryDependencies_sentenceTheoryList record
  , (\_v2 -> (3, ("tokenizationTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v8 -> Uuid_Types.from_UUID _v8) $ Vector.toList _v2))) <$> theoryDependencies_tokenizationTheoryList record
  , (\_v2 -> (4, ("posTagTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v10 -> Uuid_Types.from_UUID _v10) $ Vector.toList _v2))) <$> theoryDependencies_posTagTheoryList record
  , (\_v2 -> (5, ("nerTagTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v12 -> Uuid_Types.from_UUID _v12) $ Vector.toList _v2))) <$> theoryDependencies_nerTagTheoryList record
  , (\_v2 -> (6, ("lemmaTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v14 -> Uuid_Types.from_UUID _v14) $ Vector.toList _v2))) <$> theoryDependencies_lemmaTheoryList record
  , (\_v2 -> (7, ("langIdTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v16 -> Uuid_Types.from_UUID _v16) $ Vector.toList _v2))) <$> theoryDependencies_langIdTheoryList record
  , (\_v2 -> (8, ("parseTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v18 -> Uuid_Types.from_UUID _v18) $ Vector.toList _v2))) <$> theoryDependencies_parseTheoryList record
  , (\_v2 -> (9, ("dependencyParseTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v20 -> Uuid_Types.from_UUID _v20) $ Vector.toList _v2))) <$> theoryDependencies_dependencyParseTheoryList record
  , (\_v2 -> (10, ("tokenAnnotationTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v22 -> Uuid_Types.from_UUID _v22) $ Vector.toList _v2))) <$> theoryDependencies_tokenAnnotationTheoryList record
  , (\_v2 -> (11, ("entityMentionSetTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v24 -> Uuid_Types.from_UUID _v24) $ Vector.toList _v2))) <$> theoryDependencies_entityMentionSetTheoryList record
  , (\_v2 -> (12, ("entitySetTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v26 -> Uuid_Types.from_UUID _v26) $ Vector.toList _v2))) <$> theoryDependencies_entitySetTheoryList record
  , (\_v2 -> (13, ("situationMentionSetTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v28 -> Uuid_Types.from_UUID _v28) $ Vector.toList _v2))) <$> theoryDependencies_situationMentionSetTheoryList record
  , (\_v2 -> (14, ("situationSetTheoryList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v30 -> Uuid_Types.from_UUID _v30) $ Vector.toList _v2))) <$> theoryDependencies_situationSetTheoryList record
  , (\_v2 -> (15, ("communicationsList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v32 -> Uuid_Types.from_UUID _v32) $ Vector.toList _v2))) <$> theoryDependencies_communicationsList record
  ]
write_TheoryDependencies :: (T.Protocol p, T.Transport t) => p t -> TheoryDependencies -> P.IO ()
write_TheoryDependencies oprot record = T.writeVal oprot $ from_TheoryDependencies record
encode_TheoryDependencies :: (T.Protocol p, T.Transport t) => p t -> TheoryDependencies -> LBS.ByteString
encode_TheoryDependencies oprot record = T.serializeVal oprot $ from_TheoryDependencies record
to_TheoryDependencies :: T.ThriftVal -> TheoryDependencies
to_TheoryDependencies (T.TStruct fields) = TheoryDependencies{
  theoryDependencies_sectionTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val35 -> (Vector.fromList $ P.map (\_v36 -> (case _v36 of {T.TStruct _val37 -> (Uuid_Types.to_UUID (T.TStruct _val37)); _ -> P.error "wrong type"})) _val35); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  theoryDependencies_sentenceTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val38 -> (Vector.fromList $ P.map (\_v39 -> (case _v39 of {T.TStruct _val40 -> (Uuid_Types.to_UUID (T.TStruct _val40)); _ -> P.error "wrong type"})) _val38); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  theoryDependencies_tokenizationTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val41 -> (Vector.fromList $ P.map (\_v42 -> (case _v42 of {T.TStruct _val43 -> (Uuid_Types.to_UUID (T.TStruct _val43)); _ -> P.error "wrong type"})) _val41); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  theoryDependencies_posTagTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val44 -> (Vector.fromList $ P.map (\_v45 -> (case _v45 of {T.TStruct _val46 -> (Uuid_Types.to_UUID (T.TStruct _val46)); _ -> P.error "wrong type"})) _val44); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  theoryDependencies_nerTagTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val47 -> (Vector.fromList $ P.map (\_v48 -> (case _v48 of {T.TStruct _val49 -> (Uuid_Types.to_UUID (T.TStruct _val49)); _ -> P.error "wrong type"})) _val47); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  theoryDependencies_lemmaTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val50 -> (Vector.fromList $ P.map (\_v51 -> (case _v51 of {T.TStruct _val52 -> (Uuid_Types.to_UUID (T.TStruct _val52)); _ -> P.error "wrong type"})) _val50); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  theoryDependencies_langIdTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val53 -> (Vector.fromList $ P.map (\_v54 -> (case _v54 of {T.TStruct _val55 -> (Uuid_Types.to_UUID (T.TStruct _val55)); _ -> P.error "wrong type"})) _val53); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  theoryDependencies_parseTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val56 -> (Vector.fromList $ P.map (\_v57 -> (case _v57 of {T.TStruct _val58 -> (Uuid_Types.to_UUID (T.TStruct _val58)); _ -> P.error "wrong type"})) _val56); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  theoryDependencies_dependencyParseTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val59 -> (Vector.fromList $ P.map (\_v60 -> (case _v60 of {T.TStruct _val61 -> (Uuid_Types.to_UUID (T.TStruct _val61)); _ -> P.error "wrong type"})) _val59); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  theoryDependencies_tokenAnnotationTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val62 -> (Vector.fromList $ P.map (\_v63 -> (case _v63 of {T.TStruct _val64 -> (Uuid_Types.to_UUID (T.TStruct _val64)); _ -> P.error "wrong type"})) _val62); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  theoryDependencies_entityMentionSetTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val65 -> (Vector.fromList $ P.map (\_v66 -> (case _v66 of {T.TStruct _val67 -> (Uuid_Types.to_UUID (T.TStruct _val67)); _ -> P.error "wrong type"})) _val65); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  theoryDependencies_entitySetTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val68 -> (Vector.fromList $ P.map (\_v69 -> (case _v69 of {T.TStruct _val70 -> (Uuid_Types.to_UUID (T.TStruct _val70)); _ -> P.error "wrong type"})) _val68); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  theoryDependencies_situationMentionSetTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val71 -> (Vector.fromList $ P.map (\_v72 -> (case _v72 of {T.TStruct _val73 -> (Uuid_Types.to_UUID (T.TStruct _val73)); _ -> P.error "wrong type"})) _val71); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  theoryDependencies_situationSetTheoryList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val74 -> (Vector.fromList $ P.map (\_v75 -> (case _v75 of {T.TStruct _val76 -> (Uuid_Types.to_UUID (T.TStruct _val76)); _ -> P.error "wrong type"})) _val74); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  theoryDependencies_communicationsList = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val77 -> (Vector.fromList $ P.map (\_v78 -> (case _v78 of {T.TStruct _val79 -> (Uuid_Types.to_UUID (T.TStruct _val79)); _ -> P.error "wrong type"})) _val77); _ -> P.error "wrong type"})) (Map.lookup (15) fields)
  }
to_TheoryDependencies _ = P.error "not a struct"
read_TheoryDependencies :: (T.Transport t, T.Protocol p) => p t -> P.IO TheoryDependencies
read_TheoryDependencies iprot = to_TheoryDependencies <$> T.readVal iprot (T.T_STRUCT typemap_TheoryDependencies)
decode_TheoryDependencies :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TheoryDependencies
decode_TheoryDependencies iprot bs = to_TheoryDependencies $ T.deserializeVal iprot (T.T_STRUCT typemap_TheoryDependencies) bs
typemap_TheoryDependencies :: T.TypeMap
typemap_TheoryDependencies = Map.fromList [(1,("sectionTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(2,("sentenceTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(3,("tokenizationTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(4,("posTagTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(5,("nerTagTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(6,("lemmaTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(7,("langIdTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(8,("parseTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(9,("dependencyParseTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(10,("tokenAnnotationTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(11,("entityMentionSetTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(12,("entitySetTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(13,("situationMentionSetTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(14,("situationSetTheoryList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(15,("communicationsList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID))))]
default_TheoryDependencies :: TheoryDependencies
default_TheoryDependencies = TheoryDependencies{
  theoryDependencies_sectionTheoryList = P.Nothing,
  theoryDependencies_sentenceTheoryList = P.Nothing,
  theoryDependencies_tokenizationTheoryList = P.Nothing,
  theoryDependencies_posTagTheoryList = P.Nothing,
  theoryDependencies_nerTagTheoryList = P.Nothing,
  theoryDependencies_lemmaTheoryList = P.Nothing,
  theoryDependencies_langIdTheoryList = P.Nothing,
  theoryDependencies_parseTheoryList = P.Nothing,
  theoryDependencies_dependencyParseTheoryList = P.Nothing,
  theoryDependencies_tokenAnnotationTheoryList = P.Nothing,
  theoryDependencies_entityMentionSetTheoryList = P.Nothing,
  theoryDependencies_entitySetTheoryList = P.Nothing,
  theoryDependencies_situationMentionSetTheoryList = P.Nothing,
  theoryDependencies_situationSetTheoryList = P.Nothing,
  theoryDependencies_communicationsList = P.Nothing}
data Digest = Digest  { digest_bytesValue :: P.Maybe LBS.ByteString
  , digest_int64Value :: P.Maybe I.Int64
  , digest_doubleValue :: P.Maybe P.Double
  , digest_stringValue :: P.Maybe LT.Text
  , digest_int64List :: P.Maybe (Vector.Vector I.Int64)
  , digest_doubleList :: P.Maybe (Vector.Vector P.Double)
  , digest_stringList :: P.Maybe (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Digest where
  hashWithSalt salt record = salt   `H.hashWithSalt` digest_bytesValue record   `H.hashWithSalt` digest_int64Value record   `H.hashWithSalt` digest_doubleValue record   `H.hashWithSalt` digest_stringValue record   `H.hashWithSalt` digest_int64List record   `H.hashWithSalt` digest_doubleList record   `H.hashWithSalt` digest_stringList record  
instance QC.Arbitrary Digest where 
  arbitrary = M.liftM Digest (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Digest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Digest{digest_bytesValue = digest_bytesValue obj} then P.Nothing else P.Just $ default_Digest{digest_bytesValue = digest_bytesValue obj}
    , if obj == default_Digest{digest_int64Value = digest_int64Value obj} then P.Nothing else P.Just $ default_Digest{digest_int64Value = digest_int64Value obj}
    , if obj == default_Digest{digest_doubleValue = digest_doubleValue obj} then P.Nothing else P.Just $ default_Digest{digest_doubleValue = digest_doubleValue obj}
    , if obj == default_Digest{digest_stringValue = digest_stringValue obj} then P.Nothing else P.Just $ default_Digest{digest_stringValue = digest_stringValue obj}
    , if obj == default_Digest{digest_int64List = digest_int64List obj} then P.Nothing else P.Just $ default_Digest{digest_int64List = digest_int64List obj}
    , if obj == default_Digest{digest_doubleList = digest_doubleList obj} then P.Nothing else P.Just $ default_Digest{digest_doubleList = digest_doubleList obj}
    , if obj == default_Digest{digest_stringList = digest_stringList obj} then P.Nothing else P.Just $ default_Digest{digest_stringList = digest_stringList obj}
    ]
from_Digest :: Digest -> T.ThriftVal
from_Digest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v82 -> (1, ("bytesValue",T.TBinary _v82))) <$> digest_bytesValue record
  , (\_v82 -> (2, ("int64Value",T.TI64 _v82))) <$> digest_int64Value record
  , (\_v82 -> (3, ("doubleValue",T.TDouble _v82))) <$> digest_doubleValue record
  , (\_v82 -> (4, ("stringValue",T.TString $ E.encodeUtf8 _v82))) <$> digest_stringValue record
  , (\_v82 -> (5, ("int64List",T.TList T.T_I64 $ P.map (\_v84 -> T.TI64 _v84) $ Vector.toList _v82))) <$> digest_int64List record
  , (\_v82 -> (6, ("doubleList",T.TList T.T_DOUBLE $ P.map (\_v86 -> T.TDouble _v86) $ Vector.toList _v82))) <$> digest_doubleList record
  , (\_v82 -> (7, ("stringList",T.TList T.T_STRING $ P.map (\_v88 -> T.TString $ E.encodeUtf8 _v88) $ Vector.toList _v82))) <$> digest_stringList record
  ]
write_Digest :: (T.Protocol p, T.Transport t) => p t -> Digest -> P.IO ()
write_Digest oprot record = T.writeVal oprot $ from_Digest record
encode_Digest :: (T.Protocol p, T.Transport t) => p t -> Digest -> LBS.ByteString
encode_Digest oprot record = T.serializeVal oprot $ from_Digest record
to_Digest :: T.ThriftVal -> Digest
to_Digest (T.TStruct fields) = Digest{
  digest_bytesValue = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TBinary _val91 -> _val91; T.TString _val91 -> _val91; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  digest_int64Value = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TI64 _val92 -> _val92; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  digest_doubleValue = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TDouble _val93 -> _val93; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  digest_stringValue = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TString _val94 -> E.decodeUtf8 _val94; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  digest_int64List = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TList _ _val95 -> (Vector.fromList $ P.map (\_v96 -> (case _v96 of {T.TI64 _val97 -> _val97; _ -> P.error "wrong type"})) _val95); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  digest_doubleList = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TList _ _val98 -> (Vector.fromList $ P.map (\_v99 -> (case _v99 of {T.TDouble _val100 -> _val100; _ -> P.error "wrong type"})) _val98); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  digest_stringList = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TList _ _val101 -> (Vector.fromList $ P.map (\_v102 -> (case _v102 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) _val101); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_Digest _ = P.error "not a struct"
read_Digest :: (T.Transport t, T.Protocol p) => p t -> P.IO Digest
read_Digest iprot = to_Digest <$> T.readVal iprot (T.T_STRUCT typemap_Digest)
decode_Digest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Digest
decode_Digest iprot bs = to_Digest $ T.deserializeVal iprot (T.T_STRUCT typemap_Digest) bs
typemap_Digest :: T.TypeMap
typemap_Digest = Map.fromList [(1,("bytesValue",T.T_BINARY)),(2,("int64Value",T.T_I64)),(3,("doubleValue",T.T_DOUBLE)),(4,("stringValue",T.T_STRING)),(5,("int64List",(T.T_LIST T.T_I64))),(6,("doubleList",(T.T_LIST T.T_DOUBLE))),(7,("stringList",(T.T_LIST T.T_STRING)))]
default_Digest :: Digest
default_Digest = Digest{
  digest_bytesValue = P.Nothing,
  digest_int64Value = P.Nothing,
  digest_doubleValue = P.Nothing,
  digest_stringValue = P.Nothing,
  digest_int64List = P.Nothing,
  digest_doubleList = P.Nothing,
  digest_stringList = P.Nothing}
data AnnotationMetadata = AnnotationMetadata  { annotationMetadata_tool :: LT.Text
  , annotationMetadata_timestamp :: I.Int64
  , annotationMetadata_digest :: P.Maybe Digest
  , annotationMetadata_dependencies :: P.Maybe TheoryDependencies
  , annotationMetadata_kBest :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AnnotationMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotationMetadata_tool record   `H.hashWithSalt` annotationMetadata_timestamp record   `H.hashWithSalt` annotationMetadata_digest record   `H.hashWithSalt` annotationMetadata_dependencies record   `H.hashWithSalt` annotationMetadata_kBest record  
instance QC.Arbitrary AnnotationMetadata where 
  arbitrary = M.liftM AnnotationMetadata (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AnnotationMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AnnotationMetadata{annotationMetadata_tool = annotationMetadata_tool obj} then P.Nothing else P.Just $ default_AnnotationMetadata{annotationMetadata_tool = annotationMetadata_tool obj}
    , if obj == default_AnnotationMetadata{annotationMetadata_timestamp = annotationMetadata_timestamp obj} then P.Nothing else P.Just $ default_AnnotationMetadata{annotationMetadata_timestamp = annotationMetadata_timestamp obj}
    , if obj == default_AnnotationMetadata{annotationMetadata_digest = annotationMetadata_digest obj} then P.Nothing else P.Just $ default_AnnotationMetadata{annotationMetadata_digest = annotationMetadata_digest obj}
    , if obj == default_AnnotationMetadata{annotationMetadata_dependencies = annotationMetadata_dependencies obj} then P.Nothing else P.Just $ default_AnnotationMetadata{annotationMetadata_dependencies = annotationMetadata_dependencies obj}
    , if obj == default_AnnotationMetadata{annotationMetadata_kBest = annotationMetadata_kBest obj} then P.Nothing else P.Just $ default_AnnotationMetadata{annotationMetadata_kBest = annotationMetadata_kBest obj}
    ]
from_AnnotationMetadata :: AnnotationMetadata -> T.ThriftVal
from_AnnotationMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v106 -> P.Just (1, ("tool",T.TString $ E.encodeUtf8 _v106))) $ annotationMetadata_tool record
  , (\_v106 -> P.Just (2, ("timestamp",T.TI64 _v106))) $ annotationMetadata_timestamp record
  , (\_v106 -> (4, ("digest",from_Digest _v106))) <$> annotationMetadata_digest record
  , (\_v106 -> (5, ("dependencies",from_TheoryDependencies _v106))) <$> annotationMetadata_dependencies record
  , (\_v106 -> P.Just (6, ("kBest",T.TI32 _v106))) $ annotationMetadata_kBest record
  ]
write_AnnotationMetadata :: (T.Protocol p, T.Transport t) => p t -> AnnotationMetadata -> P.IO ()
write_AnnotationMetadata oprot record = T.writeVal oprot $ from_AnnotationMetadata record
encode_AnnotationMetadata :: (T.Protocol p, T.Transport t) => p t -> AnnotationMetadata -> LBS.ByteString
encode_AnnotationMetadata oprot record = T.serializeVal oprot $ from_AnnotationMetadata record
to_AnnotationMetadata :: T.ThriftVal -> AnnotationMetadata
to_AnnotationMetadata (T.TStruct fields) = AnnotationMetadata{
  annotationMetadata_tool = P.maybe (P.error "Missing required field: tool") (\(_,_val108) -> (case _val108 of {T.TString _val109 -> E.decodeUtf8 _val109; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  annotationMetadata_timestamp = P.maybe (P.error "Missing required field: timestamp") (\(_,_val108) -> (case _val108 of {T.TI64 _val110 -> _val110; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  annotationMetadata_digest = P.maybe (P.Nothing) (\(_,_val108) -> P.Just (case _val108 of {T.TStruct _val111 -> (to_Digest (T.TStruct _val111)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  annotationMetadata_dependencies = P.maybe (P.Nothing) (\(_,_val108) -> P.Just (case _val108 of {T.TStruct _val112 -> (to_TheoryDependencies (T.TStruct _val112)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  annotationMetadata_kBest = P.maybe (P.error "Missing required field: kBest") (\(_,_val108) -> (case _val108 of {T.TI32 _val113 -> _val113; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_AnnotationMetadata _ = P.error "not a struct"
read_AnnotationMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO AnnotationMetadata
read_AnnotationMetadata iprot = to_AnnotationMetadata <$> T.readVal iprot (T.T_STRUCT typemap_AnnotationMetadata)
decode_AnnotationMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AnnotationMetadata
decode_AnnotationMetadata iprot bs = to_AnnotationMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_AnnotationMetadata) bs
typemap_AnnotationMetadata :: T.TypeMap
typemap_AnnotationMetadata = Map.fromList [(1,("tool",T.T_STRING)),(2,("timestamp",T.T_I64)),(4,("digest",(T.T_STRUCT typemap_Digest))),(5,("dependencies",(T.T_STRUCT typemap_TheoryDependencies))),(6,("kBest",T.T_I32))]
default_AnnotationMetadata :: AnnotationMetadata
default_AnnotationMetadata = AnnotationMetadata{
  annotationMetadata_tool = "",
  annotationMetadata_timestamp = 0,
  annotationMetadata_digest = P.Nothing,
  annotationMetadata_dependencies = P.Nothing,
  annotationMetadata_kBest = (1)}
data CommunicationMetadata = CommunicationMetadata  { communicationMetadata_tweetInfo :: P.Maybe Twitter_Types.TweetInfo
  , communicationMetadata_emailInfo :: P.Maybe Email_Types.EmailCommunicationInfo
  , communicationMetadata_nitfInfo :: P.Maybe Nitf_Types.NITFInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommunicationMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` communicationMetadata_tweetInfo record   `H.hashWithSalt` communicationMetadata_emailInfo record   `H.hashWithSalt` communicationMetadata_nitfInfo record  
instance QC.Arbitrary CommunicationMetadata where 
  arbitrary = M.liftM CommunicationMetadata (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommunicationMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommunicationMetadata{communicationMetadata_tweetInfo = communicationMetadata_tweetInfo obj} then P.Nothing else P.Just $ default_CommunicationMetadata{communicationMetadata_tweetInfo = communicationMetadata_tweetInfo obj}
    , if obj == default_CommunicationMetadata{communicationMetadata_emailInfo = communicationMetadata_emailInfo obj} then P.Nothing else P.Just $ default_CommunicationMetadata{communicationMetadata_emailInfo = communicationMetadata_emailInfo obj}
    , if obj == default_CommunicationMetadata{communicationMetadata_nitfInfo = communicationMetadata_nitfInfo obj} then P.Nothing else P.Just $ default_CommunicationMetadata{communicationMetadata_nitfInfo = communicationMetadata_nitfInfo obj}
    ]
from_CommunicationMetadata :: CommunicationMetadata -> T.ThriftVal
from_CommunicationMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v116 -> (1, ("tweetInfo",Twitter_Types.from_TweetInfo _v116))) <$> communicationMetadata_tweetInfo record
  , (\_v116 -> (2, ("emailInfo",Email_Types.from_EmailCommunicationInfo _v116))) <$> communicationMetadata_emailInfo record
  , (\_v116 -> (3, ("nitfInfo",Nitf_Types.from_NITFInfo _v116))) <$> communicationMetadata_nitfInfo record
  ]
write_CommunicationMetadata :: (T.Protocol p, T.Transport t) => p t -> CommunicationMetadata -> P.IO ()
write_CommunicationMetadata oprot record = T.writeVal oprot $ from_CommunicationMetadata record
encode_CommunicationMetadata :: (T.Protocol p, T.Transport t) => p t -> CommunicationMetadata -> LBS.ByteString
encode_CommunicationMetadata oprot record = T.serializeVal oprot $ from_CommunicationMetadata record
to_CommunicationMetadata :: T.ThriftVal -> CommunicationMetadata
to_CommunicationMetadata (T.TStruct fields) = CommunicationMetadata{
  communicationMetadata_tweetInfo = P.maybe (P.Nothing) (\(_,_val118) -> P.Just (case _val118 of {T.TStruct _val119 -> (Twitter_Types.to_TweetInfo (T.TStruct _val119)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  communicationMetadata_emailInfo = P.maybe (P.Nothing) (\(_,_val118) -> P.Just (case _val118 of {T.TStruct _val120 -> (Email_Types.to_EmailCommunicationInfo (T.TStruct _val120)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  communicationMetadata_nitfInfo = P.maybe (P.Nothing) (\(_,_val118) -> P.Just (case _val118 of {T.TStruct _val121 -> (Nitf_Types.to_NITFInfo (T.TStruct _val121)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommunicationMetadata _ = P.error "not a struct"
read_CommunicationMetadata :: (T.Transport t, T.Protocol p) => p t -> P.IO CommunicationMetadata
read_CommunicationMetadata iprot = to_CommunicationMetadata <$> T.readVal iprot (T.T_STRUCT typemap_CommunicationMetadata)
decode_CommunicationMetadata :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CommunicationMetadata
decode_CommunicationMetadata iprot bs = to_CommunicationMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_CommunicationMetadata) bs
typemap_CommunicationMetadata :: T.TypeMap
typemap_CommunicationMetadata = Map.fromList [(1,("tweetInfo",(T.T_STRUCT Twitter_Types.typemap_TweetInfo))),(2,("emailInfo",(T.T_STRUCT Email_Types.typemap_EmailCommunicationInfo))),(3,("nitfInfo",(T.T_STRUCT Nitf_Types.typemap_NITFInfo)))]
default_CommunicationMetadata :: CommunicationMetadata
default_CommunicationMetadata = CommunicationMetadata{
  communicationMetadata_tweetInfo = P.Nothing,
  communicationMetadata_emailInfo = P.Nothing,
  communicationMetadata_nitfInfo = P.Nothing}
