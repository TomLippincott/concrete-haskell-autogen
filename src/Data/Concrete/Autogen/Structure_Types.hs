{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Structure_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Spans_Types as Spans_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Language_Types as Language_Types


data TokenizationKind = TOKEN_LIST|TOKEN_LATTICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum TokenizationKind where
  fromEnum t = case t of
    TOKEN_LIST -> 1
    TOKEN_LATTICE -> 2
  toEnum t = case t of
    1 -> TOKEN_LIST
    2 -> TOKEN_LATTICE
    _ -> X.throw T.ThriftException
instance H.Hashable TokenizationKind where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary TokenizationKind where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Constituent = Constituent  { constituent_id :: I.Int32
  , constituent_tag :: P.Maybe LT.Text
  , constituent_childList :: (Vector.Vector I.Int32)
  , constituent_headChildIndex :: P.Maybe I.Int32
  , constituent_start :: P.Maybe I.Int32
  , constituent_ending :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Constituent where
  hashWithSalt salt record = salt   `H.hashWithSalt` constituent_id record   `H.hashWithSalt` constituent_tag record   `H.hashWithSalt` constituent_childList record   `H.hashWithSalt` constituent_headChildIndex record   `H.hashWithSalt` constituent_start record   `H.hashWithSalt` constituent_ending record  
instance QC.Arbitrary Constituent where 
  arbitrary = M.liftM Constituent (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Constituent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Constituent{constituent_id = constituent_id obj} then P.Nothing else P.Just $ default_Constituent{constituent_id = constituent_id obj}
    , if obj == default_Constituent{constituent_tag = constituent_tag obj} then P.Nothing else P.Just $ default_Constituent{constituent_tag = constituent_tag obj}
    , if obj == default_Constituent{constituent_childList = constituent_childList obj} then P.Nothing else P.Just $ default_Constituent{constituent_childList = constituent_childList obj}
    , if obj == default_Constituent{constituent_headChildIndex = constituent_headChildIndex obj} then P.Nothing else P.Just $ default_Constituent{constituent_headChildIndex = constituent_headChildIndex obj}
    , if obj == default_Constituent{constituent_start = constituent_start obj} then P.Nothing else P.Just $ default_Constituent{constituent_start = constituent_start obj}
    , if obj == default_Constituent{constituent_ending = constituent_ending obj} then P.Nothing else P.Just $ default_Constituent{constituent_ending = constituent_ending obj}
    ]
from_Constituent :: Constituent -> T.ThriftVal
from_Constituent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("id",T.TI32 _v2))) $ constituent_id record
  , (\_v2 -> (2, ("tag",T.TString $ E.encodeUtf8 _v2))) <$> constituent_tag record
  , (\_v2 -> P.Just (3, ("childList",T.TList T.T_I32 $ P.map (\_v4 -> T.TI32 _v4) $ Vector.toList _v2))) $ constituent_childList record
  , (\_v2 -> (4, ("headChildIndex",T.TI32 _v2))) <$> constituent_headChildIndex record
  , (\_v2 -> (5, ("start",T.TI32 _v2))) <$> constituent_start record
  , (\_v2 -> (6, ("ending",T.TI32 _v2))) <$> constituent_ending record
  ]
write_Constituent :: (T.Protocol p, T.Transport t) => p t -> Constituent -> P.IO ()
write_Constituent oprot record = T.writeVal oprot $ from_Constituent record
encode_Constituent :: (T.Protocol p, T.Transport t) => p t -> Constituent -> LBS.ByteString
encode_Constituent oprot record = T.serializeVal oprot $ from_Constituent record
to_Constituent :: T.ThriftVal -> Constituent
to_Constituent (T.TStruct fields) = Constituent{
  constituent_id = P.maybe (P.error "Missing required field: id") (\(_,_val6) -> (case _val6 of {T.TI32 _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  constituent_tag = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TString _val8 -> E.decodeUtf8 _val8; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  constituent_childList = P.maybe (P.error "Missing required field: childList") (\(_,_val6) -> (case _val6 of {T.TList _ _val9 -> (Vector.fromList $ P.map (\_v10 -> (case _v10 of {T.TI32 _val11 -> _val11; _ -> P.error "wrong type"})) _val9); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  constituent_headChildIndex = P.maybe (constituent_headChildIndex default_Constituent) (\(_,_val6) -> P.Just (case _val6 of {T.TI32 _val12 -> _val12; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  constituent_start = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TI32 _val13 -> _val13; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  constituent_ending = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TI32 _val14 -> _val14; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_Constituent _ = P.error "not a struct"
read_Constituent :: (T.Transport t, T.Protocol p) => p t -> P.IO Constituent
read_Constituent iprot = to_Constituent <$> T.readVal iprot (T.T_STRUCT typemap_Constituent)
decode_Constituent :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Constituent
decode_Constituent iprot bs = to_Constituent $ T.deserializeVal iprot (T.T_STRUCT typemap_Constituent) bs
typemap_Constituent :: T.TypeMap
typemap_Constituent = Map.fromList [(1,("id",T.T_I32)),(2,("tag",T.T_STRING)),(3,("childList",(T.T_LIST T.T_I32))),(4,("headChildIndex",T.T_I32)),(5,("start",T.T_I32)),(6,("ending",T.T_I32))]
default_Constituent :: Constituent
default_Constituent = Constituent{
  constituent_id = 0,
  constituent_tag = P.Nothing,
  constituent_childList = Vector.empty,
  constituent_headChildIndex = P.Just (-1),
  constituent_start = P.Nothing,
  constituent_ending = P.Nothing}
data Parse = Parse  { parse_uuid :: Uuid_Types.UUID
  , parse_metadata :: Metadata_Types.AnnotationMetadata
  , parse_constituentList :: (Vector.Vector Constituent)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Parse where
  hashWithSalt salt record = salt   `H.hashWithSalt` parse_uuid record   `H.hashWithSalt` parse_metadata record   `H.hashWithSalt` parse_constituentList record  
instance QC.Arbitrary Parse where 
  arbitrary = M.liftM Parse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Parse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Parse{parse_uuid = parse_uuid obj} then P.Nothing else P.Just $ default_Parse{parse_uuid = parse_uuid obj}
    , if obj == default_Parse{parse_metadata = parse_metadata obj} then P.Nothing else P.Just $ default_Parse{parse_metadata = parse_metadata obj}
    , if obj == default_Parse{parse_constituentList = parse_constituentList obj} then P.Nothing else P.Just $ default_Parse{parse_constituentList = parse_constituentList obj}
    ]
from_Parse :: Parse -> T.ThriftVal
from_Parse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v17 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v17))) $ parse_uuid record
  , (\_v17 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v17))) $ parse_metadata record
  , (\_v17 -> P.Just (3, ("constituentList",T.TList (T.T_STRUCT typemap_Constituent) $ P.map (\_v19 -> from_Constituent _v19) $ Vector.toList _v17))) $ parse_constituentList record
  ]
write_Parse :: (T.Protocol p, T.Transport t) => p t -> Parse -> P.IO ()
write_Parse oprot record = T.writeVal oprot $ from_Parse record
encode_Parse :: (T.Protocol p, T.Transport t) => p t -> Parse -> LBS.ByteString
encode_Parse oprot record = T.serializeVal oprot $ from_Parse record
to_Parse :: T.ThriftVal -> Parse
to_Parse (T.TStruct fields) = Parse{
  parse_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val21) -> (case _val21 of {T.TStruct _val22 -> (Uuid_Types.to_UUID (T.TStruct _val22)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  parse_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val21) -> (case _val21 of {T.TStruct _val23 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val23)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  parse_constituentList = P.maybe (P.error "Missing required field: constituentList") (\(_,_val21) -> (case _val21 of {T.TList _ _val24 -> (Vector.fromList $ P.map (\_v25 -> (case _v25 of {T.TStruct _val26 -> (to_Constituent (T.TStruct _val26)); _ -> P.error "wrong type"})) _val24); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Parse _ = P.error "not a struct"
read_Parse :: (T.Transport t, T.Protocol p) => p t -> P.IO Parse
read_Parse iprot = to_Parse <$> T.readVal iprot (T.T_STRUCT typemap_Parse)
decode_Parse :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Parse
decode_Parse iprot bs = to_Parse $ T.deserializeVal iprot (T.T_STRUCT typemap_Parse) bs
typemap_Parse :: T.TypeMap
typemap_Parse = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("constituentList",(T.T_LIST (T.T_STRUCT typemap_Constituent))))]
default_Parse :: Parse
default_Parse = Parse{
  parse_uuid = Uuid_Types.default_UUID,
  parse_metadata = Metadata_Types.default_AnnotationMetadata,
  parse_constituentList = Vector.empty}
data ConstituentRef = ConstituentRef  { constituentRef_parseId :: Uuid_Types.UUID
  , constituentRef_constituentIndex :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConstituentRef where
  hashWithSalt salt record = salt   `H.hashWithSalt` constituentRef_parseId record   `H.hashWithSalt` constituentRef_constituentIndex record  
instance QC.Arbitrary ConstituentRef where 
  arbitrary = M.liftM ConstituentRef (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConstituentRef = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConstituentRef{constituentRef_parseId = constituentRef_parseId obj} then P.Nothing else P.Just $ default_ConstituentRef{constituentRef_parseId = constituentRef_parseId obj}
    , if obj == default_ConstituentRef{constituentRef_constituentIndex = constituentRef_constituentIndex obj} then P.Nothing else P.Just $ default_ConstituentRef{constituentRef_constituentIndex = constituentRef_constituentIndex obj}
    ]
from_ConstituentRef :: ConstituentRef -> T.ThriftVal
from_ConstituentRef record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v29 -> P.Just (1, ("parseId",Uuid_Types.from_UUID _v29))) $ constituentRef_parseId record
  , (\_v29 -> P.Just (2, ("constituentIndex",T.TI32 _v29))) $ constituentRef_constituentIndex record
  ]
write_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> ConstituentRef -> P.IO ()
write_ConstituentRef oprot record = T.writeVal oprot $ from_ConstituentRef record
encode_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> ConstituentRef -> LBS.ByteString
encode_ConstituentRef oprot record = T.serializeVal oprot $ from_ConstituentRef record
to_ConstituentRef :: T.ThriftVal -> ConstituentRef
to_ConstituentRef (T.TStruct fields) = ConstituentRef{
  constituentRef_parseId = P.maybe (P.error "Missing required field: parseId") (\(_,_val31) -> (case _val31 of {T.TStruct _val32 -> (Uuid_Types.to_UUID (T.TStruct _val32)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  constituentRef_constituentIndex = P.maybe (P.error "Missing required field: constituentIndex") (\(_,_val31) -> (case _val31 of {T.TI32 _val33 -> _val33; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConstituentRef _ = P.error "not a struct"
read_ConstituentRef :: (T.Transport t, T.Protocol p) => p t -> P.IO ConstituentRef
read_ConstituentRef iprot = to_ConstituentRef <$> T.readVal iprot (T.T_STRUCT typemap_ConstituentRef)
decode_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConstituentRef
decode_ConstituentRef iprot bs = to_ConstituentRef $ T.deserializeVal iprot (T.T_STRUCT typemap_ConstituentRef) bs
typemap_ConstituentRef :: T.TypeMap
typemap_ConstituentRef = Map.fromList [(1,("parseId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("constituentIndex",T.T_I32))]
default_ConstituentRef :: ConstituentRef
default_ConstituentRef = ConstituentRef{
  constituentRef_parseId = Uuid_Types.default_UUID,
  constituentRef_constituentIndex = 0}
data Dependency = Dependency  { dependency_gov :: P.Maybe I.Int32
  , dependency_dep :: I.Int32
  , dependency_edgeType :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Dependency where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependency_gov record   `H.hashWithSalt` dependency_dep record   `H.hashWithSalt` dependency_edgeType record  
instance QC.Arbitrary Dependency where 
  arbitrary = M.liftM Dependency (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Dependency = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Dependency{dependency_gov = dependency_gov obj} then P.Nothing else P.Just $ default_Dependency{dependency_gov = dependency_gov obj}
    , if obj == default_Dependency{dependency_dep = dependency_dep obj} then P.Nothing else P.Just $ default_Dependency{dependency_dep = dependency_dep obj}
    , if obj == default_Dependency{dependency_edgeType = dependency_edgeType obj} then P.Nothing else P.Just $ default_Dependency{dependency_edgeType = dependency_edgeType obj}
    ]
from_Dependency :: Dependency -> T.ThriftVal
from_Dependency record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v36 -> (1, ("gov",T.TI32 _v36))) <$> dependency_gov record
  , (\_v36 -> P.Just (2, ("dep",T.TI32 _v36))) $ dependency_dep record
  , (\_v36 -> (3, ("edgeType",T.TString $ E.encodeUtf8 _v36))) <$> dependency_edgeType record
  ]
write_Dependency :: (T.Protocol p, T.Transport t) => p t -> Dependency -> P.IO ()
write_Dependency oprot record = T.writeVal oprot $ from_Dependency record
encode_Dependency :: (T.Protocol p, T.Transport t) => p t -> Dependency -> LBS.ByteString
encode_Dependency oprot record = T.serializeVal oprot $ from_Dependency record
to_Dependency :: T.ThriftVal -> Dependency
to_Dependency (T.TStruct fields) = Dependency{
  dependency_gov = P.maybe (dependency_gov default_Dependency) (\(_,_val38) -> P.Just (case _val38 of {T.TI32 _val39 -> _val39; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependency_dep = P.maybe (P.error "Missing required field: dep") (\(_,_val38) -> (case _val38 of {T.TI32 _val40 -> _val40; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependency_edgeType = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Dependency _ = P.error "not a struct"
read_Dependency :: (T.Transport t, T.Protocol p) => p t -> P.IO Dependency
read_Dependency iprot = to_Dependency <$> T.readVal iprot (T.T_STRUCT typemap_Dependency)
decode_Dependency :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Dependency
decode_Dependency iprot bs = to_Dependency $ T.deserializeVal iprot (T.T_STRUCT typemap_Dependency) bs
typemap_Dependency :: T.TypeMap
typemap_Dependency = Map.fromList [(1,("gov",T.T_I32)),(2,("dep",T.T_I32)),(3,("edgeType",T.T_STRING))]
default_Dependency :: Dependency
default_Dependency = Dependency{
  dependency_gov = P.Just (-1),
  dependency_dep = 0,
  dependency_edgeType = P.Nothing}
data DependencyParseStructure = DependencyParseStructure  { dependencyParseStructure_isAcyclic :: P.Bool
  , dependencyParseStructure_isConnected :: P.Bool
  , dependencyParseStructure_isSingleHeaded :: P.Bool
  , dependencyParseStructure_isProjective :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DependencyParseStructure where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependencyParseStructure_isAcyclic record   `H.hashWithSalt` dependencyParseStructure_isConnected record   `H.hashWithSalt` dependencyParseStructure_isSingleHeaded record   `H.hashWithSalt` dependencyParseStructure_isProjective record  
instance QC.Arbitrary DependencyParseStructure where 
  arbitrary = M.liftM DependencyParseStructure (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DependencyParseStructure = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DependencyParseStructure{dependencyParseStructure_isAcyclic = dependencyParseStructure_isAcyclic obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isAcyclic = dependencyParseStructure_isAcyclic obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isConnected = dependencyParseStructure_isConnected obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isConnected = dependencyParseStructure_isConnected obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isSingleHeaded = dependencyParseStructure_isSingleHeaded obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isSingleHeaded = dependencyParseStructure_isSingleHeaded obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isProjective = dependencyParseStructure_isProjective obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isProjective = dependencyParseStructure_isProjective obj}
    ]
from_DependencyParseStructure :: DependencyParseStructure -> T.ThriftVal
from_DependencyParseStructure record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v44 -> P.Just (1, ("isAcyclic",T.TBool _v44))) $ dependencyParseStructure_isAcyclic record
  , (\_v44 -> P.Just (2, ("isConnected",T.TBool _v44))) $ dependencyParseStructure_isConnected record
  , (\_v44 -> P.Just (3, ("isSingleHeaded",T.TBool _v44))) $ dependencyParseStructure_isSingleHeaded record
  , (\_v44 -> P.Just (4, ("isProjective",T.TBool _v44))) $ dependencyParseStructure_isProjective record
  ]
write_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> DependencyParseStructure -> P.IO ()
write_DependencyParseStructure oprot record = T.writeVal oprot $ from_DependencyParseStructure record
encode_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> DependencyParseStructure -> LBS.ByteString
encode_DependencyParseStructure oprot record = T.serializeVal oprot $ from_DependencyParseStructure record
to_DependencyParseStructure :: T.ThriftVal -> DependencyParseStructure
to_DependencyParseStructure (T.TStruct fields) = DependencyParseStructure{
  dependencyParseStructure_isAcyclic = P.maybe (P.error "Missing required field: isAcyclic") (\(_,_val46) -> (case _val46 of {T.TBool _val47 -> _val47; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependencyParseStructure_isConnected = P.maybe (P.error "Missing required field: isConnected") (\(_,_val46) -> (case _val46 of {T.TBool _val48 -> _val48; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependencyParseStructure_isSingleHeaded = P.maybe (P.error "Missing required field: isSingleHeaded") (\(_,_val46) -> (case _val46 of {T.TBool _val49 -> _val49; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  dependencyParseStructure_isProjective = P.maybe (P.error "Missing required field: isProjective") (\(_,_val46) -> (case _val46 of {T.TBool _val50 -> _val50; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DependencyParseStructure _ = P.error "not a struct"
read_DependencyParseStructure :: (T.Transport t, T.Protocol p) => p t -> P.IO DependencyParseStructure
read_DependencyParseStructure iprot = to_DependencyParseStructure <$> T.readVal iprot (T.T_STRUCT typemap_DependencyParseStructure)
decode_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DependencyParseStructure
decode_DependencyParseStructure iprot bs = to_DependencyParseStructure $ T.deserializeVal iprot (T.T_STRUCT typemap_DependencyParseStructure) bs
typemap_DependencyParseStructure :: T.TypeMap
typemap_DependencyParseStructure = Map.fromList [(1,("isAcyclic",T.T_BOOL)),(2,("isConnected",T.T_BOOL)),(3,("isSingleHeaded",T.T_BOOL)),(4,("isProjective",T.T_BOOL))]
default_DependencyParseStructure :: DependencyParseStructure
default_DependencyParseStructure = DependencyParseStructure{
  dependencyParseStructure_isAcyclic = P.False,
  dependencyParseStructure_isConnected = P.False,
  dependencyParseStructure_isSingleHeaded = P.False,
  dependencyParseStructure_isProjective = P.False}
data DependencyParse = DependencyParse  { dependencyParse_uuid :: Uuid_Types.UUID
  , dependencyParse_metadata :: Metadata_Types.AnnotationMetadata
  , dependencyParse_dependencyList :: (Vector.Vector Dependency)
  , dependencyParse_structureInformation :: P.Maybe DependencyParseStructure
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DependencyParse where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependencyParse_uuid record   `H.hashWithSalt` dependencyParse_metadata record   `H.hashWithSalt` dependencyParse_dependencyList record   `H.hashWithSalt` dependencyParse_structureInformation record  
instance QC.Arbitrary DependencyParse where 
  arbitrary = M.liftM DependencyParse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DependencyParse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DependencyParse{dependencyParse_uuid = dependencyParse_uuid obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_uuid = dependencyParse_uuid obj}
    , if obj == default_DependencyParse{dependencyParse_metadata = dependencyParse_metadata obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_metadata = dependencyParse_metadata obj}
    , if obj == default_DependencyParse{dependencyParse_dependencyList = dependencyParse_dependencyList obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_dependencyList = dependencyParse_dependencyList obj}
    , if obj == default_DependencyParse{dependencyParse_structureInformation = dependencyParse_structureInformation obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_structureInformation = dependencyParse_structureInformation obj}
    ]
from_DependencyParse :: DependencyParse -> T.ThriftVal
from_DependencyParse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v53 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v53))) $ dependencyParse_uuid record
  , (\_v53 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v53))) $ dependencyParse_metadata record
  , (\_v53 -> P.Just (3, ("dependencyList",T.TList (T.T_STRUCT typemap_Dependency) $ P.map (\_v55 -> from_Dependency _v55) $ Vector.toList _v53))) $ dependencyParse_dependencyList record
  , (\_v53 -> (4, ("structureInformation",from_DependencyParseStructure _v53))) <$> dependencyParse_structureInformation record
  ]
write_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> DependencyParse -> P.IO ()
write_DependencyParse oprot record = T.writeVal oprot $ from_DependencyParse record
encode_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> DependencyParse -> LBS.ByteString
encode_DependencyParse oprot record = T.serializeVal oprot $ from_DependencyParse record
to_DependencyParse :: T.ThriftVal -> DependencyParse
to_DependencyParse (T.TStruct fields) = DependencyParse{
  dependencyParse_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val57) -> (case _val57 of {T.TStruct _val58 -> (Uuid_Types.to_UUID (T.TStruct _val58)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependencyParse_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val57) -> (case _val57 of {T.TStruct _val59 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val59)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependencyParse_dependencyList = P.maybe (P.error "Missing required field: dependencyList") (\(_,_val57) -> (case _val57 of {T.TList _ _val60 -> (Vector.fromList $ P.map (\_v61 -> (case _v61 of {T.TStruct _val62 -> (to_Dependency (T.TStruct _val62)); _ -> P.error "wrong type"})) _val60); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  dependencyParse_structureInformation = P.maybe (P.Nothing) (\(_,_val57) -> P.Just (case _val57 of {T.TStruct _val63 -> (to_DependencyParseStructure (T.TStruct _val63)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DependencyParse _ = P.error "not a struct"
read_DependencyParse :: (T.Transport t, T.Protocol p) => p t -> P.IO DependencyParse
read_DependencyParse iprot = to_DependencyParse <$> T.readVal iprot (T.T_STRUCT typemap_DependencyParse)
decode_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DependencyParse
decode_DependencyParse iprot bs = to_DependencyParse $ T.deserializeVal iprot (T.T_STRUCT typemap_DependencyParse) bs
typemap_DependencyParse :: T.TypeMap
typemap_DependencyParse = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("dependencyList",(T.T_LIST (T.T_STRUCT typemap_Dependency)))),(4,("structureInformation",(T.T_STRUCT typemap_DependencyParseStructure)))]
default_DependencyParse :: DependencyParse
default_DependencyParse = DependencyParse{
  dependencyParse_uuid = Uuid_Types.default_UUID,
  dependencyParse_metadata = Metadata_Types.default_AnnotationMetadata,
  dependencyParse_dependencyList = Vector.empty,
  dependencyParse_structureInformation = P.Nothing}
data Token = Token  { token_tokenIndex :: I.Int32
  , token_text :: P.Maybe LT.Text
  , token_textSpan :: P.Maybe Spans_Types.TextSpan
  , token_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , token_audioSpan :: P.Maybe Spans_Types.AudioSpan
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Token where
  hashWithSalt salt record = salt   `H.hashWithSalt` token_tokenIndex record   `H.hashWithSalt` token_text record   `H.hashWithSalt` token_textSpan record   `H.hashWithSalt` token_rawTextSpan record   `H.hashWithSalt` token_audioSpan record  
instance QC.Arbitrary Token where 
  arbitrary = M.liftM Token (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Token = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Token{token_tokenIndex = token_tokenIndex obj} then P.Nothing else P.Just $ default_Token{token_tokenIndex = token_tokenIndex obj}
    , if obj == default_Token{token_text = token_text obj} then P.Nothing else P.Just $ default_Token{token_text = token_text obj}
    , if obj == default_Token{token_textSpan = token_textSpan obj} then P.Nothing else P.Just $ default_Token{token_textSpan = token_textSpan obj}
    , if obj == default_Token{token_rawTextSpan = token_rawTextSpan obj} then P.Nothing else P.Just $ default_Token{token_rawTextSpan = token_rawTextSpan obj}
    , if obj == default_Token{token_audioSpan = token_audioSpan obj} then P.Nothing else P.Just $ default_Token{token_audioSpan = token_audioSpan obj}
    ]
from_Token :: Token -> T.ThriftVal
from_Token record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v66 -> P.Just (1, ("tokenIndex",T.TI32 _v66))) $ token_tokenIndex record
  , (\_v66 -> (2, ("text",T.TString $ E.encodeUtf8 _v66))) <$> token_text record
  , (\_v66 -> (3, ("textSpan",Spans_Types.from_TextSpan _v66))) <$> token_textSpan record
  , (\_v66 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v66))) <$> token_rawTextSpan record
  , (\_v66 -> (5, ("audioSpan",Spans_Types.from_AudioSpan _v66))) <$> token_audioSpan record
  ]
write_Token :: (T.Protocol p, T.Transport t) => p t -> Token -> P.IO ()
write_Token oprot record = T.writeVal oprot $ from_Token record
encode_Token :: (T.Protocol p, T.Transport t) => p t -> Token -> LBS.ByteString
encode_Token oprot record = T.serializeVal oprot $ from_Token record
to_Token :: T.ThriftVal -> Token
to_Token (T.TStruct fields) = Token{
  token_tokenIndex = P.maybe (P.error "Missing required field: tokenIndex") (\(_,_val68) -> (case _val68 of {T.TI32 _val69 -> _val69; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  token_text = P.maybe (P.Nothing) (\(_,_val68) -> P.Just (case _val68 of {T.TString _val70 -> E.decodeUtf8 _val70; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  token_textSpan = P.maybe (P.Nothing) (\(_,_val68) -> P.Just (case _val68 of {T.TStruct _val71 -> (Spans_Types.to_TextSpan (T.TStruct _val71)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  token_rawTextSpan = P.maybe (P.Nothing) (\(_,_val68) -> P.Just (case _val68 of {T.TStruct _val72 -> (Spans_Types.to_TextSpan (T.TStruct _val72)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  token_audioSpan = P.maybe (P.Nothing) (\(_,_val68) -> P.Just (case _val68 of {T.TStruct _val73 -> (Spans_Types.to_AudioSpan (T.TStruct _val73)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Token _ = P.error "not a struct"
read_Token :: (T.Transport t, T.Protocol p) => p t -> P.IO Token
read_Token iprot = to_Token <$> T.readVal iprot (T.T_STRUCT typemap_Token)
decode_Token :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Token
decode_Token iprot bs = to_Token $ T.deserializeVal iprot (T.T_STRUCT typemap_Token) bs
typemap_Token :: T.TypeMap
typemap_Token = Map.fromList [(1,("tokenIndex",T.T_I32)),(2,("text",T.T_STRING)),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Token :: Token
default_Token = Token{
  token_tokenIndex = 0,
  token_text = P.Nothing,
  token_textSpan = P.Nothing,
  token_rawTextSpan = P.Nothing,
  token_audioSpan = P.Nothing}
data TokenRefSequence = TokenRefSequence  { tokenRefSequence_tokenIndexList :: (Vector.Vector I.Int32)
  , tokenRefSequence_anchorTokenIndex :: P.Maybe I.Int32
  , tokenRefSequence_tokenizationId :: Uuid_Types.UUID
  , tokenRefSequence_textSpan :: P.Maybe Spans_Types.TextSpan
  , tokenRefSequence_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , tokenRefSequence_audioSpan :: P.Maybe Spans_Types.AudioSpan
  , tokenRefSequence_dependencies :: P.Maybe (Vector.Vector Dependency)
  , tokenRefSequence_constituent :: P.Maybe ConstituentRef
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenRefSequence where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenRefSequence_tokenIndexList record   `H.hashWithSalt` tokenRefSequence_anchorTokenIndex record   `H.hashWithSalt` tokenRefSequence_tokenizationId record   `H.hashWithSalt` tokenRefSequence_textSpan record   `H.hashWithSalt` tokenRefSequence_rawTextSpan record   `H.hashWithSalt` tokenRefSequence_audioSpan record   `H.hashWithSalt` tokenRefSequence_dependencies record   `H.hashWithSalt` tokenRefSequence_constituent record  
instance QC.Arbitrary TokenRefSequence where 
  arbitrary = M.liftM TokenRefSequence (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenRefSequence = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenRefSequence{tokenRefSequence_tokenIndexList = tokenRefSequence_tokenIndexList obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_tokenIndexList = tokenRefSequence_tokenIndexList obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_anchorTokenIndex = tokenRefSequence_anchorTokenIndex obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_anchorTokenIndex = tokenRefSequence_anchorTokenIndex obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_tokenizationId = tokenRefSequence_tokenizationId obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_tokenizationId = tokenRefSequence_tokenizationId obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_textSpan = tokenRefSequence_textSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_textSpan = tokenRefSequence_textSpan obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_rawTextSpan = tokenRefSequence_rawTextSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_rawTextSpan = tokenRefSequence_rawTextSpan obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_audioSpan = tokenRefSequence_audioSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_audioSpan = tokenRefSequence_audioSpan obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_dependencies = tokenRefSequence_dependencies obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_dependencies = tokenRefSequence_dependencies obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_constituent = tokenRefSequence_constituent obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_constituent = tokenRefSequence_constituent obj}
    ]
from_TokenRefSequence :: TokenRefSequence -> T.ThriftVal
from_TokenRefSequence record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v76 -> P.Just (1, ("tokenIndexList",T.TList T.T_I32 $ P.map (\_v78 -> T.TI32 _v78) $ Vector.toList _v76))) $ tokenRefSequence_tokenIndexList record
  , (\_v76 -> (2, ("anchorTokenIndex",T.TI32 _v76))) <$> tokenRefSequence_anchorTokenIndex record
  , (\_v76 -> P.Just (3, ("tokenizationId",Uuid_Types.from_UUID _v76))) $ tokenRefSequence_tokenizationId record
  , (\_v76 -> (4, ("textSpan",Spans_Types.from_TextSpan _v76))) <$> tokenRefSequence_textSpan record
  , (\_v76 -> (5, ("rawTextSpan",Spans_Types.from_TextSpan _v76))) <$> tokenRefSequence_rawTextSpan record
  , (\_v76 -> (6, ("audioSpan",Spans_Types.from_AudioSpan _v76))) <$> tokenRefSequence_audioSpan record
  , (\_v76 -> (7, ("dependencies",T.TList (T.T_STRUCT typemap_Dependency) $ P.map (\_v80 -> from_Dependency _v80) $ Vector.toList _v76))) <$> tokenRefSequence_dependencies record
  , (\_v76 -> (8, ("constituent",from_ConstituentRef _v76))) <$> tokenRefSequence_constituent record
  ]
write_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> TokenRefSequence -> P.IO ()
write_TokenRefSequence oprot record = T.writeVal oprot $ from_TokenRefSequence record
encode_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> TokenRefSequence -> LBS.ByteString
encode_TokenRefSequence oprot record = T.serializeVal oprot $ from_TokenRefSequence record
to_TokenRefSequence :: T.ThriftVal -> TokenRefSequence
to_TokenRefSequence (T.TStruct fields) = TokenRefSequence{
  tokenRefSequence_tokenIndexList = P.maybe (P.error "Missing required field: tokenIndexList") (\(_,_val82) -> (case _val82 of {T.TList _ _val83 -> (Vector.fromList $ P.map (\_v84 -> (case _v84 of {T.TI32 _val85 -> _val85; _ -> P.error "wrong type"})) _val83); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenRefSequence_anchorTokenIndex = P.maybe (tokenRefSequence_anchorTokenIndex default_TokenRefSequence) (\(_,_val82) -> P.Just (case _val82 of {T.TI32 _val86 -> _val86; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenRefSequence_tokenizationId = P.maybe (P.error "Missing required field: tokenizationId") (\(_,_val82) -> (case _val82 of {T.TStruct _val87 -> (Uuid_Types.to_UUID (T.TStruct _val87)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenRefSequence_textSpan = P.maybe (P.Nothing) (\(_,_val82) -> P.Just (case _val82 of {T.TStruct _val88 -> (Spans_Types.to_TextSpan (T.TStruct _val88)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tokenRefSequence_rawTextSpan = P.maybe (P.Nothing) (\(_,_val82) -> P.Just (case _val82 of {T.TStruct _val89 -> (Spans_Types.to_TextSpan (T.TStruct _val89)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tokenRefSequence_audioSpan = P.maybe (P.Nothing) (\(_,_val82) -> P.Just (case _val82 of {T.TStruct _val90 -> (Spans_Types.to_AudioSpan (T.TStruct _val90)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tokenRefSequence_dependencies = P.maybe (P.Nothing) (\(_,_val82) -> P.Just (case _val82 of {T.TList _ _val91 -> (Vector.fromList $ P.map (\_v92 -> (case _v92 of {T.TStruct _val93 -> (to_Dependency (T.TStruct _val93)); _ -> P.error "wrong type"})) _val91); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tokenRefSequence_constituent = P.maybe (P.Nothing) (\(_,_val82) -> P.Just (case _val82 of {T.TStruct _val94 -> (to_ConstituentRef (T.TStruct _val94)); _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_TokenRefSequence _ = P.error "not a struct"
read_TokenRefSequence :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenRefSequence
read_TokenRefSequence iprot = to_TokenRefSequence <$> T.readVal iprot (T.T_STRUCT typemap_TokenRefSequence)
decode_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenRefSequence
decode_TokenRefSequence iprot bs = to_TokenRefSequence $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenRefSequence) bs
typemap_TokenRefSequence :: T.TypeMap
typemap_TokenRefSequence = Map.fromList [(1,("tokenIndexList",(T.T_LIST T.T_I32))),(2,("anchorTokenIndex",T.T_I32)),(3,("tokenizationId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(4,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(6,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan))),(7,("dependencies",(T.T_LIST (T.T_STRUCT typemap_Dependency)))),(8,("constituent",(T.T_STRUCT typemap_ConstituentRef)))]
default_TokenRefSequence :: TokenRefSequence
default_TokenRefSequence = TokenRefSequence{
  tokenRefSequence_tokenIndexList = Vector.empty,
  tokenRefSequence_anchorTokenIndex = P.Just (-1),
  tokenRefSequence_tokenizationId = Uuid_Types.default_UUID,
  tokenRefSequence_textSpan = P.Nothing,
  tokenRefSequence_rawTextSpan = P.Nothing,
  tokenRefSequence_audioSpan = P.Nothing,
  tokenRefSequence_dependencies = P.Nothing,
  tokenRefSequence_constituent = P.Nothing}
data TaggedToken = TaggedToken  { taggedToken_tokenIndex :: P.Maybe I.Int32
  , taggedToken_tag :: P.Maybe LT.Text
  , taggedToken_confidence :: P.Maybe P.Double
  , taggedToken_tagList :: P.Maybe (Vector.Vector LT.Text)
  , taggedToken_confidenceList :: P.Maybe (Vector.Vector P.Double)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TaggedToken where
  hashWithSalt salt record = salt   `H.hashWithSalt` taggedToken_tokenIndex record   `H.hashWithSalt` taggedToken_tag record   `H.hashWithSalt` taggedToken_confidence record   `H.hashWithSalt` taggedToken_tagList record   `H.hashWithSalt` taggedToken_confidenceList record  
instance QC.Arbitrary TaggedToken where 
  arbitrary = M.liftM TaggedToken (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TaggedToken = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaggedToken{taggedToken_tokenIndex = taggedToken_tokenIndex obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tokenIndex = taggedToken_tokenIndex obj}
    , if obj == default_TaggedToken{taggedToken_tag = taggedToken_tag obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tag = taggedToken_tag obj}
    , if obj == default_TaggedToken{taggedToken_confidence = taggedToken_confidence obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_confidence = taggedToken_confidence obj}
    , if obj == default_TaggedToken{taggedToken_tagList = taggedToken_tagList obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tagList = taggedToken_tagList obj}
    , if obj == default_TaggedToken{taggedToken_confidenceList = taggedToken_confidenceList obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_confidenceList = taggedToken_confidenceList obj}
    ]
from_TaggedToken :: TaggedToken -> T.ThriftVal
from_TaggedToken record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v97 -> (1, ("tokenIndex",T.TI32 _v97))) <$> taggedToken_tokenIndex record
  , (\_v97 -> (2, ("tag",T.TString $ E.encodeUtf8 _v97))) <$> taggedToken_tag record
  , (\_v97 -> (3, ("confidence",T.TDouble _v97))) <$> taggedToken_confidence record
  , (\_v97 -> (4, ("tagList",T.TList T.T_STRING $ P.map (\_v99 -> T.TString $ E.encodeUtf8 _v99) $ Vector.toList _v97))) <$> taggedToken_tagList record
  , (\_v97 -> (5, ("confidenceList",T.TList T.T_DOUBLE $ P.map (\_v101 -> T.TDouble _v101) $ Vector.toList _v97))) <$> taggedToken_confidenceList record
  ]
write_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> TaggedToken -> P.IO ()
write_TaggedToken oprot record = T.writeVal oprot $ from_TaggedToken record
encode_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> TaggedToken -> LBS.ByteString
encode_TaggedToken oprot record = T.serializeVal oprot $ from_TaggedToken record
to_TaggedToken :: T.ThriftVal -> TaggedToken
to_TaggedToken (T.TStruct fields) = TaggedToken{
  taggedToken_tokenIndex = P.maybe (P.Nothing) (\(_,_val103) -> P.Just (case _val103 of {T.TI32 _val104 -> _val104; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  taggedToken_tag = P.maybe (P.Nothing) (\(_,_val103) -> P.Just (case _val103 of {T.TString _val105 -> E.decodeUtf8 _val105; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  taggedToken_confidence = P.maybe (P.Nothing) (\(_,_val103) -> P.Just (case _val103 of {T.TDouble _val106 -> _val106; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  taggedToken_tagList = P.maybe (P.Nothing) (\(_,_val103) -> P.Just (case _val103 of {T.TList _ _val107 -> (Vector.fromList $ P.map (\_v108 -> (case _v108 of {T.TString _val109 -> E.decodeUtf8 _val109; _ -> P.error "wrong type"})) _val107); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  taggedToken_confidenceList = P.maybe (P.Nothing) (\(_,_val103) -> P.Just (case _val103 of {T.TList _ _val110 -> (Vector.fromList $ P.map (\_v111 -> (case _v111 of {T.TDouble _val112 -> _val112; _ -> P.error "wrong type"})) _val110); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_TaggedToken _ = P.error "not a struct"
read_TaggedToken :: (T.Transport t, T.Protocol p) => p t -> P.IO TaggedToken
read_TaggedToken iprot = to_TaggedToken <$> T.readVal iprot (T.T_STRUCT typemap_TaggedToken)
decode_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaggedToken
decode_TaggedToken iprot bs = to_TaggedToken $ T.deserializeVal iprot (T.T_STRUCT typemap_TaggedToken) bs
typemap_TaggedToken :: T.TypeMap
typemap_TaggedToken = Map.fromList [(1,("tokenIndex",T.T_I32)),(2,("tag",T.T_STRING)),(3,("confidence",T.T_DOUBLE)),(4,("tagList",(T.T_LIST T.T_STRING))),(5,("confidenceList",(T.T_LIST T.T_DOUBLE)))]
default_TaggedToken :: TaggedToken
default_TaggedToken = TaggedToken{
  taggedToken_tokenIndex = P.Nothing,
  taggedToken_tag = P.Nothing,
  taggedToken_confidence = P.Nothing,
  taggedToken_tagList = P.Nothing,
  taggedToken_confidenceList = P.Nothing}
data TokenTagging = TokenTagging  { tokenTagging_uuid :: Uuid_Types.UUID
  , tokenTagging_metadata :: Metadata_Types.AnnotationMetadata
  , tokenTagging_taggedTokenList :: (Vector.Vector TaggedToken)
  , tokenTagging_taggingType :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenTagging where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenTagging_uuid record   `H.hashWithSalt` tokenTagging_metadata record   `H.hashWithSalt` tokenTagging_taggedTokenList record   `H.hashWithSalt` tokenTagging_taggingType record  
instance QC.Arbitrary TokenTagging where 
  arbitrary = M.liftM TokenTagging (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenTagging = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenTagging{tokenTagging_uuid = tokenTagging_uuid obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_uuid = tokenTagging_uuid obj}
    , if obj == default_TokenTagging{tokenTagging_metadata = tokenTagging_metadata obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_metadata = tokenTagging_metadata obj}
    , if obj == default_TokenTagging{tokenTagging_taggedTokenList = tokenTagging_taggedTokenList obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_taggedTokenList = tokenTagging_taggedTokenList obj}
    , if obj == default_TokenTagging{tokenTagging_taggingType = tokenTagging_taggingType obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_taggingType = tokenTagging_taggingType obj}
    ]
from_TokenTagging :: TokenTagging -> T.ThriftVal
from_TokenTagging record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v115 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v115))) $ tokenTagging_uuid record
  , (\_v115 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v115))) $ tokenTagging_metadata record
  , (\_v115 -> P.Just (3, ("taggedTokenList",T.TList (T.T_STRUCT typemap_TaggedToken) $ P.map (\_v117 -> from_TaggedToken _v117) $ Vector.toList _v115))) $ tokenTagging_taggedTokenList record
  , (\_v115 -> (4, ("taggingType",T.TString $ E.encodeUtf8 _v115))) <$> tokenTagging_taggingType record
  ]
write_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> TokenTagging -> P.IO ()
write_TokenTagging oprot record = T.writeVal oprot $ from_TokenTagging record
encode_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> TokenTagging -> LBS.ByteString
encode_TokenTagging oprot record = T.serializeVal oprot $ from_TokenTagging record
to_TokenTagging :: T.ThriftVal -> TokenTagging
to_TokenTagging (T.TStruct fields) = TokenTagging{
  tokenTagging_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val119) -> (case _val119 of {T.TStruct _val120 -> (Uuid_Types.to_UUID (T.TStruct _val120)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenTagging_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val119) -> (case _val119 of {T.TStruct _val121 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val121)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenTagging_taggedTokenList = P.maybe (P.error "Missing required field: taggedTokenList") (\(_,_val119) -> (case _val119 of {T.TList _ _val122 -> (Vector.fromList $ P.map (\_v123 -> (case _v123 of {T.TStruct _val124 -> (to_TaggedToken (T.TStruct _val124)); _ -> P.error "wrong type"})) _val122); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenTagging_taggingType = P.maybe (P.Nothing) (\(_,_val119) -> P.Just (case _val119 of {T.TString _val125 -> E.decodeUtf8 _val125; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TokenTagging _ = P.error "not a struct"
read_TokenTagging :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenTagging
read_TokenTagging iprot = to_TokenTagging <$> T.readVal iprot (T.T_STRUCT typemap_TokenTagging)
decode_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenTagging
decode_TokenTagging iprot bs = to_TokenTagging $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenTagging) bs
typemap_TokenTagging :: T.TypeMap
typemap_TokenTagging = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("taggedTokenList",(T.T_LIST (T.T_STRUCT typemap_TaggedToken)))),(4,("taggingType",T.T_STRING))]
default_TokenTagging :: TokenTagging
default_TokenTagging = TokenTagging{
  tokenTagging_uuid = Uuid_Types.default_UUID,
  tokenTagging_metadata = Metadata_Types.default_AnnotationMetadata,
  tokenTagging_taggedTokenList = Vector.empty,
  tokenTagging_taggingType = P.Nothing}
data LatticePath = LatticePath  { latticePath_weight :: P.Maybe P.Double
  , latticePath_tokenList :: (Vector.Vector Token)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LatticePath where
  hashWithSalt salt record = salt   `H.hashWithSalt` latticePath_weight record   `H.hashWithSalt` latticePath_tokenList record  
instance QC.Arbitrary LatticePath where 
  arbitrary = M.liftM LatticePath (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LatticePath = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LatticePath{latticePath_weight = latticePath_weight obj} then P.Nothing else P.Just $ default_LatticePath{latticePath_weight = latticePath_weight obj}
    , if obj == default_LatticePath{latticePath_tokenList = latticePath_tokenList obj} then P.Nothing else P.Just $ default_LatticePath{latticePath_tokenList = latticePath_tokenList obj}
    ]
from_LatticePath :: LatticePath -> T.ThriftVal
from_LatticePath record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v128 -> (1, ("weight",T.TDouble _v128))) <$> latticePath_weight record
  , (\_v128 -> P.Just (2, ("tokenList",T.TList (T.T_STRUCT typemap_Token) $ P.map (\_v130 -> from_Token _v130) $ Vector.toList _v128))) $ latticePath_tokenList record
  ]
write_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LatticePath -> P.IO ()
write_LatticePath oprot record = T.writeVal oprot $ from_LatticePath record
encode_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LatticePath -> LBS.ByteString
encode_LatticePath oprot record = T.serializeVal oprot $ from_LatticePath record
to_LatticePath :: T.ThriftVal -> LatticePath
to_LatticePath (T.TStruct fields) = LatticePath{
  latticePath_weight = P.maybe (P.Nothing) (\(_,_val132) -> P.Just (case _val132 of {T.TDouble _val133 -> _val133; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  latticePath_tokenList = P.maybe (P.error "Missing required field: tokenList") (\(_,_val132) -> (case _val132 of {T.TList _ _val134 -> (Vector.fromList $ P.map (\_v135 -> (case _v135 of {T.TStruct _val136 -> (to_Token (T.TStruct _val136)); _ -> P.error "wrong type"})) _val134); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LatticePath _ = P.error "not a struct"
read_LatticePath :: (T.Transport t, T.Protocol p) => p t -> P.IO LatticePath
read_LatticePath iprot = to_LatticePath <$> T.readVal iprot (T.T_STRUCT typemap_LatticePath)
decode_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> LatticePath
decode_LatticePath iprot bs = to_LatticePath $ T.deserializeVal iprot (T.T_STRUCT typemap_LatticePath) bs
typemap_LatticePath :: T.TypeMap
typemap_LatticePath = Map.fromList [(1,("weight",T.T_DOUBLE)),(2,("tokenList",(T.T_LIST (T.T_STRUCT typemap_Token))))]
default_LatticePath :: LatticePath
default_LatticePath = LatticePath{
  latticePath_weight = P.Nothing,
  latticePath_tokenList = Vector.empty}
data Arc = Arc  { arc_src :: P.Maybe I.Int32
  , arc_dst :: P.Maybe I.Int32
  , arc_token :: P.Maybe Token
  , arc_weight :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Arc where
  hashWithSalt salt record = salt   `H.hashWithSalt` arc_src record   `H.hashWithSalt` arc_dst record   `H.hashWithSalt` arc_token record   `H.hashWithSalt` arc_weight record  
instance QC.Arbitrary Arc where 
  arbitrary = M.liftM Arc (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Arc = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Arc{arc_src = arc_src obj} then P.Nothing else P.Just $ default_Arc{arc_src = arc_src obj}
    , if obj == default_Arc{arc_dst = arc_dst obj} then P.Nothing else P.Just $ default_Arc{arc_dst = arc_dst obj}
    , if obj == default_Arc{arc_token = arc_token obj} then P.Nothing else P.Just $ default_Arc{arc_token = arc_token obj}
    , if obj == default_Arc{arc_weight = arc_weight obj} then P.Nothing else P.Just $ default_Arc{arc_weight = arc_weight obj}
    ]
from_Arc :: Arc -> T.ThriftVal
from_Arc record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v139 -> (1, ("src",T.TI32 _v139))) <$> arc_src record
  , (\_v139 -> (2, ("dst",T.TI32 _v139))) <$> arc_dst record
  , (\_v139 -> (3, ("token",from_Token _v139))) <$> arc_token record
  , (\_v139 -> (4, ("weight",T.TDouble _v139))) <$> arc_weight record
  ]
write_Arc :: (T.Protocol p, T.Transport t) => p t -> Arc -> P.IO ()
write_Arc oprot record = T.writeVal oprot $ from_Arc record
encode_Arc :: (T.Protocol p, T.Transport t) => p t -> Arc -> LBS.ByteString
encode_Arc oprot record = T.serializeVal oprot $ from_Arc record
to_Arc :: T.ThriftVal -> Arc
to_Arc (T.TStruct fields) = Arc{
  arc_src = P.maybe (P.Nothing) (\(_,_val141) -> P.Just (case _val141 of {T.TI32 _val142 -> _val142; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  arc_dst = P.maybe (P.Nothing) (\(_,_val141) -> P.Just (case _val141 of {T.TI32 _val143 -> _val143; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  arc_token = P.maybe (P.Nothing) (\(_,_val141) -> P.Just (case _val141 of {T.TStruct _val144 -> (to_Token (T.TStruct _val144)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  arc_weight = P.maybe (P.Nothing) (\(_,_val141) -> P.Just (case _val141 of {T.TDouble _val145 -> _val145; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Arc _ = P.error "not a struct"
read_Arc :: (T.Transport t, T.Protocol p) => p t -> P.IO Arc
read_Arc iprot = to_Arc <$> T.readVal iprot (T.T_STRUCT typemap_Arc)
decode_Arc :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Arc
decode_Arc iprot bs = to_Arc $ T.deserializeVal iprot (T.T_STRUCT typemap_Arc) bs
typemap_Arc :: T.TypeMap
typemap_Arc = Map.fromList [(1,("src",T.T_I32)),(2,("dst",T.T_I32)),(3,("token",(T.T_STRUCT typemap_Token))),(4,("weight",T.T_DOUBLE))]
default_Arc :: Arc
default_Arc = Arc{
  arc_src = P.Nothing,
  arc_dst = P.Nothing,
  arc_token = P.Nothing,
  arc_weight = P.Nothing}
data TokenLattice = TokenLattice  { tokenLattice_startState :: P.Maybe I.Int32
  , tokenLattice_endState :: P.Maybe I.Int32
  , tokenLattice_arcList :: (Vector.Vector Arc)
  , tokenLattice_cachedBestPath :: P.Maybe LatticePath
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenLattice where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenLattice_startState record   `H.hashWithSalt` tokenLattice_endState record   `H.hashWithSalt` tokenLattice_arcList record   `H.hashWithSalt` tokenLattice_cachedBestPath record  
instance QC.Arbitrary TokenLattice where 
  arbitrary = M.liftM TokenLattice (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenLattice = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenLattice{tokenLattice_startState = tokenLattice_startState obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_startState = tokenLattice_startState obj}
    , if obj == default_TokenLattice{tokenLattice_endState = tokenLattice_endState obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_endState = tokenLattice_endState obj}
    , if obj == default_TokenLattice{tokenLattice_arcList = tokenLattice_arcList obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_arcList = tokenLattice_arcList obj}
    , if obj == default_TokenLattice{tokenLattice_cachedBestPath = tokenLattice_cachedBestPath obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_cachedBestPath = tokenLattice_cachedBestPath obj}
    ]
from_TokenLattice :: TokenLattice -> T.ThriftVal
from_TokenLattice record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v148 -> (1, ("startState",T.TI32 _v148))) <$> tokenLattice_startState record
  , (\_v148 -> (2, ("endState",T.TI32 _v148))) <$> tokenLattice_endState record
  , (\_v148 -> P.Just (3, ("arcList",T.TList (T.T_STRUCT typemap_Arc) $ P.map (\_v150 -> from_Arc _v150) $ Vector.toList _v148))) $ tokenLattice_arcList record
  , (\_v148 -> (4, ("cachedBestPath",from_LatticePath _v148))) <$> tokenLattice_cachedBestPath record
  ]
write_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> TokenLattice -> P.IO ()
write_TokenLattice oprot record = T.writeVal oprot $ from_TokenLattice record
encode_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> TokenLattice -> LBS.ByteString
encode_TokenLattice oprot record = T.serializeVal oprot $ from_TokenLattice record
to_TokenLattice :: T.ThriftVal -> TokenLattice
to_TokenLattice (T.TStruct fields) = TokenLattice{
  tokenLattice_startState = P.maybe (tokenLattice_startState default_TokenLattice) (\(_,_val152) -> P.Just (case _val152 of {T.TI32 _val153 -> _val153; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenLattice_endState = P.maybe (tokenLattice_endState default_TokenLattice) (\(_,_val152) -> P.Just (case _val152 of {T.TI32 _val154 -> _val154; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenLattice_arcList = P.maybe (P.error "Missing required field: arcList") (\(_,_val152) -> (case _val152 of {T.TList _ _val155 -> (Vector.fromList $ P.map (\_v156 -> (case _v156 of {T.TStruct _val157 -> (to_Arc (T.TStruct _val157)); _ -> P.error "wrong type"})) _val155); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenLattice_cachedBestPath = P.maybe (P.Nothing) (\(_,_val152) -> P.Just (case _val152 of {T.TStruct _val158 -> (to_LatticePath (T.TStruct _val158)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TokenLattice _ = P.error "not a struct"
read_TokenLattice :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenLattice
read_TokenLattice iprot = to_TokenLattice <$> T.readVal iprot (T.T_STRUCT typemap_TokenLattice)
decode_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenLattice
decode_TokenLattice iprot bs = to_TokenLattice $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenLattice) bs
typemap_TokenLattice :: T.TypeMap
typemap_TokenLattice = Map.fromList [(1,("startState",T.T_I32)),(2,("endState",T.T_I32)),(3,("arcList",(T.T_LIST (T.T_STRUCT typemap_Arc)))),(4,("cachedBestPath",(T.T_STRUCT typemap_LatticePath)))]
default_TokenLattice :: TokenLattice
default_TokenLattice = TokenLattice{
  tokenLattice_startState = P.Just (0),
  tokenLattice_endState = P.Just (0),
  tokenLattice_arcList = Vector.empty,
  tokenLattice_cachedBestPath = P.Nothing}
data TokenList = TokenList  { tokenList_tokenList :: (Vector.Vector Token)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenList where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenList_tokenList record  
instance QC.Arbitrary TokenList where 
  arbitrary = M.liftM TokenList (QC.arbitrary)
  shrink obj | obj == default_TokenList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenList{tokenList_tokenList = tokenList_tokenList obj} then P.Nothing else P.Just $ default_TokenList{tokenList_tokenList = tokenList_tokenList obj}
    ]
from_TokenList :: TokenList -> T.ThriftVal
from_TokenList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v161 -> P.Just (1, ("tokenList",T.TList (T.T_STRUCT typemap_Token) $ P.map (\_v163 -> from_Token _v163) $ Vector.toList _v161))) $ tokenList_tokenList record
  ]
write_TokenList :: (T.Protocol p, T.Transport t) => p t -> TokenList -> P.IO ()
write_TokenList oprot record = T.writeVal oprot $ from_TokenList record
encode_TokenList :: (T.Protocol p, T.Transport t) => p t -> TokenList -> LBS.ByteString
encode_TokenList oprot record = T.serializeVal oprot $ from_TokenList record
to_TokenList :: T.ThriftVal -> TokenList
to_TokenList (T.TStruct fields) = TokenList{
  tokenList_tokenList = P.maybe (P.error "Missing required field: tokenList") (\(_,_val165) -> (case _val165 of {T.TList _ _val166 -> (Vector.fromList $ P.map (\_v167 -> (case _v167 of {T.TStruct _val168 -> (to_Token (T.TStruct _val168)); _ -> P.error "wrong type"})) _val166); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TokenList _ = P.error "not a struct"
read_TokenList :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenList
read_TokenList iprot = to_TokenList <$> T.readVal iprot (T.T_STRUCT typemap_TokenList)
decode_TokenList :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenList
decode_TokenList iprot bs = to_TokenList $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenList) bs
typemap_TokenList :: T.TypeMap
typemap_TokenList = Map.fromList [(1,("tokenList",(T.T_LIST (T.T_STRUCT typemap_Token))))]
default_TokenList :: TokenList
default_TokenList = TokenList{
  tokenList_tokenList = Vector.empty}
data SpanLink = SpanLink  { spanLink_tokens :: TokenRefSequence
  , spanLink_concreteTarget :: P.Maybe Uuid_Types.UUID
  , spanLink_externalTarget :: P.Maybe LT.Text
  , spanLink_linkType :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpanLink where
  hashWithSalt salt record = salt   `H.hashWithSalt` spanLink_tokens record   `H.hashWithSalt` spanLink_concreteTarget record   `H.hashWithSalt` spanLink_externalTarget record   `H.hashWithSalt` spanLink_linkType record  
instance QC.Arbitrary SpanLink where 
  arbitrary = M.liftM SpanLink (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SpanLink = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpanLink{spanLink_tokens = spanLink_tokens obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_tokens = spanLink_tokens obj}
    , if obj == default_SpanLink{spanLink_concreteTarget = spanLink_concreteTarget obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_concreteTarget = spanLink_concreteTarget obj}
    , if obj == default_SpanLink{spanLink_externalTarget = spanLink_externalTarget obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_externalTarget = spanLink_externalTarget obj}
    , if obj == default_SpanLink{spanLink_linkType = spanLink_linkType obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_linkType = spanLink_linkType obj}
    ]
from_SpanLink :: SpanLink -> T.ThriftVal
from_SpanLink record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v171 -> P.Just (1, ("tokens",from_TokenRefSequence _v171))) $ spanLink_tokens record
  , (\_v171 -> (2, ("concreteTarget",Uuid_Types.from_UUID _v171))) <$> spanLink_concreteTarget record
  , (\_v171 -> (3, ("externalTarget",T.TString $ E.encodeUtf8 _v171))) <$> spanLink_externalTarget record
  , (\_v171 -> P.Just (4, ("linkType",T.TString $ E.encodeUtf8 _v171))) $ spanLink_linkType record
  ]
write_SpanLink :: (T.Protocol p, T.Transport t) => p t -> SpanLink -> P.IO ()
write_SpanLink oprot record = T.writeVal oprot $ from_SpanLink record
encode_SpanLink :: (T.Protocol p, T.Transport t) => p t -> SpanLink -> LBS.ByteString
encode_SpanLink oprot record = T.serializeVal oprot $ from_SpanLink record
to_SpanLink :: T.ThriftVal -> SpanLink
to_SpanLink (T.TStruct fields) = SpanLink{
  spanLink_tokens = P.maybe (P.error "Missing required field: tokens") (\(_,_val173) -> (case _val173 of {T.TStruct _val174 -> (to_TokenRefSequence (T.TStruct _val174)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  spanLink_concreteTarget = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TStruct _val175 -> (Uuid_Types.to_UUID (T.TStruct _val175)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  spanLink_externalTarget = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TString _val176 -> E.decodeUtf8 _val176; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  spanLink_linkType = P.maybe (P.error "Missing required field: linkType") (\(_,_val173) -> (case _val173 of {T.TString _val177 -> E.decodeUtf8 _val177; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SpanLink _ = P.error "not a struct"
read_SpanLink :: (T.Transport t, T.Protocol p) => p t -> P.IO SpanLink
read_SpanLink iprot = to_SpanLink <$> T.readVal iprot (T.T_STRUCT typemap_SpanLink)
decode_SpanLink :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SpanLink
decode_SpanLink iprot bs = to_SpanLink $ T.deserializeVal iprot (T.T_STRUCT typemap_SpanLink) bs
typemap_SpanLink :: T.TypeMap
typemap_SpanLink = Map.fromList [(1,("tokens",(T.T_STRUCT typemap_TokenRefSequence))),(2,("concreteTarget",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("externalTarget",T.T_STRING)),(4,("linkType",T.T_STRING))]
default_SpanLink :: SpanLink
default_SpanLink = SpanLink{
  spanLink_tokens = default_TokenRefSequence,
  spanLink_concreteTarget = P.Nothing,
  spanLink_externalTarget = P.Nothing,
  spanLink_linkType = ""}
data Tokenization = Tokenization  { tokenization_uuid :: Uuid_Types.UUID
  , tokenization_metadata :: Metadata_Types.AnnotationMetadata
  , tokenization_tokenList :: P.Maybe TokenList
  , tokenization_lattice :: P.Maybe TokenLattice
  , tokenization_kind :: TokenizationKind
  , tokenization_tokenTaggingList :: P.Maybe (Vector.Vector TokenTagging)
  , tokenization_parseList :: P.Maybe (Vector.Vector Parse)
  , tokenization_dependencyParseList :: P.Maybe (Vector.Vector DependencyParse)
  , tokenization_spanLinkList :: P.Maybe (Vector.Vector SpanLink)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Tokenization where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenization_uuid record   `H.hashWithSalt` tokenization_metadata record   `H.hashWithSalt` tokenization_tokenList record   `H.hashWithSalt` tokenization_lattice record   `H.hashWithSalt` tokenization_kind record   `H.hashWithSalt` tokenization_tokenTaggingList record   `H.hashWithSalt` tokenization_parseList record   `H.hashWithSalt` tokenization_dependencyParseList record   `H.hashWithSalt` tokenization_spanLinkList record  
instance QC.Arbitrary Tokenization where 
  arbitrary = M.liftM Tokenization (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Tokenization = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Tokenization{tokenization_uuid = tokenization_uuid obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_uuid = tokenization_uuid obj}
    , if obj == default_Tokenization{tokenization_metadata = tokenization_metadata obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_metadata = tokenization_metadata obj}
    , if obj == default_Tokenization{tokenization_tokenList = tokenization_tokenList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_tokenList = tokenization_tokenList obj}
    , if obj == default_Tokenization{tokenization_lattice = tokenization_lattice obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_lattice = tokenization_lattice obj}
    , if obj == default_Tokenization{tokenization_kind = tokenization_kind obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_kind = tokenization_kind obj}
    , if obj == default_Tokenization{tokenization_tokenTaggingList = tokenization_tokenTaggingList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_tokenTaggingList = tokenization_tokenTaggingList obj}
    , if obj == default_Tokenization{tokenization_parseList = tokenization_parseList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_parseList = tokenization_parseList obj}
    , if obj == default_Tokenization{tokenization_dependencyParseList = tokenization_dependencyParseList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_dependencyParseList = tokenization_dependencyParseList obj}
    , if obj == default_Tokenization{tokenization_spanLinkList = tokenization_spanLinkList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_spanLinkList = tokenization_spanLinkList obj}
    ]
from_Tokenization :: Tokenization -> T.ThriftVal
from_Tokenization record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v180 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v180))) $ tokenization_uuid record
  , (\_v180 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v180))) $ tokenization_metadata record
  , (\_v180 -> (3, ("tokenList",from_TokenList _v180))) <$> tokenization_tokenList record
  , (\_v180 -> (4, ("lattice",from_TokenLattice _v180))) <$> tokenization_lattice record
  , (\_v180 -> P.Just (5, ("kind",T.TI32 $ P.fromIntegral $ P.fromEnum _v180))) $ tokenization_kind record
  , (\_v180 -> (6, ("tokenTaggingList",T.TList (T.T_STRUCT typemap_TokenTagging) $ P.map (\_v182 -> from_TokenTagging _v182) $ Vector.toList _v180))) <$> tokenization_tokenTaggingList record
  , (\_v180 -> (7, ("parseList",T.TList (T.T_STRUCT typemap_Parse) $ P.map (\_v184 -> from_Parse _v184) $ Vector.toList _v180))) <$> tokenization_parseList record
  , (\_v180 -> (8, ("dependencyParseList",T.TList (T.T_STRUCT typemap_DependencyParse) $ P.map (\_v186 -> from_DependencyParse _v186) $ Vector.toList _v180))) <$> tokenization_dependencyParseList record
  , (\_v180 -> (9, ("spanLinkList",T.TList (T.T_STRUCT typemap_SpanLink) $ P.map (\_v188 -> from_SpanLink _v188) $ Vector.toList _v180))) <$> tokenization_spanLinkList record
  ]
write_Tokenization :: (T.Protocol p, T.Transport t) => p t -> Tokenization -> P.IO ()
write_Tokenization oprot record = T.writeVal oprot $ from_Tokenization record
encode_Tokenization :: (T.Protocol p, T.Transport t) => p t -> Tokenization -> LBS.ByteString
encode_Tokenization oprot record = T.serializeVal oprot $ from_Tokenization record
to_Tokenization :: T.ThriftVal -> Tokenization
to_Tokenization (T.TStruct fields) = Tokenization{
  tokenization_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val190) -> (case _val190 of {T.TStruct _val191 -> (Uuid_Types.to_UUID (T.TStruct _val191)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenization_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val190) -> (case _val190 of {T.TStruct _val192 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val192)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenization_tokenList = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TStruct _val193 -> (to_TokenList (T.TStruct _val193)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenization_lattice = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TStruct _val194 -> (to_TokenLattice (T.TStruct _val194)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tokenization_kind = P.maybe (P.error "Missing required field: kind") (\(_,_val190) -> (case _val190 of {T.TI32 _val195 -> P.toEnum $ P.fromIntegral _val195; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tokenization_tokenTaggingList = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TList _ _val196 -> (Vector.fromList $ P.map (\_v197 -> (case _v197 of {T.TStruct _val198 -> (to_TokenTagging (T.TStruct _val198)); _ -> P.error "wrong type"})) _val196); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tokenization_parseList = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TList _ _val199 -> (Vector.fromList $ P.map (\_v200 -> (case _v200 of {T.TStruct _val201 -> (to_Parse (T.TStruct _val201)); _ -> P.error "wrong type"})) _val199); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tokenization_dependencyParseList = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TList _ _val202 -> (Vector.fromList $ P.map (\_v203 -> (case _v203 of {T.TStruct _val204 -> (to_DependencyParse (T.TStruct _val204)); _ -> P.error "wrong type"})) _val202); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  tokenization_spanLinkList = P.maybe (P.Nothing) (\(_,_val190) -> P.Just (case _val190 of {T.TList _ _val205 -> (Vector.fromList $ P.map (\_v206 -> (case _v206 of {T.TStruct _val207 -> (to_SpanLink (T.TStruct _val207)); _ -> P.error "wrong type"})) _val205); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_Tokenization _ = P.error "not a struct"
read_Tokenization :: (T.Transport t, T.Protocol p) => p t -> P.IO Tokenization
read_Tokenization iprot = to_Tokenization <$> T.readVal iprot (T.T_STRUCT typemap_Tokenization)
decode_Tokenization :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Tokenization
decode_Tokenization iprot bs = to_Tokenization $ T.deserializeVal iprot (T.T_STRUCT typemap_Tokenization) bs
typemap_Tokenization :: T.TypeMap
typemap_Tokenization = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("tokenList",(T.T_STRUCT typemap_TokenList))),(4,("lattice",(T.T_STRUCT typemap_TokenLattice))),(5,("kind",T.T_I32)),(6,("tokenTaggingList",(T.T_LIST (T.T_STRUCT typemap_TokenTagging)))),(7,("parseList",(T.T_LIST (T.T_STRUCT typemap_Parse)))),(8,("dependencyParseList",(T.T_LIST (T.T_STRUCT typemap_DependencyParse)))),(9,("spanLinkList",(T.T_LIST (T.T_STRUCT typemap_SpanLink))))]
default_Tokenization :: Tokenization
default_Tokenization = Tokenization{
  tokenization_uuid = Uuid_Types.default_UUID,
  tokenization_metadata = Metadata_Types.default_AnnotationMetadata,
  tokenization_tokenList = P.Nothing,
  tokenization_lattice = P.Nothing,
  tokenization_kind = (P.toEnum 0),
  tokenization_tokenTaggingList = P.Nothing,
  tokenization_parseList = P.Nothing,
  tokenization_dependencyParseList = P.Nothing,
  tokenization_spanLinkList = P.Nothing}
data Sentence = Sentence  { sentence_uuid :: Uuid_Types.UUID
  , sentence_tokenization :: P.Maybe Tokenization
  , sentence_textSpan :: P.Maybe Spans_Types.TextSpan
  , sentence_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , sentence_audioSpan :: P.Maybe Spans_Types.AudioSpan
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Sentence where
  hashWithSalt salt record = salt   `H.hashWithSalt` sentence_uuid record   `H.hashWithSalt` sentence_tokenization record   `H.hashWithSalt` sentence_textSpan record   `H.hashWithSalt` sentence_rawTextSpan record   `H.hashWithSalt` sentence_audioSpan record  
instance QC.Arbitrary Sentence where 
  arbitrary = M.liftM Sentence (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Sentence = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Sentence{sentence_uuid = sentence_uuid obj} then P.Nothing else P.Just $ default_Sentence{sentence_uuid = sentence_uuid obj}
    , if obj == default_Sentence{sentence_tokenization = sentence_tokenization obj} then P.Nothing else P.Just $ default_Sentence{sentence_tokenization = sentence_tokenization obj}
    , if obj == default_Sentence{sentence_textSpan = sentence_textSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_textSpan = sentence_textSpan obj}
    , if obj == default_Sentence{sentence_rawTextSpan = sentence_rawTextSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_rawTextSpan = sentence_rawTextSpan obj}
    , if obj == default_Sentence{sentence_audioSpan = sentence_audioSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_audioSpan = sentence_audioSpan obj}
    ]
from_Sentence :: Sentence -> T.ThriftVal
from_Sentence record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v210 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v210))) $ sentence_uuid record
  , (\_v210 -> (2, ("tokenization",from_Tokenization _v210))) <$> sentence_tokenization record
  , (\_v210 -> (3, ("textSpan",Spans_Types.from_TextSpan _v210))) <$> sentence_textSpan record
  , (\_v210 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v210))) <$> sentence_rawTextSpan record
  , (\_v210 -> (5, ("audioSpan",Spans_Types.from_AudioSpan _v210))) <$> sentence_audioSpan record
  ]
write_Sentence :: (T.Protocol p, T.Transport t) => p t -> Sentence -> P.IO ()
write_Sentence oprot record = T.writeVal oprot $ from_Sentence record
encode_Sentence :: (T.Protocol p, T.Transport t) => p t -> Sentence -> LBS.ByteString
encode_Sentence oprot record = T.serializeVal oprot $ from_Sentence record
to_Sentence :: T.ThriftVal -> Sentence
to_Sentence (T.TStruct fields) = Sentence{
  sentence_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val212) -> (case _val212 of {T.TStruct _val213 -> (Uuid_Types.to_UUID (T.TStruct _val213)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sentence_tokenization = P.maybe (P.Nothing) (\(_,_val212) -> P.Just (case _val212 of {T.TStruct _val214 -> (to_Tokenization (T.TStruct _val214)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sentence_textSpan = P.maybe (P.Nothing) (\(_,_val212) -> P.Just (case _val212 of {T.TStruct _val215 -> (Spans_Types.to_TextSpan (T.TStruct _val215)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sentence_rawTextSpan = P.maybe (P.Nothing) (\(_,_val212) -> P.Just (case _val212 of {T.TStruct _val216 -> (Spans_Types.to_TextSpan (T.TStruct _val216)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sentence_audioSpan = P.maybe (P.Nothing) (\(_,_val212) -> P.Just (case _val212 of {T.TStruct _val217 -> (Spans_Types.to_AudioSpan (T.TStruct _val217)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Sentence _ = P.error "not a struct"
read_Sentence :: (T.Transport t, T.Protocol p) => p t -> P.IO Sentence
read_Sentence iprot = to_Sentence <$> T.readVal iprot (T.T_STRUCT typemap_Sentence)
decode_Sentence :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Sentence
decode_Sentence iprot bs = to_Sentence $ T.deserializeVal iprot (T.T_STRUCT typemap_Sentence) bs
typemap_Sentence :: T.TypeMap
typemap_Sentence = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("tokenization",(T.T_STRUCT typemap_Tokenization))),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Sentence :: Sentence
default_Sentence = Sentence{
  sentence_uuid = Uuid_Types.default_UUID,
  sentence_tokenization = P.Nothing,
  sentence_textSpan = P.Nothing,
  sentence_rawTextSpan = P.Nothing,
  sentence_audioSpan = P.Nothing}
data Section = Section  { section_uuid :: Uuid_Types.UUID
  , section_sentenceList :: P.Maybe (Vector.Vector Sentence)
  , section_textSpan :: P.Maybe Spans_Types.TextSpan
  , section_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , section_audioSpan :: P.Maybe Spans_Types.AudioSpan
  , section_kind :: LT.Text
  , section_label :: P.Maybe LT.Text
  , section_numberList :: P.Maybe (Vector.Vector I.Int32)
  , section_lidList :: P.Maybe (Vector.Vector Language_Types.LanguageIdentification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Section where
  hashWithSalt salt record = salt   `H.hashWithSalt` section_uuid record   `H.hashWithSalt` section_sentenceList record   `H.hashWithSalt` section_textSpan record   `H.hashWithSalt` section_rawTextSpan record   `H.hashWithSalt` section_audioSpan record   `H.hashWithSalt` section_kind record   `H.hashWithSalt` section_label record   `H.hashWithSalt` section_numberList record   `H.hashWithSalt` section_lidList record  
instance QC.Arbitrary Section where 
  arbitrary = M.liftM Section (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Section = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Section{section_uuid = section_uuid obj} then P.Nothing else P.Just $ default_Section{section_uuid = section_uuid obj}
    , if obj == default_Section{section_sentenceList = section_sentenceList obj} then P.Nothing else P.Just $ default_Section{section_sentenceList = section_sentenceList obj}
    , if obj == default_Section{section_textSpan = section_textSpan obj} then P.Nothing else P.Just $ default_Section{section_textSpan = section_textSpan obj}
    , if obj == default_Section{section_rawTextSpan = section_rawTextSpan obj} then P.Nothing else P.Just $ default_Section{section_rawTextSpan = section_rawTextSpan obj}
    , if obj == default_Section{section_audioSpan = section_audioSpan obj} then P.Nothing else P.Just $ default_Section{section_audioSpan = section_audioSpan obj}
    , if obj == default_Section{section_kind = section_kind obj} then P.Nothing else P.Just $ default_Section{section_kind = section_kind obj}
    , if obj == default_Section{section_label = section_label obj} then P.Nothing else P.Just $ default_Section{section_label = section_label obj}
    , if obj == default_Section{section_numberList = section_numberList obj} then P.Nothing else P.Just $ default_Section{section_numberList = section_numberList obj}
    , if obj == default_Section{section_lidList = section_lidList obj} then P.Nothing else P.Just $ default_Section{section_lidList = section_lidList obj}
    ]
from_Section :: Section -> T.ThriftVal
from_Section record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v220 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v220))) $ section_uuid record
  , (\_v220 -> (2, ("sentenceList",T.TList (T.T_STRUCT typemap_Sentence) $ P.map (\_v222 -> from_Sentence _v222) $ Vector.toList _v220))) <$> section_sentenceList record
  , (\_v220 -> (3, ("textSpan",Spans_Types.from_TextSpan _v220))) <$> section_textSpan record
  , (\_v220 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v220))) <$> section_rawTextSpan record
  , (\_v220 -> P.Just (5, ("kind",T.TString $ E.encodeUtf8 _v220))) $ section_kind record
  , (\_v220 -> (6, ("label",T.TString $ E.encodeUtf8 _v220))) <$> section_label record
  , (\_v220 -> (7, ("numberList",T.TList T.T_I32 $ P.map (\_v224 -> T.TI32 _v224) $ Vector.toList _v220))) <$> section_numberList record
  , (\_v220 -> (8, ("lidList",T.TList (T.T_STRUCT Language_Types.typemap_LanguageIdentification) $ P.map (\_v226 -> Language_Types.from_LanguageIdentification _v226) $ Vector.toList _v220))) <$> section_lidList record
  , (\_v220 -> (9, ("audioSpan",Spans_Types.from_AudioSpan _v220))) <$> section_audioSpan record
  ]
write_Section :: (T.Protocol p, T.Transport t) => p t -> Section -> P.IO ()
write_Section oprot record = T.writeVal oprot $ from_Section record
encode_Section :: (T.Protocol p, T.Transport t) => p t -> Section -> LBS.ByteString
encode_Section oprot record = T.serializeVal oprot $ from_Section record
to_Section :: T.ThriftVal -> Section
to_Section (T.TStruct fields) = Section{
  section_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val228) -> (case _val228 of {T.TStruct _val229 -> (Uuid_Types.to_UUID (T.TStruct _val229)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  section_sentenceList = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TList _ _val230 -> (Vector.fromList $ P.map (\_v231 -> (case _v231 of {T.TStruct _val232 -> (to_Sentence (T.TStruct _val232)); _ -> P.error "wrong type"})) _val230); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  section_textSpan = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TStruct _val233 -> (Spans_Types.to_TextSpan (T.TStruct _val233)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  section_rawTextSpan = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TStruct _val234 -> (Spans_Types.to_TextSpan (T.TStruct _val234)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  section_audioSpan = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TStruct _val235 -> (Spans_Types.to_AudioSpan (T.TStruct _val235)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  section_kind = P.maybe (P.error "Missing required field: kind") (\(_,_val228) -> (case _val228 of {T.TString _val236 -> E.decodeUtf8 _val236; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  section_label = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TString _val237 -> E.decodeUtf8 _val237; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  section_numberList = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TList _ _val238 -> (Vector.fromList $ P.map (\_v239 -> (case _v239 of {T.TI32 _val240 -> _val240; _ -> P.error "wrong type"})) _val238); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  section_lidList = P.maybe (P.Nothing) (\(_,_val228) -> P.Just (case _val228 of {T.TList _ _val241 -> (Vector.fromList $ P.map (\_v242 -> (case _v242 of {T.TStruct _val243 -> (Language_Types.to_LanguageIdentification (T.TStruct _val243)); _ -> P.error "wrong type"})) _val241); _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_Section _ = P.error "not a struct"
read_Section :: (T.Transport t, T.Protocol p) => p t -> P.IO Section
read_Section iprot = to_Section <$> T.readVal iprot (T.T_STRUCT typemap_Section)
decode_Section :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Section
decode_Section iprot bs = to_Section $ T.deserializeVal iprot (T.T_STRUCT typemap_Section) bs
typemap_Section :: T.TypeMap
typemap_Section = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("sentenceList",(T.T_LIST (T.T_STRUCT typemap_Sentence)))),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("kind",T.T_STRING)),(6,("label",T.T_STRING)),(7,("numberList",(T.T_LIST T.T_I32))),(8,("lidList",(T.T_LIST (T.T_STRUCT Language_Types.typemap_LanguageIdentification)))),(9,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Section :: Section
default_Section = Section{
  section_uuid = Uuid_Types.default_UUID,
  section_sentenceList = P.Nothing,
  section_textSpan = P.Nothing,
  section_rawTextSpan = P.Nothing,
  section_kind = "",
  section_label = P.Nothing,
  section_numberList = P.Nothing,
  section_lidList = P.Nothing,
  section_audioSpan = P.Nothing}
