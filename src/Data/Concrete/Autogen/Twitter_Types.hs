{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Twitter_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data TwitterUser = TwitterUser  { twitterUser_id :: P.Maybe I.Int64
  , twitterUser_name :: P.Maybe LT.Text
  , twitterUser_screenName :: P.Maybe LT.Text
  , twitterUser_lang :: P.Maybe LT.Text
  , twitterUser_geoEnabled :: P.Maybe P.Bool
  , twitterUser_createdAt :: P.Maybe LT.Text
  , twitterUser_friendsCount :: P.Maybe I.Int32
  , twitterUser_statusesCount :: P.Maybe I.Int32
  , twitterUser_verified :: P.Maybe P.Bool
  , twitterUser_listedCount :: P.Maybe I.Int32
  , twitterUser_favouritesCount :: P.Maybe I.Int32
  , twitterUser_followersCount :: P.Maybe I.Int32
  , twitterUser_location :: P.Maybe LT.Text
  , twitterUser_timeZone :: P.Maybe LT.Text
  , twitterUser_description :: P.Maybe LT.Text
  , twitterUser_utcOffset :: P.Maybe I.Int32
  , twitterUser_url :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TwitterUser where
  hashWithSalt salt record = salt   `H.hashWithSalt` twitterUser_id record   `H.hashWithSalt` twitterUser_name record   `H.hashWithSalt` twitterUser_screenName record   `H.hashWithSalt` twitterUser_lang record   `H.hashWithSalt` twitterUser_geoEnabled record   `H.hashWithSalt` twitterUser_createdAt record   `H.hashWithSalt` twitterUser_friendsCount record   `H.hashWithSalt` twitterUser_statusesCount record   `H.hashWithSalt` twitterUser_verified record   `H.hashWithSalt` twitterUser_listedCount record   `H.hashWithSalt` twitterUser_favouritesCount record   `H.hashWithSalt` twitterUser_followersCount record   `H.hashWithSalt` twitterUser_location record   `H.hashWithSalt` twitterUser_timeZone record   `H.hashWithSalt` twitterUser_description record   `H.hashWithSalt` twitterUser_utcOffset record   `H.hashWithSalt` twitterUser_url record  
instance QC.Arbitrary TwitterUser where 
  arbitrary = M.liftM TwitterUser (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TwitterUser = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TwitterUser{twitterUser_id = twitterUser_id obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_id = twitterUser_id obj}
    , if obj == default_TwitterUser{twitterUser_name = twitterUser_name obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_name = twitterUser_name obj}
    , if obj == default_TwitterUser{twitterUser_screenName = twitterUser_screenName obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_screenName = twitterUser_screenName obj}
    , if obj == default_TwitterUser{twitterUser_lang = twitterUser_lang obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_lang = twitterUser_lang obj}
    , if obj == default_TwitterUser{twitterUser_geoEnabled = twitterUser_geoEnabled obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_geoEnabled = twitterUser_geoEnabled obj}
    , if obj == default_TwitterUser{twitterUser_createdAt = twitterUser_createdAt obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_createdAt = twitterUser_createdAt obj}
    , if obj == default_TwitterUser{twitterUser_friendsCount = twitterUser_friendsCount obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_friendsCount = twitterUser_friendsCount obj}
    , if obj == default_TwitterUser{twitterUser_statusesCount = twitterUser_statusesCount obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_statusesCount = twitterUser_statusesCount obj}
    , if obj == default_TwitterUser{twitterUser_verified = twitterUser_verified obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_verified = twitterUser_verified obj}
    , if obj == default_TwitterUser{twitterUser_listedCount = twitterUser_listedCount obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_listedCount = twitterUser_listedCount obj}
    , if obj == default_TwitterUser{twitterUser_favouritesCount = twitterUser_favouritesCount obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_favouritesCount = twitterUser_favouritesCount obj}
    , if obj == default_TwitterUser{twitterUser_followersCount = twitterUser_followersCount obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_followersCount = twitterUser_followersCount obj}
    , if obj == default_TwitterUser{twitterUser_location = twitterUser_location obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_location = twitterUser_location obj}
    , if obj == default_TwitterUser{twitterUser_timeZone = twitterUser_timeZone obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_timeZone = twitterUser_timeZone obj}
    , if obj == default_TwitterUser{twitterUser_description = twitterUser_description obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_description = twitterUser_description obj}
    , if obj == default_TwitterUser{twitterUser_utcOffset = twitterUser_utcOffset obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_utcOffset = twitterUser_utcOffset obj}
    , if obj == default_TwitterUser{twitterUser_url = twitterUser_url obj} then P.Nothing else P.Just $ default_TwitterUser{twitterUser_url = twitterUser_url obj}
    ]
from_TwitterUser :: TwitterUser -> T.ThriftVal
from_TwitterUser record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("id",T.TI64 _v2))) <$> twitterUser_id record
  , (\_v2 -> (3, ("name",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_name record
  , (\_v2 -> (4, ("screenName",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_screenName record
  , (\_v2 -> (5, ("lang",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_lang record
  , (\_v2 -> (6, ("geoEnabled",T.TBool _v2))) <$> twitterUser_geoEnabled record
  , (\_v2 -> (7, ("createdAt",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_createdAt record
  , (\_v2 -> (8, ("friendsCount",T.TI32 _v2))) <$> twitterUser_friendsCount record
  , (\_v2 -> (9, ("statusesCount",T.TI32 _v2))) <$> twitterUser_statusesCount record
  , (\_v2 -> (10, ("verified",T.TBool _v2))) <$> twitterUser_verified record
  , (\_v2 -> (11, ("listedCount",T.TI32 _v2))) <$> twitterUser_listedCount record
  , (\_v2 -> (12, ("favouritesCount",T.TI32 _v2))) <$> twitterUser_favouritesCount record
  , (\_v2 -> (13, ("followersCount",T.TI32 _v2))) <$> twitterUser_followersCount record
  , (\_v2 -> (14, ("location",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_location record
  , (\_v2 -> (15, ("timeZone",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_timeZone record
  , (\_v2 -> (16, ("description",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_description record
  , (\_v2 -> (18, ("utcOffset",T.TI32 _v2))) <$> twitterUser_utcOffset record
  , (\_v2 -> (19, ("url",T.TString $ E.encodeUtf8 _v2))) <$> twitterUser_url record
  ]
write_TwitterUser :: (T.Protocol p, T.Transport t) => p t -> TwitterUser -> P.IO ()
write_TwitterUser oprot record = T.writeVal oprot $ from_TwitterUser record
encode_TwitterUser :: (T.Protocol p, T.Transport t) => p t -> TwitterUser -> LBS.ByteString
encode_TwitterUser oprot record = T.serializeVal oprot $ from_TwitterUser record
to_TwitterUser :: T.ThriftVal -> TwitterUser
to_TwitterUser (T.TStruct fields) = TwitterUser{
  twitterUser_id = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI64 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  twitterUser_name = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  twitterUser_screenName = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val7 -> E.decodeUtf8 _val7; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  twitterUser_lang = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val8 -> E.decodeUtf8 _val8; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  twitterUser_geoEnabled = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBool _val9 -> _val9; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  twitterUser_createdAt = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val10 -> E.decodeUtf8 _val10; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  twitterUser_friendsCount = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val11 -> _val11; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  twitterUser_statusesCount = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val12 -> _val12; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  twitterUser_verified = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBool _val13 -> _val13; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  twitterUser_listedCount = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val14 -> _val14; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  twitterUser_favouritesCount = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val15 -> _val15; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  twitterUser_followersCount = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val16 -> _val16; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  twitterUser_location = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val17 -> E.decodeUtf8 _val17; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  twitterUser_timeZone = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val18 -> E.decodeUtf8 _val18; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  twitterUser_description = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val19 -> E.decodeUtf8 _val19; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  twitterUser_utcOffset = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val20 -> _val20; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  twitterUser_url = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val21 -> E.decodeUtf8 _val21; _ -> P.error "wrong type"})) (Map.lookup (19) fields)
  }
to_TwitterUser _ = P.error "not a struct"
read_TwitterUser :: (T.Transport t, T.Protocol p) => p t -> P.IO TwitterUser
read_TwitterUser iprot = to_TwitterUser <$> T.readVal iprot (T.T_STRUCT typemap_TwitterUser)
decode_TwitterUser :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TwitterUser
decode_TwitterUser iprot bs = to_TwitterUser $ T.deserializeVal iprot (T.T_STRUCT typemap_TwitterUser) bs
typemap_TwitterUser :: T.TypeMap
typemap_TwitterUser = Map.fromList [(1,("id",T.T_I64)),(3,("name",T.T_STRING)),(4,("screenName",T.T_STRING)),(5,("lang",T.T_STRING)),(6,("geoEnabled",T.T_BOOL)),(7,("createdAt",T.T_STRING)),(8,("friendsCount",T.T_I32)),(9,("statusesCount",T.T_I32)),(10,("verified",T.T_BOOL)),(11,("listedCount",T.T_I32)),(12,("favouritesCount",T.T_I32)),(13,("followersCount",T.T_I32)),(14,("location",T.T_STRING)),(15,("timeZone",T.T_STRING)),(16,("description",T.T_STRING)),(18,("utcOffset",T.T_I32)),(19,("url",T.T_STRING))]
default_TwitterUser :: TwitterUser
default_TwitterUser = TwitterUser{
  twitterUser_id = P.Nothing,
  twitterUser_name = P.Nothing,
  twitterUser_screenName = P.Nothing,
  twitterUser_lang = P.Nothing,
  twitterUser_geoEnabled = P.Nothing,
  twitterUser_createdAt = P.Nothing,
  twitterUser_friendsCount = P.Nothing,
  twitterUser_statusesCount = P.Nothing,
  twitterUser_verified = P.Nothing,
  twitterUser_listedCount = P.Nothing,
  twitterUser_favouritesCount = P.Nothing,
  twitterUser_followersCount = P.Nothing,
  twitterUser_location = P.Nothing,
  twitterUser_timeZone = P.Nothing,
  twitterUser_description = P.Nothing,
  twitterUser_utcOffset = P.Nothing,
  twitterUser_url = P.Nothing}
data TwitterLatLong = TwitterLatLong  { twitterLatLong_latitude :: P.Maybe P.Double
  , twitterLatLong_longitude :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TwitterLatLong where
  hashWithSalt salt record = salt   `H.hashWithSalt` twitterLatLong_latitude record   `H.hashWithSalt` twitterLatLong_longitude record  
instance QC.Arbitrary TwitterLatLong where 
  arbitrary = M.liftM TwitterLatLong (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TwitterLatLong = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TwitterLatLong{twitterLatLong_latitude = twitterLatLong_latitude obj} then P.Nothing else P.Just $ default_TwitterLatLong{twitterLatLong_latitude = twitterLatLong_latitude obj}
    , if obj == default_TwitterLatLong{twitterLatLong_longitude = twitterLatLong_longitude obj} then P.Nothing else P.Just $ default_TwitterLatLong{twitterLatLong_longitude = twitterLatLong_longitude obj}
    ]
from_TwitterLatLong :: TwitterLatLong -> T.ThriftVal
from_TwitterLatLong record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v24 -> (1, ("latitude",T.TDouble _v24))) <$> twitterLatLong_latitude record
  , (\_v24 -> (2, ("longitude",T.TDouble _v24))) <$> twitterLatLong_longitude record
  ]
write_TwitterLatLong :: (T.Protocol p, T.Transport t) => p t -> TwitterLatLong -> P.IO ()
write_TwitterLatLong oprot record = T.writeVal oprot $ from_TwitterLatLong record
encode_TwitterLatLong :: (T.Protocol p, T.Transport t) => p t -> TwitterLatLong -> LBS.ByteString
encode_TwitterLatLong oprot record = T.serializeVal oprot $ from_TwitterLatLong record
to_TwitterLatLong :: T.ThriftVal -> TwitterLatLong
to_TwitterLatLong (T.TStruct fields) = TwitterLatLong{
  twitterLatLong_latitude = P.maybe (P.Nothing) (\(_,_val26) -> P.Just (case _val26 of {T.TDouble _val27 -> _val27; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  twitterLatLong_longitude = P.maybe (P.Nothing) (\(_,_val26) -> P.Just (case _val26 of {T.TDouble _val28 -> _val28; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TwitterLatLong _ = P.error "not a struct"
read_TwitterLatLong :: (T.Transport t, T.Protocol p) => p t -> P.IO TwitterLatLong
read_TwitterLatLong iprot = to_TwitterLatLong <$> T.readVal iprot (T.T_STRUCT typemap_TwitterLatLong)
decode_TwitterLatLong :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TwitterLatLong
decode_TwitterLatLong iprot bs = to_TwitterLatLong $ T.deserializeVal iprot (T.T_STRUCT typemap_TwitterLatLong) bs
typemap_TwitterLatLong :: T.TypeMap
typemap_TwitterLatLong = Map.fromList [(1,("latitude",T.T_DOUBLE)),(2,("longitude",T.T_DOUBLE))]
default_TwitterLatLong :: TwitterLatLong
default_TwitterLatLong = TwitterLatLong{
  twitterLatLong_latitude = P.Nothing,
  twitterLatLong_longitude = P.Nothing}
data BoundingBox = BoundingBox  { boundingBox_type :: P.Maybe LT.Text
  , boundingBox_coordinateList :: (Vector.Vector TwitterLatLong)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BoundingBox where
  hashWithSalt salt record = salt   `H.hashWithSalt` boundingBox_type record   `H.hashWithSalt` boundingBox_coordinateList record  
instance QC.Arbitrary BoundingBox where 
  arbitrary = M.liftM BoundingBox (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BoundingBox = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BoundingBox{boundingBox_type = boundingBox_type obj} then P.Nothing else P.Just $ default_BoundingBox{boundingBox_type = boundingBox_type obj}
    , if obj == default_BoundingBox{boundingBox_coordinateList = boundingBox_coordinateList obj} then P.Nothing else P.Just $ default_BoundingBox{boundingBox_coordinateList = boundingBox_coordinateList obj}
    ]
from_BoundingBox :: BoundingBox -> T.ThriftVal
from_BoundingBox record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v31 -> (1, ("type",T.TString $ E.encodeUtf8 _v31))) <$> boundingBox_type record
  , (\_v31 -> P.Just (2, ("coordinateList",T.TList (T.T_STRUCT typemap_TwitterLatLong) $ P.map (\_v33 -> from_TwitterLatLong _v33) $ Vector.toList _v31))) $ boundingBox_coordinateList record
  ]
write_BoundingBox :: (T.Protocol p, T.Transport t) => p t -> BoundingBox -> P.IO ()
write_BoundingBox oprot record = T.writeVal oprot $ from_BoundingBox record
encode_BoundingBox :: (T.Protocol p, T.Transport t) => p t -> BoundingBox -> LBS.ByteString
encode_BoundingBox oprot record = T.serializeVal oprot $ from_BoundingBox record
to_BoundingBox :: T.ThriftVal -> BoundingBox
to_BoundingBox (T.TStruct fields) = BoundingBox{
  boundingBox_type = P.maybe (P.Nothing) (\(_,_val35) -> P.Just (case _val35 of {T.TString _val36 -> E.decodeUtf8 _val36; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  boundingBox_coordinateList = P.maybe (P.error "Missing required field: coordinateList") (\(_,_val35) -> (case _val35 of {T.TList _ _val37 -> (Vector.fromList $ P.map (\_v38 -> (case _v38 of {T.TStruct _val39 -> (to_TwitterLatLong (T.TStruct _val39)); _ -> P.error "wrong type"})) _val37); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BoundingBox _ = P.error "not a struct"
read_BoundingBox :: (T.Transport t, T.Protocol p) => p t -> P.IO BoundingBox
read_BoundingBox iprot = to_BoundingBox <$> T.readVal iprot (T.T_STRUCT typemap_BoundingBox)
decode_BoundingBox :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BoundingBox
decode_BoundingBox iprot bs = to_BoundingBox $ T.deserializeVal iprot (T.T_STRUCT typemap_BoundingBox) bs
typemap_BoundingBox :: T.TypeMap
typemap_BoundingBox = Map.fromList [(1,("type",T.T_STRING)),(2,("coordinateList",(T.T_LIST (T.T_STRUCT typemap_TwitterLatLong))))]
default_BoundingBox :: BoundingBox
default_BoundingBox = BoundingBox{
  boundingBox_type = P.Nothing,
  boundingBox_coordinateList = Vector.empty}
data PlaceAttributes = PlaceAttributes  { placeAttributes_streetAddress :: P.Maybe LT.Text
  , placeAttributes_region :: P.Maybe LT.Text
  , placeAttributes_locality :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PlaceAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` placeAttributes_streetAddress record   `H.hashWithSalt` placeAttributes_region record   `H.hashWithSalt` placeAttributes_locality record  
instance QC.Arbitrary PlaceAttributes where 
  arbitrary = M.liftM PlaceAttributes (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_PlaceAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PlaceAttributes{placeAttributes_streetAddress = placeAttributes_streetAddress obj} then P.Nothing else P.Just $ default_PlaceAttributes{placeAttributes_streetAddress = placeAttributes_streetAddress obj}
    , if obj == default_PlaceAttributes{placeAttributes_region = placeAttributes_region obj} then P.Nothing else P.Just $ default_PlaceAttributes{placeAttributes_region = placeAttributes_region obj}
    , if obj == default_PlaceAttributes{placeAttributes_locality = placeAttributes_locality obj} then P.Nothing else P.Just $ default_PlaceAttributes{placeAttributes_locality = placeAttributes_locality obj}
    ]
from_PlaceAttributes :: PlaceAttributes -> T.ThriftVal
from_PlaceAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v42 -> (1, ("streetAddress",T.TString $ E.encodeUtf8 _v42))) <$> placeAttributes_streetAddress record
  , (\_v42 -> (2, ("region",T.TString $ E.encodeUtf8 _v42))) <$> placeAttributes_region record
  , (\_v42 -> (3, ("locality",T.TString $ E.encodeUtf8 _v42))) <$> placeAttributes_locality record
  ]
write_PlaceAttributes :: (T.Protocol p, T.Transport t) => p t -> PlaceAttributes -> P.IO ()
write_PlaceAttributes oprot record = T.writeVal oprot $ from_PlaceAttributes record
encode_PlaceAttributes :: (T.Protocol p, T.Transport t) => p t -> PlaceAttributes -> LBS.ByteString
encode_PlaceAttributes oprot record = T.serializeVal oprot $ from_PlaceAttributes record
to_PlaceAttributes :: T.ThriftVal -> PlaceAttributes
to_PlaceAttributes (T.TStruct fields) = PlaceAttributes{
  placeAttributes_streetAddress = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val45 -> E.decodeUtf8 _val45; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  placeAttributes_region = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val46 -> E.decodeUtf8 _val46; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  placeAttributes_locality = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val47 -> E.decodeUtf8 _val47; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PlaceAttributes _ = P.error "not a struct"
read_PlaceAttributes :: (T.Transport t, T.Protocol p) => p t -> P.IO PlaceAttributes
read_PlaceAttributes iprot = to_PlaceAttributes <$> T.readVal iprot (T.T_STRUCT typemap_PlaceAttributes)
decode_PlaceAttributes :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> PlaceAttributes
decode_PlaceAttributes iprot bs = to_PlaceAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_PlaceAttributes) bs
typemap_PlaceAttributes :: T.TypeMap
typemap_PlaceAttributes = Map.fromList [(1,("streetAddress",T.T_STRING)),(2,("region",T.T_STRING)),(3,("locality",T.T_STRING))]
default_PlaceAttributes :: PlaceAttributes
default_PlaceAttributes = PlaceAttributes{
  placeAttributes_streetAddress = P.Nothing,
  placeAttributes_region = P.Nothing,
  placeAttributes_locality = P.Nothing}
data UserMention = UserMention  { userMention_startOffset :: P.Maybe I.Int32
  , userMention_endOffset :: P.Maybe I.Int32
  , userMention_screenName :: P.Maybe LT.Text
  , userMention_name :: P.Maybe LT.Text
  , userMention_id :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserMention where
  hashWithSalt salt record = salt   `H.hashWithSalt` userMention_startOffset record   `H.hashWithSalt` userMention_endOffset record   `H.hashWithSalt` userMention_screenName record   `H.hashWithSalt` userMention_name record   `H.hashWithSalt` userMention_id record  
instance QC.Arbitrary UserMention where 
  arbitrary = M.liftM UserMention (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UserMention = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserMention{userMention_startOffset = userMention_startOffset obj} then P.Nothing else P.Just $ default_UserMention{userMention_startOffset = userMention_startOffset obj}
    , if obj == default_UserMention{userMention_endOffset = userMention_endOffset obj} then P.Nothing else P.Just $ default_UserMention{userMention_endOffset = userMention_endOffset obj}
    , if obj == default_UserMention{userMention_screenName = userMention_screenName obj} then P.Nothing else P.Just $ default_UserMention{userMention_screenName = userMention_screenName obj}
    , if obj == default_UserMention{userMention_name = userMention_name obj} then P.Nothing else P.Just $ default_UserMention{userMention_name = userMention_name obj}
    , if obj == default_UserMention{userMention_id = userMention_id obj} then P.Nothing else P.Just $ default_UserMention{userMention_id = userMention_id obj}
    ]
from_UserMention :: UserMention -> T.ThriftVal
from_UserMention record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v50 -> (1, ("startOffset",T.TI32 _v50))) <$> userMention_startOffset record
  , (\_v50 -> (2, ("endOffset",T.TI32 _v50))) <$> userMention_endOffset record
  , (\_v50 -> (4, ("screenName",T.TString $ E.encodeUtf8 _v50))) <$> userMention_screenName record
  , (\_v50 -> (5, ("name",T.TString $ E.encodeUtf8 _v50))) <$> userMention_name record
  , (\_v50 -> (6, ("id",T.TI64 _v50))) <$> userMention_id record
  ]
write_UserMention :: (T.Protocol p, T.Transport t) => p t -> UserMention -> P.IO ()
write_UserMention oprot record = T.writeVal oprot $ from_UserMention record
encode_UserMention :: (T.Protocol p, T.Transport t) => p t -> UserMention -> LBS.ByteString
encode_UserMention oprot record = T.serializeVal oprot $ from_UserMention record
to_UserMention :: T.ThriftVal -> UserMention
to_UserMention (T.TStruct fields) = UserMention{
  userMention_startOffset = P.maybe (P.Nothing) (\(_,_val52) -> P.Just (case _val52 of {T.TI32 _val53 -> _val53; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userMention_endOffset = P.maybe (P.Nothing) (\(_,_val52) -> P.Just (case _val52 of {T.TI32 _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  userMention_screenName = P.maybe (P.Nothing) (\(_,_val52) -> P.Just (case _val52 of {T.TString _val55 -> E.decodeUtf8 _val55; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  userMention_name = P.maybe (P.Nothing) (\(_,_val52) -> P.Just (case _val52 of {T.TString _val56 -> E.decodeUtf8 _val56; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  userMention_id = P.maybe (P.Nothing) (\(_,_val52) -> P.Just (case _val52 of {T.TI64 _val57 -> _val57; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_UserMention _ = P.error "not a struct"
read_UserMention :: (T.Transport t, T.Protocol p) => p t -> P.IO UserMention
read_UserMention iprot = to_UserMention <$> T.readVal iprot (T.T_STRUCT typemap_UserMention)
decode_UserMention :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> UserMention
decode_UserMention iprot bs = to_UserMention $ T.deserializeVal iprot (T.T_STRUCT typemap_UserMention) bs
typemap_UserMention :: T.TypeMap
typemap_UserMention = Map.fromList [(1,("startOffset",T.T_I32)),(2,("endOffset",T.T_I32)),(4,("screenName",T.T_STRING)),(5,("name",T.T_STRING)),(6,("id",T.T_I64))]
default_UserMention :: UserMention
default_UserMention = UserMention{
  userMention_startOffset = P.Nothing,
  userMention_endOffset = P.Nothing,
  userMention_screenName = P.Nothing,
  userMention_name = P.Nothing,
  userMention_id = P.Nothing}
data URL = URL  { uRL_startOffset :: P.Maybe I.Int32
  , uRL_endOffset :: P.Maybe I.Int32
  , uRL_expandedUrl :: P.Maybe LT.Text
  , uRL_url :: P.Maybe LT.Text
  , uRL_displayUrl :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable URL where
  hashWithSalt salt record = salt   `H.hashWithSalt` uRL_startOffset record   `H.hashWithSalt` uRL_endOffset record   `H.hashWithSalt` uRL_expandedUrl record   `H.hashWithSalt` uRL_url record   `H.hashWithSalt` uRL_displayUrl record  
instance QC.Arbitrary URL where 
  arbitrary = M.liftM URL (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_URL = []
             | P.otherwise = M.catMaybes
    [ if obj == default_URL{uRL_startOffset = uRL_startOffset obj} then P.Nothing else P.Just $ default_URL{uRL_startOffset = uRL_startOffset obj}
    , if obj == default_URL{uRL_endOffset = uRL_endOffset obj} then P.Nothing else P.Just $ default_URL{uRL_endOffset = uRL_endOffset obj}
    , if obj == default_URL{uRL_expandedUrl = uRL_expandedUrl obj} then P.Nothing else P.Just $ default_URL{uRL_expandedUrl = uRL_expandedUrl obj}
    , if obj == default_URL{uRL_url = uRL_url obj} then P.Nothing else P.Just $ default_URL{uRL_url = uRL_url obj}
    , if obj == default_URL{uRL_displayUrl = uRL_displayUrl obj} then P.Nothing else P.Just $ default_URL{uRL_displayUrl = uRL_displayUrl obj}
    ]
from_URL :: URL -> T.ThriftVal
from_URL record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v60 -> (1, ("startOffset",T.TI32 _v60))) <$> uRL_startOffset record
  , (\_v60 -> (2, ("endOffset",T.TI32 _v60))) <$> uRL_endOffset record
  , (\_v60 -> (3, ("expandedUrl",T.TString $ E.encodeUtf8 _v60))) <$> uRL_expandedUrl record
  , (\_v60 -> (4, ("url",T.TString $ E.encodeUtf8 _v60))) <$> uRL_url record
  , (\_v60 -> (5, ("displayUrl",T.TString $ E.encodeUtf8 _v60))) <$> uRL_displayUrl record
  ]
write_URL :: (T.Protocol p, T.Transport t) => p t -> URL -> P.IO ()
write_URL oprot record = T.writeVal oprot $ from_URL record
encode_URL :: (T.Protocol p, T.Transport t) => p t -> URL -> LBS.ByteString
encode_URL oprot record = T.serializeVal oprot $ from_URL record
to_URL :: T.ThriftVal -> URL
to_URL (T.TStruct fields) = URL{
  uRL_startOffset = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TI32 _val63 -> _val63; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  uRL_endOffset = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TI32 _val64 -> _val64; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  uRL_expandedUrl = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TString _val65 -> E.decodeUtf8 _val65; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  uRL_url = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TString _val66 -> E.decodeUtf8 _val66; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  uRL_displayUrl = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TString _val67 -> E.decodeUtf8 _val67; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_URL _ = P.error "not a struct"
read_URL :: (T.Transport t, T.Protocol p) => p t -> P.IO URL
read_URL iprot = to_URL <$> T.readVal iprot (T.T_STRUCT typemap_URL)
decode_URL :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> URL
decode_URL iprot bs = to_URL $ T.deserializeVal iprot (T.T_STRUCT typemap_URL) bs
typemap_URL :: T.TypeMap
typemap_URL = Map.fromList [(1,("startOffset",T.T_I32)),(2,("endOffset",T.T_I32)),(3,("expandedUrl",T.T_STRING)),(4,("url",T.T_STRING)),(5,("displayUrl",T.T_STRING))]
default_URL :: URL
default_URL = URL{
  uRL_startOffset = P.Nothing,
  uRL_endOffset = P.Nothing,
  uRL_expandedUrl = P.Nothing,
  uRL_url = P.Nothing,
  uRL_displayUrl = P.Nothing}
data HashTag = HashTag  { hashTag_text :: P.Maybe LT.Text
  , hashTag_startOffset :: P.Maybe I.Int32
  , hashTag_endOffset :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable HashTag where
  hashWithSalt salt record = salt   `H.hashWithSalt` hashTag_text record   `H.hashWithSalt` hashTag_startOffset record   `H.hashWithSalt` hashTag_endOffset record  
instance QC.Arbitrary HashTag where 
  arbitrary = M.liftM HashTag (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_HashTag = []
             | P.otherwise = M.catMaybes
    [ if obj == default_HashTag{hashTag_text = hashTag_text obj} then P.Nothing else P.Just $ default_HashTag{hashTag_text = hashTag_text obj}
    , if obj == default_HashTag{hashTag_startOffset = hashTag_startOffset obj} then P.Nothing else P.Just $ default_HashTag{hashTag_startOffset = hashTag_startOffset obj}
    , if obj == default_HashTag{hashTag_endOffset = hashTag_endOffset obj} then P.Nothing else P.Just $ default_HashTag{hashTag_endOffset = hashTag_endOffset obj}
    ]
from_HashTag :: HashTag -> T.ThriftVal
from_HashTag record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v70 -> (1, ("text",T.TString $ E.encodeUtf8 _v70))) <$> hashTag_text record
  , (\_v70 -> (2, ("startOffset",T.TI32 _v70))) <$> hashTag_startOffset record
  , (\_v70 -> (3, ("endOffset",T.TI32 _v70))) <$> hashTag_endOffset record
  ]
write_HashTag :: (T.Protocol p, T.Transport t) => p t -> HashTag -> P.IO ()
write_HashTag oprot record = T.writeVal oprot $ from_HashTag record
encode_HashTag :: (T.Protocol p, T.Transport t) => p t -> HashTag -> LBS.ByteString
encode_HashTag oprot record = T.serializeVal oprot $ from_HashTag record
to_HashTag :: T.ThriftVal -> HashTag
to_HashTag (T.TStruct fields) = HashTag{
  hashTag_text = P.maybe (P.Nothing) (\(_,_val72) -> P.Just (case _val72 of {T.TString _val73 -> E.decodeUtf8 _val73; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  hashTag_startOffset = P.maybe (P.Nothing) (\(_,_val72) -> P.Just (case _val72 of {T.TI32 _val74 -> _val74; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  hashTag_endOffset = P.maybe (P.Nothing) (\(_,_val72) -> P.Just (case _val72 of {T.TI32 _val75 -> _val75; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_HashTag _ = P.error "not a struct"
read_HashTag :: (T.Transport t, T.Protocol p) => p t -> P.IO HashTag
read_HashTag iprot = to_HashTag <$> T.readVal iprot (T.T_STRUCT typemap_HashTag)
decode_HashTag :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> HashTag
decode_HashTag iprot bs = to_HashTag $ T.deserializeVal iprot (T.T_STRUCT typemap_HashTag) bs
typemap_HashTag :: T.TypeMap
typemap_HashTag = Map.fromList [(1,("text",T.T_STRING)),(2,("startOffset",T.T_I32)),(3,("endOffset",T.T_I32))]
default_HashTag :: HashTag
default_HashTag = HashTag{
  hashTag_text = P.Nothing,
  hashTag_startOffset = P.Nothing,
  hashTag_endOffset = P.Nothing}
data TwitterEntities = TwitterEntities  { twitterEntities_hashtagList :: P.Maybe (Vector.Vector HashTag)
  , twitterEntities_urlList :: P.Maybe (Vector.Vector URL)
  , twitterEntities_userMentionList :: P.Maybe (Vector.Vector UserMention)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TwitterEntities where
  hashWithSalt salt record = salt   `H.hashWithSalt` twitterEntities_hashtagList record   `H.hashWithSalt` twitterEntities_urlList record   `H.hashWithSalt` twitterEntities_userMentionList record  
instance QC.Arbitrary TwitterEntities where 
  arbitrary = M.liftM TwitterEntities (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TwitterEntities = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TwitterEntities{twitterEntities_hashtagList = twitterEntities_hashtagList obj} then P.Nothing else P.Just $ default_TwitterEntities{twitterEntities_hashtagList = twitterEntities_hashtagList obj}
    , if obj == default_TwitterEntities{twitterEntities_urlList = twitterEntities_urlList obj} then P.Nothing else P.Just $ default_TwitterEntities{twitterEntities_urlList = twitterEntities_urlList obj}
    , if obj == default_TwitterEntities{twitterEntities_userMentionList = twitterEntities_userMentionList obj} then P.Nothing else P.Just $ default_TwitterEntities{twitterEntities_userMentionList = twitterEntities_userMentionList obj}
    ]
from_TwitterEntities :: TwitterEntities -> T.ThriftVal
from_TwitterEntities record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v78 -> (1, ("hashtagList",T.TList (T.T_STRUCT typemap_HashTag) $ P.map (\_v80 -> from_HashTag _v80) $ Vector.toList _v78))) <$> twitterEntities_hashtagList record
  , (\_v78 -> (2, ("urlList",T.TList (T.T_STRUCT typemap_URL) $ P.map (\_v82 -> from_URL _v82) $ Vector.toList _v78))) <$> twitterEntities_urlList record
  , (\_v78 -> (3, ("userMentionList",T.TList (T.T_STRUCT typemap_UserMention) $ P.map (\_v84 -> from_UserMention _v84) $ Vector.toList _v78))) <$> twitterEntities_userMentionList record
  ]
write_TwitterEntities :: (T.Protocol p, T.Transport t) => p t -> TwitterEntities -> P.IO ()
write_TwitterEntities oprot record = T.writeVal oprot $ from_TwitterEntities record
encode_TwitterEntities :: (T.Protocol p, T.Transport t) => p t -> TwitterEntities -> LBS.ByteString
encode_TwitterEntities oprot record = T.serializeVal oprot $ from_TwitterEntities record
to_TwitterEntities :: T.ThriftVal -> TwitterEntities
to_TwitterEntities (T.TStruct fields) = TwitterEntities{
  twitterEntities_hashtagList = P.maybe (P.Nothing) (\(_,_val86) -> P.Just (case _val86 of {T.TList _ _val87 -> (Vector.fromList $ P.map (\_v88 -> (case _v88 of {T.TStruct _val89 -> (to_HashTag (T.TStruct _val89)); _ -> P.error "wrong type"})) _val87); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  twitterEntities_urlList = P.maybe (P.Nothing) (\(_,_val86) -> P.Just (case _val86 of {T.TList _ _val90 -> (Vector.fromList $ P.map (\_v91 -> (case _v91 of {T.TStruct _val92 -> (to_URL (T.TStruct _val92)); _ -> P.error "wrong type"})) _val90); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  twitterEntities_userMentionList = P.maybe (P.Nothing) (\(_,_val86) -> P.Just (case _val86 of {T.TList _ _val93 -> (Vector.fromList $ P.map (\_v94 -> (case _v94 of {T.TStruct _val95 -> (to_UserMention (T.TStruct _val95)); _ -> P.error "wrong type"})) _val93); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TwitterEntities _ = P.error "not a struct"
read_TwitterEntities :: (T.Transport t, T.Protocol p) => p t -> P.IO TwitterEntities
read_TwitterEntities iprot = to_TwitterEntities <$> T.readVal iprot (T.T_STRUCT typemap_TwitterEntities)
decode_TwitterEntities :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TwitterEntities
decode_TwitterEntities iprot bs = to_TwitterEntities $ T.deserializeVal iprot (T.T_STRUCT typemap_TwitterEntities) bs
typemap_TwitterEntities :: T.TypeMap
typemap_TwitterEntities = Map.fromList [(1,("hashtagList",(T.T_LIST (T.T_STRUCT typemap_HashTag)))),(2,("urlList",(T.T_LIST (T.T_STRUCT typemap_URL)))),(3,("userMentionList",(T.T_LIST (T.T_STRUCT typemap_UserMention))))]
default_TwitterEntities :: TwitterEntities
default_TwitterEntities = TwitterEntities{
  twitterEntities_hashtagList = P.Nothing,
  twitterEntities_urlList = P.Nothing,
  twitterEntities_userMentionList = P.Nothing}
data TwitterPlace = TwitterPlace  { twitterPlace_placeType :: P.Maybe LT.Text
  , twitterPlace_countryCode :: P.Maybe LT.Text
  , twitterPlace_country :: P.Maybe LT.Text
  , twitterPlace_fullName :: P.Maybe LT.Text
  , twitterPlace_name :: P.Maybe LT.Text
  , twitterPlace_id :: P.Maybe LT.Text
  , twitterPlace_url :: P.Maybe LT.Text
  , twitterPlace_boundingBox :: P.Maybe BoundingBox
  , twitterPlace_attributes :: P.Maybe PlaceAttributes
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TwitterPlace where
  hashWithSalt salt record = salt   `H.hashWithSalt` twitterPlace_placeType record   `H.hashWithSalt` twitterPlace_countryCode record   `H.hashWithSalt` twitterPlace_country record   `H.hashWithSalt` twitterPlace_fullName record   `H.hashWithSalt` twitterPlace_name record   `H.hashWithSalt` twitterPlace_id record   `H.hashWithSalt` twitterPlace_url record   `H.hashWithSalt` twitterPlace_boundingBox record   `H.hashWithSalt` twitterPlace_attributes record  
instance QC.Arbitrary TwitterPlace where 
  arbitrary = M.liftM TwitterPlace (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TwitterPlace = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TwitterPlace{twitterPlace_placeType = twitterPlace_placeType obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_placeType = twitterPlace_placeType obj}
    , if obj == default_TwitterPlace{twitterPlace_countryCode = twitterPlace_countryCode obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_countryCode = twitterPlace_countryCode obj}
    , if obj == default_TwitterPlace{twitterPlace_country = twitterPlace_country obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_country = twitterPlace_country obj}
    , if obj == default_TwitterPlace{twitterPlace_fullName = twitterPlace_fullName obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_fullName = twitterPlace_fullName obj}
    , if obj == default_TwitterPlace{twitterPlace_name = twitterPlace_name obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_name = twitterPlace_name obj}
    , if obj == default_TwitterPlace{twitterPlace_id = twitterPlace_id obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_id = twitterPlace_id obj}
    , if obj == default_TwitterPlace{twitterPlace_url = twitterPlace_url obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_url = twitterPlace_url obj}
    , if obj == default_TwitterPlace{twitterPlace_boundingBox = twitterPlace_boundingBox obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_boundingBox = twitterPlace_boundingBox obj}
    , if obj == default_TwitterPlace{twitterPlace_attributes = twitterPlace_attributes obj} then P.Nothing else P.Just $ default_TwitterPlace{twitterPlace_attributes = twitterPlace_attributes obj}
    ]
from_TwitterPlace :: TwitterPlace -> T.ThriftVal
from_TwitterPlace record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v98 -> (1, ("placeType",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_placeType record
  , (\_v98 -> (2, ("countryCode",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_countryCode record
  , (\_v98 -> (3, ("country",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_country record
  , (\_v98 -> (4, ("fullName",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_fullName record
  , (\_v98 -> (5, ("name",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_name record
  , (\_v98 -> (6, ("id",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_id record
  , (\_v98 -> (7, ("url",T.TString $ E.encodeUtf8 _v98))) <$> twitterPlace_url record
  , (\_v98 -> (8, ("boundingBox",from_BoundingBox _v98))) <$> twitterPlace_boundingBox record
  , (\_v98 -> (9, ("attributes",from_PlaceAttributes _v98))) <$> twitterPlace_attributes record
  ]
write_TwitterPlace :: (T.Protocol p, T.Transport t) => p t -> TwitterPlace -> P.IO ()
write_TwitterPlace oprot record = T.writeVal oprot $ from_TwitterPlace record
encode_TwitterPlace :: (T.Protocol p, T.Transport t) => p t -> TwitterPlace -> LBS.ByteString
encode_TwitterPlace oprot record = T.serializeVal oprot $ from_TwitterPlace record
to_TwitterPlace :: T.ThriftVal -> TwitterPlace
to_TwitterPlace (T.TStruct fields) = TwitterPlace{
  twitterPlace_placeType = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val101 -> E.decodeUtf8 _val101; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  twitterPlace_countryCode = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val102 -> E.decodeUtf8 _val102; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  twitterPlace_country = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  twitterPlace_fullName = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val104 -> E.decodeUtf8 _val104; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  twitterPlace_name = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val105 -> E.decodeUtf8 _val105; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  twitterPlace_id = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val106 -> E.decodeUtf8 _val106; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  twitterPlace_url = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val107 -> E.decodeUtf8 _val107; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  twitterPlace_boundingBox = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TStruct _val108 -> (to_BoundingBox (T.TStruct _val108)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  twitterPlace_attributes = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TStruct _val109 -> (to_PlaceAttributes (T.TStruct _val109)); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_TwitterPlace _ = P.error "not a struct"
read_TwitterPlace :: (T.Transport t, T.Protocol p) => p t -> P.IO TwitterPlace
read_TwitterPlace iprot = to_TwitterPlace <$> T.readVal iprot (T.T_STRUCT typemap_TwitterPlace)
decode_TwitterPlace :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TwitterPlace
decode_TwitterPlace iprot bs = to_TwitterPlace $ T.deserializeVal iprot (T.T_STRUCT typemap_TwitterPlace) bs
typemap_TwitterPlace :: T.TypeMap
typemap_TwitterPlace = Map.fromList [(1,("placeType",T.T_STRING)),(2,("countryCode",T.T_STRING)),(3,("country",T.T_STRING)),(4,("fullName",T.T_STRING)),(5,("name",T.T_STRING)),(6,("id",T.T_STRING)),(7,("url",T.T_STRING)),(8,("boundingBox",(T.T_STRUCT typemap_BoundingBox))),(9,("attributes",(T.T_STRUCT typemap_PlaceAttributes)))]
default_TwitterPlace :: TwitterPlace
default_TwitterPlace = TwitterPlace{
  twitterPlace_placeType = P.Nothing,
  twitterPlace_countryCode = P.Nothing,
  twitterPlace_country = P.Nothing,
  twitterPlace_fullName = P.Nothing,
  twitterPlace_name = P.Nothing,
  twitterPlace_id = P.Nothing,
  twitterPlace_url = P.Nothing,
  twitterPlace_boundingBox = P.Nothing,
  twitterPlace_attributes = P.Nothing}
data TwitterCoordinates = TwitterCoordinates  { twitterCoordinates_type :: P.Maybe LT.Text
  , twitterCoordinates_coordinates :: P.Maybe TwitterLatLong
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TwitterCoordinates where
  hashWithSalt salt record = salt   `H.hashWithSalt` twitterCoordinates_type record   `H.hashWithSalt` twitterCoordinates_coordinates record  
instance QC.Arbitrary TwitterCoordinates where 
  arbitrary = M.liftM TwitterCoordinates (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TwitterCoordinates = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TwitterCoordinates{twitterCoordinates_type = twitterCoordinates_type obj} then P.Nothing else P.Just $ default_TwitterCoordinates{twitterCoordinates_type = twitterCoordinates_type obj}
    , if obj == default_TwitterCoordinates{twitterCoordinates_coordinates = twitterCoordinates_coordinates obj} then P.Nothing else P.Just $ default_TwitterCoordinates{twitterCoordinates_coordinates = twitterCoordinates_coordinates obj}
    ]
from_TwitterCoordinates :: TwitterCoordinates -> T.ThriftVal
from_TwitterCoordinates record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v112 -> (1, ("type",T.TString $ E.encodeUtf8 _v112))) <$> twitterCoordinates_type record
  , (\_v112 -> (2, ("coordinates",from_TwitterLatLong _v112))) <$> twitterCoordinates_coordinates record
  ]
write_TwitterCoordinates :: (T.Protocol p, T.Transport t) => p t -> TwitterCoordinates -> P.IO ()
write_TwitterCoordinates oprot record = T.writeVal oprot $ from_TwitterCoordinates record
encode_TwitterCoordinates :: (T.Protocol p, T.Transport t) => p t -> TwitterCoordinates -> LBS.ByteString
encode_TwitterCoordinates oprot record = T.serializeVal oprot $ from_TwitterCoordinates record
to_TwitterCoordinates :: T.ThriftVal -> TwitterCoordinates
to_TwitterCoordinates (T.TStruct fields) = TwitterCoordinates{
  twitterCoordinates_type = P.maybe (P.Nothing) (\(_,_val114) -> P.Just (case _val114 of {T.TString _val115 -> E.decodeUtf8 _val115; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  twitterCoordinates_coordinates = P.maybe (P.Nothing) (\(_,_val114) -> P.Just (case _val114 of {T.TStruct _val116 -> (to_TwitterLatLong (T.TStruct _val116)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TwitterCoordinates _ = P.error "not a struct"
read_TwitterCoordinates :: (T.Transport t, T.Protocol p) => p t -> P.IO TwitterCoordinates
read_TwitterCoordinates iprot = to_TwitterCoordinates <$> T.readVal iprot (T.T_STRUCT typemap_TwitterCoordinates)
decode_TwitterCoordinates :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TwitterCoordinates
decode_TwitterCoordinates iprot bs = to_TwitterCoordinates $ T.deserializeVal iprot (T.T_STRUCT typemap_TwitterCoordinates) bs
typemap_TwitterCoordinates :: T.TypeMap
typemap_TwitterCoordinates = Map.fromList [(1,("type",T.T_STRING)),(2,("coordinates",(T.T_STRUCT typemap_TwitterLatLong)))]
default_TwitterCoordinates :: TwitterCoordinates
default_TwitterCoordinates = TwitterCoordinates{
  twitterCoordinates_type = P.Nothing,
  twitterCoordinates_coordinates = P.Nothing}
data TweetInfo = TweetInfo  { tweetInfo_id :: P.Maybe I.Int64
  , tweetInfo_text :: P.Maybe LT.Text
  , tweetInfo_createdAt :: P.Maybe LT.Text
  , tweetInfo_user :: P.Maybe TwitterUser
  , tweetInfo_truncated :: P.Maybe P.Bool
  , tweetInfo_entities :: P.Maybe TwitterEntities
  , tweetInfo_source :: P.Maybe LT.Text
  , tweetInfo_coordinates :: P.Maybe TwitterCoordinates
  , tweetInfo_place :: P.Maybe TwitterPlace
  , tweetInfo_favorited :: P.Maybe P.Bool
  , tweetInfo_retweeted :: P.Maybe P.Bool
  , tweetInfo_retweetCount :: P.Maybe I.Int32
  , tweetInfo_inReplyToScreenName :: P.Maybe LT.Text
  , tweetInfo_inReplyToStatusId :: P.Maybe I.Int64
  , tweetInfo_inReplyToUserId :: P.Maybe I.Int64
  , tweetInfo_retweetedScreenName :: P.Maybe LT.Text
  , tweetInfo_retweetedStatusId :: P.Maybe I.Int64
  , tweetInfo_retweetedUserId :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TweetInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` tweetInfo_id record   `H.hashWithSalt` tweetInfo_text record   `H.hashWithSalt` tweetInfo_createdAt record   `H.hashWithSalt` tweetInfo_user record   `H.hashWithSalt` tweetInfo_truncated record   `H.hashWithSalt` tweetInfo_entities record   `H.hashWithSalt` tweetInfo_source record   `H.hashWithSalt` tweetInfo_coordinates record   `H.hashWithSalt` tweetInfo_place record   `H.hashWithSalt` tweetInfo_favorited record   `H.hashWithSalt` tweetInfo_retweeted record   `H.hashWithSalt` tweetInfo_retweetCount record   `H.hashWithSalt` tweetInfo_inReplyToScreenName record   `H.hashWithSalt` tweetInfo_inReplyToStatusId record   `H.hashWithSalt` tweetInfo_inReplyToUserId record   `H.hashWithSalt` tweetInfo_retweetedScreenName record   `H.hashWithSalt` tweetInfo_retweetedStatusId record   `H.hashWithSalt` tweetInfo_retweetedUserId record  
instance QC.Arbitrary TweetInfo where 
  arbitrary = M.liftM TweetInfo (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TweetInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TweetInfo{tweetInfo_id = tweetInfo_id obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_id = tweetInfo_id obj}
    , if obj == default_TweetInfo{tweetInfo_text = tweetInfo_text obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_text = tweetInfo_text obj}
    , if obj == default_TweetInfo{tweetInfo_createdAt = tweetInfo_createdAt obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_createdAt = tweetInfo_createdAt obj}
    , if obj == default_TweetInfo{tweetInfo_user = tweetInfo_user obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_user = tweetInfo_user obj}
    , if obj == default_TweetInfo{tweetInfo_truncated = tweetInfo_truncated obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_truncated = tweetInfo_truncated obj}
    , if obj == default_TweetInfo{tweetInfo_entities = tweetInfo_entities obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_entities = tweetInfo_entities obj}
    , if obj == default_TweetInfo{tweetInfo_source = tweetInfo_source obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_source = tweetInfo_source obj}
    , if obj == default_TweetInfo{tweetInfo_coordinates = tweetInfo_coordinates obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_coordinates = tweetInfo_coordinates obj}
    , if obj == default_TweetInfo{tweetInfo_place = tweetInfo_place obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_place = tweetInfo_place obj}
    , if obj == default_TweetInfo{tweetInfo_favorited = tweetInfo_favorited obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_favorited = tweetInfo_favorited obj}
    , if obj == default_TweetInfo{tweetInfo_retweeted = tweetInfo_retweeted obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_retweeted = tweetInfo_retweeted obj}
    , if obj == default_TweetInfo{tweetInfo_retweetCount = tweetInfo_retweetCount obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_retweetCount = tweetInfo_retweetCount obj}
    , if obj == default_TweetInfo{tweetInfo_inReplyToScreenName = tweetInfo_inReplyToScreenName obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_inReplyToScreenName = tweetInfo_inReplyToScreenName obj}
    , if obj == default_TweetInfo{tweetInfo_inReplyToStatusId = tweetInfo_inReplyToStatusId obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_inReplyToStatusId = tweetInfo_inReplyToStatusId obj}
    , if obj == default_TweetInfo{tweetInfo_inReplyToUserId = tweetInfo_inReplyToUserId obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_inReplyToUserId = tweetInfo_inReplyToUserId obj}
    , if obj == default_TweetInfo{tweetInfo_retweetedScreenName = tweetInfo_retweetedScreenName obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_retweetedScreenName = tweetInfo_retweetedScreenName obj}
    , if obj == default_TweetInfo{tweetInfo_retweetedStatusId = tweetInfo_retweetedStatusId obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_retweetedStatusId = tweetInfo_retweetedStatusId obj}
    , if obj == default_TweetInfo{tweetInfo_retweetedUserId = tweetInfo_retweetedUserId obj} then P.Nothing else P.Just $ default_TweetInfo{tweetInfo_retweetedUserId = tweetInfo_retweetedUserId obj}
    ]
from_TweetInfo :: TweetInfo -> T.ThriftVal
from_TweetInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v119 -> (1, ("id",T.TI64 _v119))) <$> tweetInfo_id record
  , (\_v119 -> (3, ("text",T.TString $ E.encodeUtf8 _v119))) <$> tweetInfo_text record
  , (\_v119 -> (4, ("createdAt",T.TString $ E.encodeUtf8 _v119))) <$> tweetInfo_createdAt record
  , (\_v119 -> (5, ("user",from_TwitterUser _v119))) <$> tweetInfo_user record
  , (\_v119 -> (6, ("truncated",T.TBool _v119))) <$> tweetInfo_truncated record
  , (\_v119 -> (7, ("entities",from_TwitterEntities _v119))) <$> tweetInfo_entities record
  , (\_v119 -> (8, ("source",T.TString $ E.encodeUtf8 _v119))) <$> tweetInfo_source record
  , (\_v119 -> (9, ("coordinates",from_TwitterCoordinates _v119))) <$> tweetInfo_coordinates record
  , (\_v119 -> (11, ("place",from_TwitterPlace _v119))) <$> tweetInfo_place record
  , (\_v119 -> (12, ("favorited",T.TBool _v119))) <$> tweetInfo_favorited record
  , (\_v119 -> (13, ("retweeted",T.TBool _v119))) <$> tweetInfo_retweeted record
  , (\_v119 -> (14, ("retweetCount",T.TI32 _v119))) <$> tweetInfo_retweetCount record
  , (\_v119 -> (15, ("inReplyToScreenName",T.TString $ E.encodeUtf8 _v119))) <$> tweetInfo_inReplyToScreenName record
  , (\_v119 -> (16, ("inReplyToStatusId",T.TI64 _v119))) <$> tweetInfo_inReplyToStatusId record
  , (\_v119 -> (18, ("inReplyToUserId",T.TI64 _v119))) <$> tweetInfo_inReplyToUserId record
  , (\_v119 -> (19, ("retweetedScreenName",T.TString $ E.encodeUtf8 _v119))) <$> tweetInfo_retweetedScreenName record
  , (\_v119 -> (20, ("retweetedStatusId",T.TI64 _v119))) <$> tweetInfo_retweetedStatusId record
  , (\_v119 -> (21, ("retweetedUserId",T.TI64 _v119))) <$> tweetInfo_retweetedUserId record
  ]
write_TweetInfo :: (T.Protocol p, T.Transport t) => p t -> TweetInfo -> P.IO ()
write_TweetInfo oprot record = T.writeVal oprot $ from_TweetInfo record
encode_TweetInfo :: (T.Protocol p, T.Transport t) => p t -> TweetInfo -> LBS.ByteString
encode_TweetInfo oprot record = T.serializeVal oprot $ from_TweetInfo record
to_TweetInfo :: T.ThriftVal -> TweetInfo
to_TweetInfo (T.TStruct fields) = TweetInfo{
  tweetInfo_id = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI64 _val122 -> _val122; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tweetInfo_text = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TString _val123 -> E.decodeUtf8 _val123; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tweetInfo_createdAt = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TString _val124 -> E.decodeUtf8 _val124; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tweetInfo_user = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TStruct _val125 -> (to_TwitterUser (T.TStruct _val125)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tweetInfo_truncated = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TBool _val126 -> _val126; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tweetInfo_entities = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TStruct _val127 -> (to_TwitterEntities (T.TStruct _val127)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tweetInfo_source = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TString _val128 -> E.decodeUtf8 _val128; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  tweetInfo_coordinates = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TStruct _val129 -> (to_TwitterCoordinates (T.TStruct _val129)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  tweetInfo_place = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TStruct _val130 -> (to_TwitterPlace (T.TStruct _val130)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  tweetInfo_favorited = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TBool _val131 -> _val131; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  tweetInfo_retweeted = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TBool _val132 -> _val132; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  tweetInfo_retweetCount = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI32 _val133 -> _val133; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  tweetInfo_inReplyToScreenName = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TString _val134 -> E.decodeUtf8 _val134; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  tweetInfo_inReplyToStatusId = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI64 _val135 -> _val135; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  tweetInfo_inReplyToUserId = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI64 _val136 -> _val136; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  tweetInfo_retweetedScreenName = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TString _val137 -> E.decodeUtf8 _val137; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  tweetInfo_retweetedStatusId = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI64 _val138 -> _val138; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  tweetInfo_retweetedUserId = P.maybe (P.Nothing) (\(_,_val121) -> P.Just (case _val121 of {T.TI64 _val139 -> _val139; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_TweetInfo _ = P.error "not a struct"
read_TweetInfo :: (T.Transport t, T.Protocol p) => p t -> P.IO TweetInfo
read_TweetInfo iprot = to_TweetInfo <$> T.readVal iprot (T.T_STRUCT typemap_TweetInfo)
decode_TweetInfo :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TweetInfo
decode_TweetInfo iprot bs = to_TweetInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_TweetInfo) bs
typemap_TweetInfo :: T.TypeMap
typemap_TweetInfo = Map.fromList [(1,("id",T.T_I64)),(3,("text",T.T_STRING)),(4,("createdAt",T.T_STRING)),(5,("user",(T.T_STRUCT typemap_TwitterUser))),(6,("truncated",T.T_BOOL)),(7,("entities",(T.T_STRUCT typemap_TwitterEntities))),(8,("source",T.T_STRING)),(9,("coordinates",(T.T_STRUCT typemap_TwitterCoordinates))),(11,("place",(T.T_STRUCT typemap_TwitterPlace))),(12,("favorited",T.T_BOOL)),(13,("retweeted",T.T_BOOL)),(14,("retweetCount",T.T_I32)),(15,("inReplyToScreenName",T.T_STRING)),(16,("inReplyToStatusId",T.T_I64)),(18,("inReplyToUserId",T.T_I64)),(19,("retweetedScreenName",T.T_STRING)),(20,("retweetedStatusId",T.T_I64)),(21,("retweetedUserId",T.T_I64))]
default_TweetInfo :: TweetInfo
default_TweetInfo = TweetInfo{
  tweetInfo_id = P.Nothing,
  tweetInfo_text = P.Nothing,
  tweetInfo_createdAt = P.Nothing,
  tweetInfo_user = P.Nothing,
  tweetInfo_truncated = P.Nothing,
  tweetInfo_entities = P.Nothing,
  tweetInfo_source = P.Nothing,
  tweetInfo_coordinates = P.Nothing,
  tweetInfo_place = P.Nothing,
  tweetInfo_favorited = P.Nothing,
  tweetInfo_retweeted = P.Nothing,
  tweetInfo_retweetCount = P.Nothing,
  tweetInfo_inReplyToScreenName = P.Nothing,
  tweetInfo_inReplyToStatusId = P.Nothing,
  tweetInfo_inReplyToUserId = P.Nothing,
  tweetInfo_retweetedScreenName = P.Nothing,
  tweetInfo_retweetedStatusId = P.Nothing,
  tweetInfo_retweetedUserId = P.Nothing}
