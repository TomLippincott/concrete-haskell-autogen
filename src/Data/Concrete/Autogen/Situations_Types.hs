{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Situations_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Linking_Types as Linking_Types


data Property = Property  { property_value :: LT.Text
  , property_metadata :: Metadata_Types.AnnotationMetadata
  , property_polarity :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Property where
  hashWithSalt salt record = salt   `H.hashWithSalt` property_value record   `H.hashWithSalt` property_metadata record   `H.hashWithSalt` property_polarity record  
instance QC.Arbitrary Property where 
  arbitrary = M.liftM Property (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Property = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Property{property_value = property_value obj} then P.Nothing else P.Just $ default_Property{property_value = property_value obj}
    , if obj == default_Property{property_metadata = property_metadata obj} then P.Nothing else P.Just $ default_Property{property_metadata = property_metadata obj}
    , if obj == default_Property{property_polarity = property_polarity obj} then P.Nothing else P.Just $ default_Property{property_polarity = property_polarity obj}
    ]
from_Property :: Property -> T.ThriftVal
from_Property record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("value",T.TString $ E.encodeUtf8 _v2))) $ property_value record
  , (\_v2 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v2))) $ property_metadata record
  , (\_v2 -> (3, ("polarity",T.TDouble _v2))) <$> property_polarity record
  ]
write_Property :: (T.Protocol p, T.Transport t) => p t -> Property -> P.IO ()
write_Property oprot record = T.writeVal oprot $ from_Property record
encode_Property :: (T.Protocol p, T.Transport t) => p t -> Property -> LBS.ByteString
encode_Property oprot record = T.serializeVal oprot $ from_Property record
to_Property :: T.ThriftVal -> Property
to_Property (T.TStruct fields) = Property{
  property_value = P.maybe (P.error "Missing required field: value") (\(_,_val4) -> (case _val4 of {T.TString _val5 -> E.decodeUtf8 _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  property_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val4) -> (case _val4 of {T.TStruct _val6 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val6)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  property_polarity = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TDouble _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Property _ = P.error "not a struct"
read_Property :: (T.Transport t, T.Protocol p) => p t -> P.IO Property
read_Property iprot = to_Property <$> T.readVal iprot (T.T_STRUCT typemap_Property)
decode_Property :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Property
decode_Property iprot bs = to_Property $ T.deserializeVal iprot (T.T_STRUCT typemap_Property) bs
typemap_Property :: T.TypeMap
typemap_Property = Map.fromList [(1,("value",T.T_STRING)),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("polarity",T.T_DOUBLE))]
default_Property :: Property
default_Property = Property{
  property_value = "",
  property_metadata = Metadata_Types.default_AnnotationMetadata,
  property_polarity = P.Nothing}
data Argument = Argument  { argument_role :: P.Maybe LT.Text
  , argument_entityId :: P.Maybe Uuid_Types.UUID
  , argument_situationId :: P.Maybe Uuid_Types.UUID
  , argument_propertyList :: P.Maybe (Vector.Vector Property)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Argument where
  hashWithSalt salt record = salt   `H.hashWithSalt` argument_role record   `H.hashWithSalt` argument_entityId record   `H.hashWithSalt` argument_situationId record   `H.hashWithSalt` argument_propertyList record  
instance QC.Arbitrary Argument where 
  arbitrary = M.liftM Argument (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Argument = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Argument{argument_role = argument_role obj} then P.Nothing else P.Just $ default_Argument{argument_role = argument_role obj}
    , if obj == default_Argument{argument_entityId = argument_entityId obj} then P.Nothing else P.Just $ default_Argument{argument_entityId = argument_entityId obj}
    , if obj == default_Argument{argument_situationId = argument_situationId obj} then P.Nothing else P.Just $ default_Argument{argument_situationId = argument_situationId obj}
    , if obj == default_Argument{argument_propertyList = argument_propertyList obj} then P.Nothing else P.Just $ default_Argument{argument_propertyList = argument_propertyList obj}
    ]
from_Argument :: Argument -> T.ThriftVal
from_Argument record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10 -> (1, ("role",T.TString $ E.encodeUtf8 _v10))) <$> argument_role record
  , (\_v10 -> (2, ("entityId",Uuid_Types.from_UUID _v10))) <$> argument_entityId record
  , (\_v10 -> (3, ("situationId",Uuid_Types.from_UUID _v10))) <$> argument_situationId record
  , (\_v10 -> (4, ("propertyList",T.TList (T.T_STRUCT typemap_Property) $ P.map (\_v12 -> from_Property _v12) $ Vector.toList _v10))) <$> argument_propertyList record
  ]
write_Argument :: (T.Protocol p, T.Transport t) => p t -> Argument -> P.IO ()
write_Argument oprot record = T.writeVal oprot $ from_Argument record
encode_Argument :: (T.Protocol p, T.Transport t) => p t -> Argument -> LBS.ByteString
encode_Argument oprot record = T.serializeVal oprot $ from_Argument record
to_Argument :: T.ThriftVal -> Argument
to_Argument (T.TStruct fields) = Argument{
  argument_role = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val15 -> E.decodeUtf8 _val15; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  argument_entityId = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TStruct _val16 -> (Uuid_Types.to_UUID (T.TStruct _val16)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  argument_situationId = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TStruct _val17 -> (Uuid_Types.to_UUID (T.TStruct _val17)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  argument_propertyList = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TList _ _val18 -> (Vector.fromList $ P.map (\_v19 -> (case _v19 of {T.TStruct _val20 -> (to_Property (T.TStruct _val20)); _ -> P.error "wrong type"})) _val18); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Argument _ = P.error "not a struct"
read_Argument :: (T.Transport t, T.Protocol p) => p t -> P.IO Argument
read_Argument iprot = to_Argument <$> T.readVal iprot (T.T_STRUCT typemap_Argument)
decode_Argument :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Argument
decode_Argument iprot bs = to_Argument $ T.deserializeVal iprot (T.T_STRUCT typemap_Argument) bs
typemap_Argument :: T.TypeMap
typemap_Argument = Map.fromList [(1,("role",T.T_STRING)),(2,("entityId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("situationId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(4,("propertyList",(T.T_LIST (T.T_STRUCT typemap_Property))))]
default_Argument :: Argument
default_Argument = Argument{
  argument_role = P.Nothing,
  argument_entityId = P.Nothing,
  argument_situationId = P.Nothing,
  argument_propertyList = P.Nothing}
data Justification = Justification  { justification_justificationType :: P.Maybe LT.Text
  , justification_mentionId :: Uuid_Types.UUID
  , justification_tokenRefSeqList :: P.Maybe (Vector.Vector Structure_Types.TokenRefSequence)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Justification where
  hashWithSalt salt record = salt   `H.hashWithSalt` justification_justificationType record   `H.hashWithSalt` justification_mentionId record   `H.hashWithSalt` justification_tokenRefSeqList record  
instance QC.Arbitrary Justification where 
  arbitrary = M.liftM Justification (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Justification = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Justification{justification_justificationType = justification_justificationType obj} then P.Nothing else P.Just $ default_Justification{justification_justificationType = justification_justificationType obj}
    , if obj == default_Justification{justification_mentionId = justification_mentionId obj} then P.Nothing else P.Just $ default_Justification{justification_mentionId = justification_mentionId obj}
    , if obj == default_Justification{justification_tokenRefSeqList = justification_tokenRefSeqList obj} then P.Nothing else P.Just $ default_Justification{justification_tokenRefSeqList = justification_tokenRefSeqList obj}
    ]
from_Justification :: Justification -> T.ThriftVal
from_Justification record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v23 -> (1, ("justificationType",T.TString $ E.encodeUtf8 _v23))) <$> justification_justificationType record
  , (\_v23 -> P.Just (2, ("mentionId",Uuid_Types.from_UUID _v23))) $ justification_mentionId record
  , (\_v23 -> (3, ("tokenRefSeqList",T.TList (T.T_STRUCT Structure_Types.typemap_TokenRefSequence) $ P.map (\_v25 -> Structure_Types.from_TokenRefSequence _v25) $ Vector.toList _v23))) <$> justification_tokenRefSeqList record
  ]
write_Justification :: (T.Protocol p, T.Transport t) => p t -> Justification -> P.IO ()
write_Justification oprot record = T.writeVal oprot $ from_Justification record
encode_Justification :: (T.Protocol p, T.Transport t) => p t -> Justification -> LBS.ByteString
encode_Justification oprot record = T.serializeVal oprot $ from_Justification record
to_Justification :: T.ThriftVal -> Justification
to_Justification (T.TStruct fields) = Justification{
  justification_justificationType = P.maybe (P.Nothing) (\(_,_val27) -> P.Just (case _val27 of {T.TString _val28 -> E.decodeUtf8 _val28; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  justification_mentionId = P.maybe (P.error "Missing required field: mentionId") (\(_,_val27) -> (case _val27 of {T.TStruct _val29 -> (Uuid_Types.to_UUID (T.TStruct _val29)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  justification_tokenRefSeqList = P.maybe (P.Nothing) (\(_,_val27) -> P.Just (case _val27 of {T.TList _ _val30 -> (Vector.fromList $ P.map (\_v31 -> (case _v31 of {T.TStruct _val32 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val32)); _ -> P.error "wrong type"})) _val30); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Justification _ = P.error "not a struct"
read_Justification :: (T.Transport t, T.Protocol p) => p t -> P.IO Justification
read_Justification iprot = to_Justification <$> T.readVal iprot (T.T_STRUCT typemap_Justification)
decode_Justification :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Justification
decode_Justification iprot bs = to_Justification $ T.deserializeVal iprot (T.T_STRUCT typemap_Justification) bs
typemap_Justification :: T.TypeMap
typemap_Justification = Map.fromList [(1,("justificationType",T.T_STRING)),(2,("mentionId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("tokenRefSeqList",(T.T_LIST (T.T_STRUCT Structure_Types.typemap_TokenRefSequence))))]
default_Justification :: Justification
default_Justification = Justification{
  justification_justificationType = P.Nothing,
  justification_mentionId = Uuid_Types.default_UUID,
  justification_tokenRefSeqList = P.Nothing}
data TimeML = TimeML  { timeML_timeMLClass :: P.Maybe LT.Text
  , timeML_timeMLTense :: P.Maybe LT.Text
  , timeML_timeMLAspect :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimeML where
  hashWithSalt salt record = salt   `H.hashWithSalt` timeML_timeMLClass record   `H.hashWithSalt` timeML_timeMLTense record   `H.hashWithSalt` timeML_timeMLAspect record  
instance QC.Arbitrary TimeML where 
  arbitrary = M.liftM TimeML (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimeML = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimeML{timeML_timeMLClass = timeML_timeMLClass obj} then P.Nothing else P.Just $ default_TimeML{timeML_timeMLClass = timeML_timeMLClass obj}
    , if obj == default_TimeML{timeML_timeMLTense = timeML_timeMLTense obj} then P.Nothing else P.Just $ default_TimeML{timeML_timeMLTense = timeML_timeMLTense obj}
    , if obj == default_TimeML{timeML_timeMLAspect = timeML_timeMLAspect obj} then P.Nothing else P.Just $ default_TimeML{timeML_timeMLAspect = timeML_timeMLAspect obj}
    ]
from_TimeML :: TimeML -> T.ThriftVal
from_TimeML record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v35 -> (1, ("timeMLClass",T.TString $ E.encodeUtf8 _v35))) <$> timeML_timeMLClass record
  , (\_v35 -> (2, ("timeMLTense",T.TString $ E.encodeUtf8 _v35))) <$> timeML_timeMLTense record
  , (\_v35 -> (3, ("timeMLAspect",T.TString $ E.encodeUtf8 _v35))) <$> timeML_timeMLAspect record
  ]
write_TimeML :: (T.Protocol p, T.Transport t) => p t -> TimeML -> P.IO ()
write_TimeML oprot record = T.writeVal oprot $ from_TimeML record
encode_TimeML :: (T.Protocol p, T.Transport t) => p t -> TimeML -> LBS.ByteString
encode_TimeML oprot record = T.serializeVal oprot $ from_TimeML record
to_TimeML :: T.ThriftVal -> TimeML
to_TimeML (T.TStruct fields) = TimeML{
  timeML_timeMLClass = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TString _val38 -> E.decodeUtf8 _val38; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timeML_timeMLTense = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TString _val39 -> E.decodeUtf8 _val39; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timeML_timeMLAspect = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TString _val40 -> E.decodeUtf8 _val40; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimeML _ = P.error "not a struct"
read_TimeML :: (T.Transport t, T.Protocol p) => p t -> P.IO TimeML
read_TimeML iprot = to_TimeML <$> T.readVal iprot (T.T_STRUCT typemap_TimeML)
decode_TimeML :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimeML
decode_TimeML iprot bs = to_TimeML $ T.deserializeVal iprot (T.T_STRUCT typemap_TimeML) bs
typemap_TimeML :: T.TypeMap
typemap_TimeML = Map.fromList [(1,("timeMLClass",T.T_STRING)),(2,("timeMLTense",T.T_STRING)),(3,("timeMLAspect",T.T_STRING))]
default_TimeML :: TimeML
default_TimeML = TimeML{
  timeML_timeMLClass = P.Nothing,
  timeML_timeMLTense = P.Nothing,
  timeML_timeMLAspect = P.Nothing}
data Situation = Situation  { situation_uuid :: Uuid_Types.UUID
  , situation_situationType :: LT.Text
  , situation_situationKind :: P.Maybe LT.Text
  , situation_argumentList :: P.Maybe (Vector.Vector Argument)
  , situation_mentionIdList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , situation_justificationList :: P.Maybe (Vector.Vector Justification)
  , situation_timeML :: P.Maybe TimeML
  , situation_intensity :: P.Maybe P.Double
  , situation_polarity :: P.Maybe LT.Text
  , situation_confidence :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Situation where
  hashWithSalt salt record = salt   `H.hashWithSalt` situation_uuid record   `H.hashWithSalt` situation_situationType record   `H.hashWithSalt` situation_situationKind record   `H.hashWithSalt` situation_argumentList record   `H.hashWithSalt` situation_mentionIdList record   `H.hashWithSalt` situation_justificationList record   `H.hashWithSalt` situation_timeML record   `H.hashWithSalt` situation_intensity record   `H.hashWithSalt` situation_polarity record   `H.hashWithSalt` situation_confidence record  
instance QC.Arbitrary Situation where 
  arbitrary = M.liftM Situation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Situation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Situation{situation_uuid = situation_uuid obj} then P.Nothing else P.Just $ default_Situation{situation_uuid = situation_uuid obj}
    , if obj == default_Situation{situation_situationType = situation_situationType obj} then P.Nothing else P.Just $ default_Situation{situation_situationType = situation_situationType obj}
    , if obj == default_Situation{situation_situationKind = situation_situationKind obj} then P.Nothing else P.Just $ default_Situation{situation_situationKind = situation_situationKind obj}
    , if obj == default_Situation{situation_argumentList = situation_argumentList obj} then P.Nothing else P.Just $ default_Situation{situation_argumentList = situation_argumentList obj}
    , if obj == default_Situation{situation_mentionIdList = situation_mentionIdList obj} then P.Nothing else P.Just $ default_Situation{situation_mentionIdList = situation_mentionIdList obj}
    , if obj == default_Situation{situation_justificationList = situation_justificationList obj} then P.Nothing else P.Just $ default_Situation{situation_justificationList = situation_justificationList obj}
    , if obj == default_Situation{situation_timeML = situation_timeML obj} then P.Nothing else P.Just $ default_Situation{situation_timeML = situation_timeML obj}
    , if obj == default_Situation{situation_intensity = situation_intensity obj} then P.Nothing else P.Just $ default_Situation{situation_intensity = situation_intensity obj}
    , if obj == default_Situation{situation_polarity = situation_polarity obj} then P.Nothing else P.Just $ default_Situation{situation_polarity = situation_polarity obj}
    , if obj == default_Situation{situation_confidence = situation_confidence obj} then P.Nothing else P.Just $ default_Situation{situation_confidence = situation_confidence obj}
    ]
from_Situation :: Situation -> T.ThriftVal
from_Situation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v43 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v43))) $ situation_uuid record
  , (\_v43 -> P.Just (2, ("situationType",T.TString $ E.encodeUtf8 _v43))) $ situation_situationType record
  , (\_v43 -> (3, ("argumentList",T.TList (T.T_STRUCT typemap_Argument) $ P.map (\_v45 -> from_Argument _v45) $ Vector.toList _v43))) <$> situation_argumentList record
  , (\_v43 -> (4, ("mentionIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v47 -> Uuid_Types.from_UUID _v47) $ Vector.toList _v43))) <$> situation_mentionIdList record
  , (\_v43 -> (5, ("justificationList",T.TList (T.T_STRUCT typemap_Justification) $ P.map (\_v49 -> from_Justification _v49) $ Vector.toList _v43))) <$> situation_justificationList record
  , (\_v43 -> (50, ("situationKind",T.TString $ E.encodeUtf8 _v43))) <$> situation_situationKind record
  , (\_v43 -> (54, ("timeML",from_TimeML _v43))) <$> situation_timeML record
  , (\_v43 -> (100, ("intensity",T.TDouble _v43))) <$> situation_intensity record
  , (\_v43 -> (101, ("polarity",T.TString $ E.encodeUtf8 _v43))) <$> situation_polarity record
  , (\_v43 -> (200, ("confidence",T.TDouble _v43))) <$> situation_confidence record
  ]
write_Situation :: (T.Protocol p, T.Transport t) => p t -> Situation -> P.IO ()
write_Situation oprot record = T.writeVal oprot $ from_Situation record
encode_Situation :: (T.Protocol p, T.Transport t) => p t -> Situation -> LBS.ByteString
encode_Situation oprot record = T.serializeVal oprot $ from_Situation record
to_Situation :: T.ThriftVal -> Situation
to_Situation (T.TStruct fields) = Situation{
  situation_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val51) -> (case _val51 of {T.TStruct _val52 -> (Uuid_Types.to_UUID (T.TStruct _val52)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  situation_situationType = P.maybe (P.error "Missing required field: situationType") (\(_,_val51) -> (case _val51 of {T.TString _val53 -> E.decodeUtf8 _val53; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  situation_situationKind = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val54 -> E.decodeUtf8 _val54; _ -> P.error "wrong type"})) (Map.lookup (50) fields),
  situation_argumentList = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TList _ _val55 -> (Vector.fromList $ P.map (\_v56 -> (case _v56 of {T.TStruct _val57 -> (to_Argument (T.TStruct _val57)); _ -> P.error "wrong type"})) _val55); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  situation_mentionIdList = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TList _ _val58 -> (Vector.fromList $ P.map (\_v59 -> (case _v59 of {T.TStruct _val60 -> (Uuid_Types.to_UUID (T.TStruct _val60)); _ -> P.error "wrong type"})) _val58); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  situation_justificationList = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TList _ _val61 -> (Vector.fromList $ P.map (\_v62 -> (case _v62 of {T.TStruct _val63 -> (to_Justification (T.TStruct _val63)); _ -> P.error "wrong type"})) _val61); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  situation_timeML = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TStruct _val64 -> (to_TimeML (T.TStruct _val64)); _ -> P.error "wrong type"})) (Map.lookup (54) fields),
  situation_intensity = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TDouble _val65 -> _val65; _ -> P.error "wrong type"})) (Map.lookup (100) fields),
  situation_polarity = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val66 -> E.decodeUtf8 _val66; _ -> P.error "wrong type"})) (Map.lookup (101) fields),
  situation_confidence = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TDouble _val67 -> _val67; _ -> P.error "wrong type"})) (Map.lookup (200) fields)
  }
to_Situation _ = P.error "not a struct"
read_Situation :: (T.Transport t, T.Protocol p) => p t -> P.IO Situation
read_Situation iprot = to_Situation <$> T.readVal iprot (T.T_STRUCT typemap_Situation)
decode_Situation :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Situation
decode_Situation iprot bs = to_Situation $ T.deserializeVal iprot (T.T_STRUCT typemap_Situation) bs
typemap_Situation :: T.TypeMap
typemap_Situation = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("situationType",T.T_STRING)),(3,("argumentList",(T.T_LIST (T.T_STRUCT typemap_Argument)))),(4,("mentionIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(5,("justificationList",(T.T_LIST (T.T_STRUCT typemap_Justification)))),(50,("situationKind",T.T_STRING)),(54,("timeML",(T.T_STRUCT typemap_TimeML))),(100,("intensity",T.T_DOUBLE)),(101,("polarity",T.T_STRING)),(200,("confidence",T.T_DOUBLE))]
default_Situation :: Situation
default_Situation = Situation{
  situation_uuid = Uuid_Types.default_UUID,
  situation_situationType = "",
  situation_argumentList = P.Nothing,
  situation_mentionIdList = P.Nothing,
  situation_justificationList = P.Nothing,
  situation_situationKind = P.Nothing,
  situation_timeML = P.Nothing,
  situation_intensity = P.Nothing,
  situation_polarity = P.Nothing,
  situation_confidence = P.Nothing}
data SituationSet = SituationSet  { situationSet_uuid :: Uuid_Types.UUID
  , situationSet_metadata :: Metadata_Types.AnnotationMetadata
  , situationSet_situationList :: (Vector.Vector Situation)
  , situationSet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SituationSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` situationSet_uuid record   `H.hashWithSalt` situationSet_metadata record   `H.hashWithSalt` situationSet_situationList record   `H.hashWithSalt` situationSet_linkingList record  
instance QC.Arbitrary SituationSet where 
  arbitrary = M.liftM SituationSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SituationSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SituationSet{situationSet_uuid = situationSet_uuid obj} then P.Nothing else P.Just $ default_SituationSet{situationSet_uuid = situationSet_uuid obj}
    , if obj == default_SituationSet{situationSet_metadata = situationSet_metadata obj} then P.Nothing else P.Just $ default_SituationSet{situationSet_metadata = situationSet_metadata obj}
    , if obj == default_SituationSet{situationSet_situationList = situationSet_situationList obj} then P.Nothing else P.Just $ default_SituationSet{situationSet_situationList = situationSet_situationList obj}
    , if obj == default_SituationSet{situationSet_linkingList = situationSet_linkingList obj} then P.Nothing else P.Just $ default_SituationSet{situationSet_linkingList = situationSet_linkingList obj}
    ]
from_SituationSet :: SituationSet -> T.ThriftVal
from_SituationSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v70 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v70))) $ situationSet_uuid record
  , (\_v70 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v70))) $ situationSet_metadata record
  , (\_v70 -> P.Just (3, ("situationList",T.TList (T.T_STRUCT typemap_Situation) $ P.map (\_v72 -> from_Situation _v72) $ Vector.toList _v70))) $ situationSet_situationList record
  , (\_v70 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v74 -> Linking_Types.from_Linking _v74) $ Vector.toList _v70))) <$> situationSet_linkingList record
  ]
write_SituationSet :: (T.Protocol p, T.Transport t) => p t -> SituationSet -> P.IO ()
write_SituationSet oprot record = T.writeVal oprot $ from_SituationSet record
encode_SituationSet :: (T.Protocol p, T.Transport t) => p t -> SituationSet -> LBS.ByteString
encode_SituationSet oprot record = T.serializeVal oprot $ from_SituationSet record
to_SituationSet :: T.ThriftVal -> SituationSet
to_SituationSet (T.TStruct fields) = SituationSet{
  situationSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val76) -> (case _val76 of {T.TStruct _val77 -> (Uuid_Types.to_UUID (T.TStruct _val77)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  situationSet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val76) -> (case _val76 of {T.TStruct _val78 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val78)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  situationSet_situationList = P.maybe (P.error "Missing required field: situationList") (\(_,_val76) -> (case _val76 of {T.TList _ _val79 -> (Vector.fromList $ P.map (\_v80 -> (case _v80 of {T.TStruct _val81 -> (to_Situation (T.TStruct _val81)); _ -> P.error "wrong type"})) _val79); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  situationSet_linkingList = P.maybe (P.Nothing) (\(_,_val76) -> P.Just (case _val76 of {T.TList _ _val82 -> (Vector.fromList $ P.map (\_v83 -> (case _v83 of {T.TStruct _val84 -> (Linking_Types.to_Linking (T.TStruct _val84)); _ -> P.error "wrong type"})) _val82); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SituationSet _ = P.error "not a struct"
read_SituationSet :: (T.Transport t, T.Protocol p) => p t -> P.IO SituationSet
read_SituationSet iprot = to_SituationSet <$> T.readVal iprot (T.T_STRUCT typemap_SituationSet)
decode_SituationSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SituationSet
decode_SituationSet iprot bs = to_SituationSet $ T.deserializeVal iprot (T.T_STRUCT typemap_SituationSet) bs
typemap_SituationSet :: T.TypeMap
typemap_SituationSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("situationList",(T.T_LIST (T.T_STRUCT typemap_Situation)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking))))]
default_SituationSet :: SituationSet
default_SituationSet = SituationSet{
  situationSet_uuid = Uuid_Types.default_UUID,
  situationSet_metadata = Metadata_Types.default_AnnotationMetadata,
  situationSet_situationList = Vector.empty,
  situationSet_linkingList = P.Nothing}
data MentionArgument = MentionArgument  { mentionArgument_role :: P.Maybe LT.Text
  , mentionArgument_entityMentionId :: P.Maybe Uuid_Types.UUID
  , mentionArgument_situationMentionId :: P.Maybe Uuid_Types.UUID
  , mentionArgument_tokens :: P.Maybe Structure_Types.TokenRefSequence
  , mentionArgument_confidence :: P.Maybe P.Double
  , mentionArgument_propertyList :: P.Maybe (Vector.Vector Property)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MentionArgument where
  hashWithSalt salt record = salt   `H.hashWithSalt` mentionArgument_role record   `H.hashWithSalt` mentionArgument_entityMentionId record   `H.hashWithSalt` mentionArgument_situationMentionId record   `H.hashWithSalt` mentionArgument_tokens record   `H.hashWithSalt` mentionArgument_confidence record   `H.hashWithSalt` mentionArgument_propertyList record  
instance QC.Arbitrary MentionArgument where 
  arbitrary = M.liftM MentionArgument (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MentionArgument = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MentionArgument{mentionArgument_role = mentionArgument_role obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_role = mentionArgument_role obj}
    , if obj == default_MentionArgument{mentionArgument_entityMentionId = mentionArgument_entityMentionId obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_entityMentionId = mentionArgument_entityMentionId obj}
    , if obj == default_MentionArgument{mentionArgument_situationMentionId = mentionArgument_situationMentionId obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_situationMentionId = mentionArgument_situationMentionId obj}
    , if obj == default_MentionArgument{mentionArgument_tokens = mentionArgument_tokens obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_tokens = mentionArgument_tokens obj}
    , if obj == default_MentionArgument{mentionArgument_confidence = mentionArgument_confidence obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_confidence = mentionArgument_confidence obj}
    , if obj == default_MentionArgument{mentionArgument_propertyList = mentionArgument_propertyList obj} then P.Nothing else P.Just $ default_MentionArgument{mentionArgument_propertyList = mentionArgument_propertyList obj}
    ]
from_MentionArgument :: MentionArgument -> T.ThriftVal
from_MentionArgument record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v87 -> (1, ("role",T.TString $ E.encodeUtf8 _v87))) <$> mentionArgument_role record
  , (\_v87 -> (2, ("entityMentionId",Uuid_Types.from_UUID _v87))) <$> mentionArgument_entityMentionId record
  , (\_v87 -> (3, ("situationMentionId",Uuid_Types.from_UUID _v87))) <$> mentionArgument_situationMentionId record
  , (\_v87 -> (4, ("tokens",Structure_Types.from_TokenRefSequence _v87))) <$> mentionArgument_tokens record
  , (\_v87 -> (5, ("confidence",T.TDouble _v87))) <$> mentionArgument_confidence record
  , (\_v87 -> (6, ("propertyList",T.TList (T.T_STRUCT typemap_Property) $ P.map (\_v89 -> from_Property _v89) $ Vector.toList _v87))) <$> mentionArgument_propertyList record
  ]
write_MentionArgument :: (T.Protocol p, T.Transport t) => p t -> MentionArgument -> P.IO ()
write_MentionArgument oprot record = T.writeVal oprot $ from_MentionArgument record
encode_MentionArgument :: (T.Protocol p, T.Transport t) => p t -> MentionArgument -> LBS.ByteString
encode_MentionArgument oprot record = T.serializeVal oprot $ from_MentionArgument record
to_MentionArgument :: T.ThriftVal -> MentionArgument
to_MentionArgument (T.TStruct fields) = MentionArgument{
  mentionArgument_role = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TString _val92 -> E.decodeUtf8 _val92; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  mentionArgument_entityMentionId = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TStruct _val93 -> (Uuid_Types.to_UUID (T.TStruct _val93)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  mentionArgument_situationMentionId = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TStruct _val94 -> (Uuid_Types.to_UUID (T.TStruct _val94)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  mentionArgument_tokens = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TStruct _val95 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val95)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  mentionArgument_confidence = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TDouble _val96 -> _val96; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  mentionArgument_propertyList = P.maybe (P.Nothing) (\(_,_val91) -> P.Just (case _val91 of {T.TList _ _val97 -> (Vector.fromList $ P.map (\_v98 -> (case _v98 of {T.TStruct _val99 -> (to_Property (T.TStruct _val99)); _ -> P.error "wrong type"})) _val97); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_MentionArgument _ = P.error "not a struct"
read_MentionArgument :: (T.Transport t, T.Protocol p) => p t -> P.IO MentionArgument
read_MentionArgument iprot = to_MentionArgument <$> T.readVal iprot (T.T_STRUCT typemap_MentionArgument)
decode_MentionArgument :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MentionArgument
decode_MentionArgument iprot bs = to_MentionArgument $ T.deserializeVal iprot (T.T_STRUCT typemap_MentionArgument) bs
typemap_MentionArgument :: T.TypeMap
typemap_MentionArgument = Map.fromList [(1,("role",T.T_STRING)),(2,("entityMentionId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("situationMentionId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(4,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(5,("confidence",T.T_DOUBLE)),(6,("propertyList",(T.T_LIST (T.T_STRUCT typemap_Property))))]
default_MentionArgument :: MentionArgument
default_MentionArgument = MentionArgument{
  mentionArgument_role = P.Nothing,
  mentionArgument_entityMentionId = P.Nothing,
  mentionArgument_situationMentionId = P.Nothing,
  mentionArgument_tokens = P.Nothing,
  mentionArgument_confidence = P.Nothing,
  mentionArgument_propertyList = P.Nothing}
data SituationMention = SituationMention  { situationMention_uuid :: Uuid_Types.UUID
  , situationMention_text :: P.Maybe LT.Text
  , situationMention_situationType :: P.Maybe LT.Text
  , situationMention_situationKind :: P.Maybe LT.Text
  , situationMention_argumentList :: (Vector.Vector MentionArgument)
  , situationMention_intensity :: P.Maybe P.Double
  , situationMention_polarity :: P.Maybe LT.Text
  , situationMention_tokens :: P.Maybe Structure_Types.TokenRefSequence
  , situationMention_confidence :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SituationMention where
  hashWithSalt salt record = salt   `H.hashWithSalt` situationMention_uuid record   `H.hashWithSalt` situationMention_text record   `H.hashWithSalt` situationMention_situationType record   `H.hashWithSalt` situationMention_situationKind record   `H.hashWithSalt` situationMention_argumentList record   `H.hashWithSalt` situationMention_intensity record   `H.hashWithSalt` situationMention_polarity record   `H.hashWithSalt` situationMention_tokens record   `H.hashWithSalt` situationMention_confidence record  
instance QC.Arbitrary SituationMention where 
  arbitrary = M.liftM SituationMention (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SituationMention = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SituationMention{situationMention_uuid = situationMention_uuid obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_uuid = situationMention_uuid obj}
    , if obj == default_SituationMention{situationMention_text = situationMention_text obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_text = situationMention_text obj}
    , if obj == default_SituationMention{situationMention_situationType = situationMention_situationType obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_situationType = situationMention_situationType obj}
    , if obj == default_SituationMention{situationMention_situationKind = situationMention_situationKind obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_situationKind = situationMention_situationKind obj}
    , if obj == default_SituationMention{situationMention_argumentList = situationMention_argumentList obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_argumentList = situationMention_argumentList obj}
    , if obj == default_SituationMention{situationMention_intensity = situationMention_intensity obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_intensity = situationMention_intensity obj}
    , if obj == default_SituationMention{situationMention_polarity = situationMention_polarity obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_polarity = situationMention_polarity obj}
    , if obj == default_SituationMention{situationMention_tokens = situationMention_tokens obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_tokens = situationMention_tokens obj}
    , if obj == default_SituationMention{situationMention_confidence = situationMention_confidence obj} then P.Nothing else P.Just $ default_SituationMention{situationMention_confidence = situationMention_confidence obj}
    ]
from_SituationMention :: SituationMention -> T.ThriftVal
from_SituationMention record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v102 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v102))) $ situationMention_uuid record
  , (\_v102 -> (2, ("text",T.TString $ E.encodeUtf8 _v102))) <$> situationMention_text record
  , (\_v102 -> (3, ("situationType",T.TString $ E.encodeUtf8 _v102))) <$> situationMention_situationType record
  , (\_v102 -> P.Just (4, ("argumentList",T.TList (T.T_STRUCT typemap_MentionArgument) $ P.map (\_v104 -> from_MentionArgument _v104) $ Vector.toList _v102))) $ situationMention_argumentList record
  , (\_v102 -> (50, ("situationKind",T.TString $ E.encodeUtf8 _v102))) <$> situationMention_situationKind record
  , (\_v102 -> (100, ("intensity",T.TDouble _v102))) <$> situationMention_intensity record
  , (\_v102 -> (101, ("polarity",T.TString $ E.encodeUtf8 _v102))) <$> situationMention_polarity record
  , (\_v102 -> (150, ("tokens",Structure_Types.from_TokenRefSequence _v102))) <$> situationMention_tokens record
  , (\_v102 -> (200, ("confidence",T.TDouble _v102))) <$> situationMention_confidence record
  ]
write_SituationMention :: (T.Protocol p, T.Transport t) => p t -> SituationMention -> P.IO ()
write_SituationMention oprot record = T.writeVal oprot $ from_SituationMention record
encode_SituationMention :: (T.Protocol p, T.Transport t) => p t -> SituationMention -> LBS.ByteString
encode_SituationMention oprot record = T.serializeVal oprot $ from_SituationMention record
to_SituationMention :: T.ThriftVal -> SituationMention
to_SituationMention (T.TStruct fields) = SituationMention{
  situationMention_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val106) -> (case _val106 of {T.TStruct _val107 -> (Uuid_Types.to_UUID (T.TStruct _val107)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  situationMention_text = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TString _val108 -> E.decodeUtf8 _val108; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  situationMention_situationType = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TString _val109 -> E.decodeUtf8 _val109; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  situationMention_situationKind = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TString _val110 -> E.decodeUtf8 _val110; _ -> P.error "wrong type"})) (Map.lookup (50) fields),
  situationMention_argumentList = P.maybe (P.error "Missing required field: argumentList") (\(_,_val106) -> (case _val106 of {T.TList _ _val111 -> (Vector.fromList $ P.map (\_v112 -> (case _v112 of {T.TStruct _val113 -> (to_MentionArgument (T.TStruct _val113)); _ -> P.error "wrong type"})) _val111); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  situationMention_intensity = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TDouble _val114 -> _val114; _ -> P.error "wrong type"})) (Map.lookup (100) fields),
  situationMention_polarity = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TString _val115 -> E.decodeUtf8 _val115; _ -> P.error "wrong type"})) (Map.lookup (101) fields),
  situationMention_tokens = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TStruct _val116 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val116)); _ -> P.error "wrong type"})) (Map.lookup (150) fields),
  situationMention_confidence = P.maybe (P.Nothing) (\(_,_val106) -> P.Just (case _val106 of {T.TDouble _val117 -> _val117; _ -> P.error "wrong type"})) (Map.lookup (200) fields)
  }
to_SituationMention _ = P.error "not a struct"
read_SituationMention :: (T.Transport t, T.Protocol p) => p t -> P.IO SituationMention
read_SituationMention iprot = to_SituationMention <$> T.readVal iprot (T.T_STRUCT typemap_SituationMention)
decode_SituationMention :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SituationMention
decode_SituationMention iprot bs = to_SituationMention $ T.deserializeVal iprot (T.T_STRUCT typemap_SituationMention) bs
typemap_SituationMention :: T.TypeMap
typemap_SituationMention = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("text",T.T_STRING)),(3,("situationType",T.T_STRING)),(4,("argumentList",(T.T_LIST (T.T_STRUCT typemap_MentionArgument)))),(50,("situationKind",T.T_STRING)),(100,("intensity",T.T_DOUBLE)),(101,("polarity",T.T_STRING)),(150,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(200,("confidence",T.T_DOUBLE))]
default_SituationMention :: SituationMention
default_SituationMention = SituationMention{
  situationMention_uuid = Uuid_Types.default_UUID,
  situationMention_text = P.Nothing,
  situationMention_situationType = P.Nothing,
  situationMention_argumentList = Vector.empty,
  situationMention_situationKind = P.Nothing,
  situationMention_intensity = P.Nothing,
  situationMention_polarity = P.Nothing,
  situationMention_tokens = P.Nothing,
  situationMention_confidence = P.Nothing}
data SituationMentionSet = SituationMentionSet  { situationMentionSet_uuid :: Uuid_Types.UUID
  , situationMentionSet_metadata :: Metadata_Types.AnnotationMetadata
  , situationMentionSet_mentionList :: (Vector.Vector SituationMention)
  , situationMentionSet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SituationMentionSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` situationMentionSet_uuid record   `H.hashWithSalt` situationMentionSet_metadata record   `H.hashWithSalt` situationMentionSet_mentionList record   `H.hashWithSalt` situationMentionSet_linkingList record  
instance QC.Arbitrary SituationMentionSet where 
  arbitrary = M.liftM SituationMentionSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SituationMentionSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SituationMentionSet{situationMentionSet_uuid = situationMentionSet_uuid obj} then P.Nothing else P.Just $ default_SituationMentionSet{situationMentionSet_uuid = situationMentionSet_uuid obj}
    , if obj == default_SituationMentionSet{situationMentionSet_metadata = situationMentionSet_metadata obj} then P.Nothing else P.Just $ default_SituationMentionSet{situationMentionSet_metadata = situationMentionSet_metadata obj}
    , if obj == default_SituationMentionSet{situationMentionSet_mentionList = situationMentionSet_mentionList obj} then P.Nothing else P.Just $ default_SituationMentionSet{situationMentionSet_mentionList = situationMentionSet_mentionList obj}
    , if obj == default_SituationMentionSet{situationMentionSet_linkingList = situationMentionSet_linkingList obj} then P.Nothing else P.Just $ default_SituationMentionSet{situationMentionSet_linkingList = situationMentionSet_linkingList obj}
    ]
from_SituationMentionSet :: SituationMentionSet -> T.ThriftVal
from_SituationMentionSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v120 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v120))) $ situationMentionSet_uuid record
  , (\_v120 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v120))) $ situationMentionSet_metadata record
  , (\_v120 -> P.Just (3, ("mentionList",T.TList (T.T_STRUCT typemap_SituationMention) $ P.map (\_v122 -> from_SituationMention _v122) $ Vector.toList _v120))) $ situationMentionSet_mentionList record
  , (\_v120 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v124 -> Linking_Types.from_Linking _v124) $ Vector.toList _v120))) <$> situationMentionSet_linkingList record
  ]
write_SituationMentionSet :: (T.Protocol p, T.Transport t) => p t -> SituationMentionSet -> P.IO ()
write_SituationMentionSet oprot record = T.writeVal oprot $ from_SituationMentionSet record
encode_SituationMentionSet :: (T.Protocol p, T.Transport t) => p t -> SituationMentionSet -> LBS.ByteString
encode_SituationMentionSet oprot record = T.serializeVal oprot $ from_SituationMentionSet record
to_SituationMentionSet :: T.ThriftVal -> SituationMentionSet
to_SituationMentionSet (T.TStruct fields) = SituationMentionSet{
  situationMentionSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val126) -> (case _val126 of {T.TStruct _val127 -> (Uuid_Types.to_UUID (T.TStruct _val127)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  situationMentionSet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val126) -> (case _val126 of {T.TStruct _val128 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val128)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  situationMentionSet_mentionList = P.maybe (P.error "Missing required field: mentionList") (\(_,_val126) -> (case _val126 of {T.TList _ _val129 -> (Vector.fromList $ P.map (\_v130 -> (case _v130 of {T.TStruct _val131 -> (to_SituationMention (T.TStruct _val131)); _ -> P.error "wrong type"})) _val129); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  situationMentionSet_linkingList = P.maybe (P.Nothing) (\(_,_val126) -> P.Just (case _val126 of {T.TList _ _val132 -> (Vector.fromList $ P.map (\_v133 -> (case _v133 of {T.TStruct _val134 -> (Linking_Types.to_Linking (T.TStruct _val134)); _ -> P.error "wrong type"})) _val132); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SituationMentionSet _ = P.error "not a struct"
read_SituationMentionSet :: (T.Transport t, T.Protocol p) => p t -> P.IO SituationMentionSet
read_SituationMentionSet iprot = to_SituationMentionSet <$> T.readVal iprot (T.T_STRUCT typemap_SituationMentionSet)
decode_SituationMentionSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SituationMentionSet
decode_SituationMentionSet iprot bs = to_SituationMentionSet $ T.deserializeVal iprot (T.T_STRUCT typemap_SituationMentionSet) bs
typemap_SituationMentionSet :: T.TypeMap
typemap_SituationMentionSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("mentionList",(T.T_LIST (T.T_STRUCT typemap_SituationMention)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking))))]
default_SituationMentionSet :: SituationMentionSet
default_SituationMentionSet = SituationMentionSet{
  situationMentionSet_uuid = Uuid_Types.default_UUID,
  situationMentionSet_metadata = Metadata_Types.default_AnnotationMetadata,
  situationMentionSet_mentionList = Vector.empty,
  situationMentionSet_linkingList = P.Nothing}
