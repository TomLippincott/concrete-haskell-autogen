{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Summarization_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Communication_Types as Communication_Types
import Data.Concrete.Autogen.Services_Types as Services_Types
import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types


data SummarySourceType = DOCUMENT|TOKENIZATION|ENTITY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SummarySourceType where
  fromEnum t = case t of
    DOCUMENT -> 0
    TOKENIZATION -> 1
    ENTITY -> 2
  toEnum t = case t of
    0 -> DOCUMENT
    1 -> TOKENIZATION
    2 -> ENTITY
    _ -> X.throw T.ThriftException
instance H.Hashable SummarySourceType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SummarySourceType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SummarizationRequest = SummarizationRequest  { summarizationRequest_queryTerms :: P.Maybe (Vector.Vector LT.Text)
  , summarizationRequest_maximumTokens :: P.Maybe I.Int32
  , summarizationRequest_maximumCharacters :: P.Maybe I.Int32
  , summarizationRequest_sourceType :: P.Maybe SummarySourceType
  , summarizationRequest_sourceIds :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , summarizationRequest_sourceCommunication :: P.Maybe Communication_Types.Communication
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SummarizationRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` summarizationRequest_queryTerms record   `H.hashWithSalt` summarizationRequest_maximumTokens record   `H.hashWithSalt` summarizationRequest_maximumCharacters record   `H.hashWithSalt` summarizationRequest_sourceType record   `H.hashWithSalt` summarizationRequest_sourceIds record   `H.hashWithSalt` summarizationRequest_sourceCommunication record  
instance QC.Arbitrary SummarizationRequest where 
  arbitrary = M.liftM SummarizationRequest (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SummarizationRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SummarizationRequest{summarizationRequest_queryTerms = summarizationRequest_queryTerms obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_queryTerms = summarizationRequest_queryTerms obj}
    , if obj == default_SummarizationRequest{summarizationRequest_maximumTokens = summarizationRequest_maximumTokens obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_maximumTokens = summarizationRequest_maximumTokens obj}
    , if obj == default_SummarizationRequest{summarizationRequest_maximumCharacters = summarizationRequest_maximumCharacters obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_maximumCharacters = summarizationRequest_maximumCharacters obj}
    , if obj == default_SummarizationRequest{summarizationRequest_sourceType = summarizationRequest_sourceType obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_sourceType = summarizationRequest_sourceType obj}
    , if obj == default_SummarizationRequest{summarizationRequest_sourceIds = summarizationRequest_sourceIds obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_sourceIds = summarizationRequest_sourceIds obj}
    , if obj == default_SummarizationRequest{summarizationRequest_sourceCommunication = summarizationRequest_sourceCommunication obj} then P.Nothing else P.Just $ default_SummarizationRequest{summarizationRequest_sourceCommunication = summarizationRequest_sourceCommunication obj}
    ]
from_SummarizationRequest :: SummarizationRequest -> T.ThriftVal
from_SummarizationRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("queryTerms",T.TList T.T_STRING $ P.map (\_v4 -> T.TString $ E.encodeUtf8 _v4) $ Vector.toList _v2))) <$> summarizationRequest_queryTerms record
  , (\_v2 -> (2, ("maximumTokens",T.TI32 _v2))) <$> summarizationRequest_maximumTokens record
  , (\_v2 -> (3, ("maximumCharacters",T.TI32 _v2))) <$> summarizationRequest_maximumCharacters record
  , (\_v2 -> (4, ("sourceType",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) <$> summarizationRequest_sourceType record
  , (\_v2 -> (5, ("sourceIds",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v6 -> Uuid_Types.from_UUID _v6) $ Vector.toList _v2))) <$> summarizationRequest_sourceIds record
  , (\_v2 -> (6, ("sourceCommunication",Communication_Types.from_Communication _v2))) <$> summarizationRequest_sourceCommunication record
  ]
write_SummarizationRequest :: (T.Protocol p, T.Transport t) => p t -> SummarizationRequest -> P.IO ()
write_SummarizationRequest oprot record = T.writeVal oprot $ from_SummarizationRequest record
encode_SummarizationRequest :: (T.Protocol p, T.Transport t) => p t -> SummarizationRequest -> LBS.ByteString
encode_SummarizationRequest oprot record = T.serializeVal oprot $ from_SummarizationRequest record
to_SummarizationRequest :: T.ThriftVal -> SummarizationRequest
to_SummarizationRequest (T.TStruct fields) = SummarizationRequest{
  summarizationRequest_queryTerms = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TList _ _val9 -> (Vector.fromList $ P.map (\_v10 -> (case _v10 of {T.TString _val11 -> E.decodeUtf8 _val11; _ -> P.error "wrong type"})) _val9); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  summarizationRequest_maximumTokens = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TI32 _val12 -> _val12; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  summarizationRequest_maximumCharacters = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TI32 _val13 -> _val13; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  summarizationRequest_sourceType = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TI32 _val14 -> P.toEnum $ P.fromIntegral _val14; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  summarizationRequest_sourceIds = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TList _ _val15 -> (Vector.fromList $ P.map (\_v16 -> (case _v16 of {T.TStruct _val17 -> (Uuid_Types.to_UUID (T.TStruct _val17)); _ -> P.error "wrong type"})) _val15); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  summarizationRequest_sourceCommunication = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TStruct _val18 -> (Communication_Types.to_Communication (T.TStruct _val18)); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_SummarizationRequest _ = P.error "not a struct"
read_SummarizationRequest :: (T.Transport t, T.Protocol p) => p t -> P.IO SummarizationRequest
read_SummarizationRequest iprot = to_SummarizationRequest <$> T.readVal iprot (T.T_STRUCT typemap_SummarizationRequest)
decode_SummarizationRequest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SummarizationRequest
decode_SummarizationRequest iprot bs = to_SummarizationRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_SummarizationRequest) bs
typemap_SummarizationRequest :: T.TypeMap
typemap_SummarizationRequest = Map.fromList [(1,("queryTerms",(T.T_LIST T.T_STRING))),(2,("maximumTokens",T.T_I32)),(3,("maximumCharacters",T.T_I32)),(4,("sourceType",T.T_I32)),(5,("sourceIds",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(6,("sourceCommunication",(T.T_STRUCT Communication_Types.typemap_Communication)))]
default_SummarizationRequest :: SummarizationRequest
default_SummarizationRequest = SummarizationRequest{
  summarizationRequest_queryTerms = P.Nothing,
  summarizationRequest_maximumTokens = P.Nothing,
  summarizationRequest_maximumCharacters = P.Nothing,
  summarizationRequest_sourceType = P.Nothing,
  summarizationRequest_sourceIds = P.Nothing,
  summarizationRequest_sourceCommunication = P.Nothing}
data SummaryConcept = SummaryConcept  { summaryConcept_tokens :: P.Maybe Structure_Types.TokenRefSequence
  , summaryConcept_concept :: P.Maybe LT.Text
  , summaryConcept_confidence :: P.Maybe P.Double
  , summaryConcept_utility :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SummaryConcept where
  hashWithSalt salt record = salt   `H.hashWithSalt` summaryConcept_tokens record   `H.hashWithSalt` summaryConcept_concept record   `H.hashWithSalt` summaryConcept_confidence record   `H.hashWithSalt` summaryConcept_utility record  
instance QC.Arbitrary SummaryConcept where 
  arbitrary = M.liftM SummaryConcept (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SummaryConcept = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SummaryConcept{summaryConcept_tokens = summaryConcept_tokens obj} then P.Nothing else P.Just $ default_SummaryConcept{summaryConcept_tokens = summaryConcept_tokens obj}
    , if obj == default_SummaryConcept{summaryConcept_concept = summaryConcept_concept obj} then P.Nothing else P.Just $ default_SummaryConcept{summaryConcept_concept = summaryConcept_concept obj}
    , if obj == default_SummaryConcept{summaryConcept_confidence = summaryConcept_confidence obj} then P.Nothing else P.Just $ default_SummaryConcept{summaryConcept_confidence = summaryConcept_confidence obj}
    , if obj == default_SummaryConcept{summaryConcept_utility = summaryConcept_utility obj} then P.Nothing else P.Just $ default_SummaryConcept{summaryConcept_utility = summaryConcept_utility obj}
    ]
from_SummaryConcept :: SummaryConcept -> T.ThriftVal
from_SummaryConcept record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v21 -> (1, ("tokens",Structure_Types.from_TokenRefSequence _v21))) <$> summaryConcept_tokens record
  , (\_v21 -> (2, ("concept",T.TString $ E.encodeUtf8 _v21))) <$> summaryConcept_concept record
  , (\_v21 -> (3, ("confidence",T.TDouble _v21))) <$> summaryConcept_confidence record
  , (\_v21 -> (4, ("utility",T.TDouble _v21))) <$> summaryConcept_utility record
  ]
write_SummaryConcept :: (T.Protocol p, T.Transport t) => p t -> SummaryConcept -> P.IO ()
write_SummaryConcept oprot record = T.writeVal oprot $ from_SummaryConcept record
encode_SummaryConcept :: (T.Protocol p, T.Transport t) => p t -> SummaryConcept -> LBS.ByteString
encode_SummaryConcept oprot record = T.serializeVal oprot $ from_SummaryConcept record
to_SummaryConcept :: T.ThriftVal -> SummaryConcept
to_SummaryConcept (T.TStruct fields) = SummaryConcept{
  summaryConcept_tokens = P.maybe (P.Nothing) (\(_,_val23) -> P.Just (case _val23 of {T.TStruct _val24 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val24)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  summaryConcept_concept = P.maybe (P.Nothing) (\(_,_val23) -> P.Just (case _val23 of {T.TString _val25 -> E.decodeUtf8 _val25; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  summaryConcept_confidence = P.maybe (summaryConcept_confidence default_SummaryConcept) (\(_,_val23) -> P.Just (case _val23 of {T.TDouble _val26 -> _val26; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  summaryConcept_utility = P.maybe (summaryConcept_utility default_SummaryConcept) (\(_,_val23) -> P.Just (case _val23 of {T.TDouble _val27 -> _val27; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SummaryConcept _ = P.error "not a struct"
read_SummaryConcept :: (T.Transport t, T.Protocol p) => p t -> P.IO SummaryConcept
read_SummaryConcept iprot = to_SummaryConcept <$> T.readVal iprot (T.T_STRUCT typemap_SummaryConcept)
decode_SummaryConcept :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SummaryConcept
decode_SummaryConcept iprot bs = to_SummaryConcept $ T.deserializeVal iprot (T.T_STRUCT typemap_SummaryConcept) bs
typemap_SummaryConcept :: T.TypeMap
typemap_SummaryConcept = Map.fromList [(1,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(2,("concept",T.T_STRING)),(3,("confidence",T.T_DOUBLE)),(4,("utility",T.T_DOUBLE))]
default_SummaryConcept :: SummaryConcept
default_SummaryConcept = SummaryConcept{
  summaryConcept_tokens = P.Nothing,
  summaryConcept_concept = P.Nothing,
  summaryConcept_confidence = P.Just (1),
  summaryConcept_utility = P.Just (1)}
data Summary = Summary  { summary_summaryCommunication :: P.Maybe Communication_Types.Communication
  , summary_concepts :: P.Maybe (Vector.Vector SummaryConcept)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Summary where
  hashWithSalt salt record = salt   `H.hashWithSalt` summary_summaryCommunication record   `H.hashWithSalt` summary_concepts record  
instance QC.Arbitrary Summary where 
  arbitrary = M.liftM Summary (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Summary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Summary{summary_summaryCommunication = summary_summaryCommunication obj} then P.Nothing else P.Just $ default_Summary{summary_summaryCommunication = summary_summaryCommunication obj}
    , if obj == default_Summary{summary_concepts = summary_concepts obj} then P.Nothing else P.Just $ default_Summary{summary_concepts = summary_concepts obj}
    ]
from_Summary :: Summary -> T.ThriftVal
from_Summary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v30 -> (1, ("summaryCommunication",Communication_Types.from_Communication _v30))) <$> summary_summaryCommunication record
  , (\_v30 -> (2, ("concepts",T.TList (T.T_STRUCT typemap_SummaryConcept) $ P.map (\_v32 -> from_SummaryConcept _v32) $ Vector.toList _v30))) <$> summary_concepts record
  ]
write_Summary :: (T.Protocol p, T.Transport t) => p t -> Summary -> P.IO ()
write_Summary oprot record = T.writeVal oprot $ from_Summary record
encode_Summary :: (T.Protocol p, T.Transport t) => p t -> Summary -> LBS.ByteString
encode_Summary oprot record = T.serializeVal oprot $ from_Summary record
to_Summary :: T.ThriftVal -> Summary
to_Summary (T.TStruct fields) = Summary{
  summary_summaryCommunication = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TStruct _val35 -> (Communication_Types.to_Communication (T.TStruct _val35)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  summary_concepts = P.maybe (P.Nothing) (\(_,_val34) -> P.Just (case _val34 of {T.TList _ _val36 -> (Vector.fromList $ P.map (\_v37 -> (case _v37 of {T.TStruct _val38 -> (to_SummaryConcept (T.TStruct _val38)); _ -> P.error "wrong type"})) _val36); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Summary _ = P.error "not a struct"
read_Summary :: (T.Transport t, T.Protocol p) => p t -> P.IO Summary
read_Summary iprot = to_Summary <$> T.readVal iprot (T.T_STRUCT typemap_Summary)
decode_Summary :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Summary
decode_Summary iprot bs = to_Summary $ T.deserializeVal iprot (T.T_STRUCT typemap_Summary) bs
typemap_Summary :: T.TypeMap
typemap_Summary = Map.fromList [(1,("summaryCommunication",(T.T_STRUCT Communication_Types.typemap_Communication))),(2,("concepts",(T.T_LIST (T.T_STRUCT typemap_SummaryConcept))))]
default_Summary :: Summary
default_Summary = Summary{
  summary_summaryCommunication = P.Nothing,
  summary_concepts = P.Nothing}
data SummarizationCapability = SummarizationCapability  { summarizationCapability_type :: SummarySourceType
  , summarizationCapability_lang :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SummarizationCapability where
  hashWithSalt salt record = salt   `H.hashWithSalt` summarizationCapability_type record   `H.hashWithSalt` summarizationCapability_lang record  
instance QC.Arbitrary SummarizationCapability where 
  arbitrary = M.liftM SummarizationCapability (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SummarizationCapability = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SummarizationCapability{summarizationCapability_type = summarizationCapability_type obj} then P.Nothing else P.Just $ default_SummarizationCapability{summarizationCapability_type = summarizationCapability_type obj}
    , if obj == default_SummarizationCapability{summarizationCapability_lang = summarizationCapability_lang obj} then P.Nothing else P.Just $ default_SummarizationCapability{summarizationCapability_lang = summarizationCapability_lang obj}
    ]
from_SummarizationCapability :: SummarizationCapability -> T.ThriftVal
from_SummarizationCapability record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v41 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v41))) $ summarizationCapability_type record
  , (\_v41 -> P.Just (2, ("lang",T.TString $ E.encodeUtf8 _v41))) $ summarizationCapability_lang record
  ]
write_SummarizationCapability :: (T.Protocol p, T.Transport t) => p t -> SummarizationCapability -> P.IO ()
write_SummarizationCapability oprot record = T.writeVal oprot $ from_SummarizationCapability record
encode_SummarizationCapability :: (T.Protocol p, T.Transport t) => p t -> SummarizationCapability -> LBS.ByteString
encode_SummarizationCapability oprot record = T.serializeVal oprot $ from_SummarizationCapability record
to_SummarizationCapability :: T.ThriftVal -> SummarizationCapability
to_SummarizationCapability (T.TStruct fields) = SummarizationCapability{
  summarizationCapability_type = P.maybe (P.error "Missing required field: type") (\(_,_val43) -> (case _val43 of {T.TI32 _val44 -> P.toEnum $ P.fromIntegral _val44; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  summarizationCapability_lang = P.maybe (P.error "Missing required field: lang") (\(_,_val43) -> (case _val43 of {T.TString _val45 -> E.decodeUtf8 _val45; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SummarizationCapability _ = P.error "not a struct"
read_SummarizationCapability :: (T.Transport t, T.Protocol p) => p t -> P.IO SummarizationCapability
read_SummarizationCapability iprot = to_SummarizationCapability <$> T.readVal iprot (T.T_STRUCT typemap_SummarizationCapability)
decode_SummarizationCapability :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SummarizationCapability
decode_SummarizationCapability iprot bs = to_SummarizationCapability $ T.deserializeVal iprot (T.T_STRUCT typemap_SummarizationCapability) bs
typemap_SummarizationCapability :: T.TypeMap
typemap_SummarizationCapability = Map.fromList [(1,("type",T.T_I32)),(2,("lang",T.T_STRING))]
default_SummarizationCapability :: SummarizationCapability
default_SummarizationCapability = SummarizationCapability{
  summarizationCapability_type = (P.toEnum 0),
  summarizationCapability_lang = ""}
