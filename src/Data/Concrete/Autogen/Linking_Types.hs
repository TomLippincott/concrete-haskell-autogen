{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Linking_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Metadata_Types as Metadata_Types


data LinkTarget = LinkTarget  { linkTarget_confidence :: P.Maybe P.Double
  , linkTarget_targetId :: P.Maybe Uuid_Types.UUID
  , linkTarget_dbId :: P.Maybe LT.Text
  , linkTarget_dbName :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LinkTarget where
  hashWithSalt salt record = salt   `H.hashWithSalt` linkTarget_confidence record   `H.hashWithSalt` linkTarget_targetId record   `H.hashWithSalt` linkTarget_dbId record   `H.hashWithSalt` linkTarget_dbName record  
instance QC.Arbitrary LinkTarget where 
  arbitrary = M.liftM LinkTarget (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LinkTarget = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LinkTarget{linkTarget_confidence = linkTarget_confidence obj} then P.Nothing else P.Just $ default_LinkTarget{linkTarget_confidence = linkTarget_confidence obj}
    , if obj == default_LinkTarget{linkTarget_targetId = linkTarget_targetId obj} then P.Nothing else P.Just $ default_LinkTarget{linkTarget_targetId = linkTarget_targetId obj}
    , if obj == default_LinkTarget{linkTarget_dbId = linkTarget_dbId obj} then P.Nothing else P.Just $ default_LinkTarget{linkTarget_dbId = linkTarget_dbId obj}
    , if obj == default_LinkTarget{linkTarget_dbName = linkTarget_dbName obj} then P.Nothing else P.Just $ default_LinkTarget{linkTarget_dbName = linkTarget_dbName obj}
    ]
from_LinkTarget :: LinkTarget -> T.ThriftVal
from_LinkTarget record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("confidence",T.TDouble _v2))) <$> linkTarget_confidence record
  , (\_v2 -> (2, ("targetId",Uuid_Types.from_UUID _v2))) <$> linkTarget_targetId record
  , (\_v2 -> (3, ("dbId",T.TString $ E.encodeUtf8 _v2))) <$> linkTarget_dbId record
  , (\_v2 -> (4, ("dbName",T.TString $ E.encodeUtf8 _v2))) <$> linkTarget_dbName record
  ]
write_LinkTarget :: (T.Protocol p, T.Transport t) => p t -> LinkTarget -> P.IO ()
write_LinkTarget oprot record = T.writeVal oprot $ from_LinkTarget record
encode_LinkTarget :: (T.Protocol p, T.Transport t) => p t -> LinkTarget -> LBS.ByteString
encode_LinkTarget oprot record = T.serializeVal oprot $ from_LinkTarget record
to_LinkTarget :: T.ThriftVal -> LinkTarget
to_LinkTarget (T.TStruct fields) = LinkTarget{
  linkTarget_confidence = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TDouble _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  linkTarget_targetId = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TStruct _val6 -> (Uuid_Types.to_UUID (T.TStruct _val6)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  linkTarget_dbId = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val7 -> E.decodeUtf8 _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  linkTarget_dbName = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val8 -> E.decodeUtf8 _val8; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_LinkTarget _ = P.error "not a struct"
read_LinkTarget :: (T.Transport t, T.Protocol p) => p t -> P.IO LinkTarget
read_LinkTarget iprot = to_LinkTarget <$> T.readVal iprot (T.T_STRUCT typemap_LinkTarget)
decode_LinkTarget :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> LinkTarget
decode_LinkTarget iprot bs = to_LinkTarget $ T.deserializeVal iprot (T.T_STRUCT typemap_LinkTarget) bs
typemap_LinkTarget :: T.TypeMap
typemap_LinkTarget = Map.fromList [(1,("confidence",T.T_DOUBLE)),(2,("targetId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("dbId",T.T_STRING)),(4,("dbName",T.T_STRING))]
default_LinkTarget :: LinkTarget
default_LinkTarget = LinkTarget{
  linkTarget_confidence = P.Nothing,
  linkTarget_targetId = P.Nothing,
  linkTarget_dbId = P.Nothing,
  linkTarget_dbName = P.Nothing}
data Link = Link  { link_sourceId :: Uuid_Types.UUID
  , link_linkTargetList :: (Vector.Vector LinkTarget)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Link where
  hashWithSalt salt record = salt   `H.hashWithSalt` link_sourceId record   `H.hashWithSalt` link_linkTargetList record  
instance QC.Arbitrary Link where 
  arbitrary = M.liftM Link (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Link = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Link{link_sourceId = link_sourceId obj} then P.Nothing else P.Just $ default_Link{link_sourceId = link_sourceId obj}
    , if obj == default_Link{link_linkTargetList = link_linkTargetList obj} then P.Nothing else P.Just $ default_Link{link_linkTargetList = link_linkTargetList obj}
    ]
from_Link :: Link -> T.ThriftVal
from_Link record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11 -> P.Just (1, ("sourceId",Uuid_Types.from_UUID _v11))) $ link_sourceId record
  , (\_v11 -> P.Just (2, ("linkTargetList",T.TList (T.T_STRUCT typemap_LinkTarget) $ P.map (\_v13 -> from_LinkTarget _v13) $ Vector.toList _v11))) $ link_linkTargetList record
  ]
write_Link :: (T.Protocol p, T.Transport t) => p t -> Link -> P.IO ()
write_Link oprot record = T.writeVal oprot $ from_Link record
encode_Link :: (T.Protocol p, T.Transport t) => p t -> Link -> LBS.ByteString
encode_Link oprot record = T.serializeVal oprot $ from_Link record
to_Link :: T.ThriftVal -> Link
to_Link (T.TStruct fields) = Link{
  link_sourceId = P.maybe (P.error "Missing required field: sourceId") (\(_,_val15) -> (case _val15 of {T.TStruct _val16 -> (Uuid_Types.to_UUID (T.TStruct _val16)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  link_linkTargetList = P.maybe (P.error "Missing required field: linkTargetList") (\(_,_val15) -> (case _val15 of {T.TList _ _val17 -> (Vector.fromList $ P.map (\_v18 -> (case _v18 of {T.TStruct _val19 -> (to_LinkTarget (T.TStruct _val19)); _ -> P.error "wrong type"})) _val17); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Link _ = P.error "not a struct"
read_Link :: (T.Transport t, T.Protocol p) => p t -> P.IO Link
read_Link iprot = to_Link <$> T.readVal iprot (T.T_STRUCT typemap_Link)
decode_Link :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Link
decode_Link iprot bs = to_Link $ T.deserializeVal iprot (T.T_STRUCT typemap_Link) bs
typemap_Link :: T.TypeMap
typemap_Link = Map.fromList [(1,("sourceId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("linkTargetList",(T.T_LIST (T.T_STRUCT typemap_LinkTarget))))]
default_Link :: Link
default_Link = Link{
  link_sourceId = Uuid_Types.default_UUID,
  link_linkTargetList = Vector.empty}
data Linking = Linking  { linking_metadata :: Metadata_Types.AnnotationMetadata
  , linking_linkList :: (Vector.Vector Link)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Linking where
  hashWithSalt salt record = salt   `H.hashWithSalt` linking_metadata record   `H.hashWithSalt` linking_linkList record  
instance QC.Arbitrary Linking where 
  arbitrary = M.liftM Linking (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Linking = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Linking{linking_metadata = linking_metadata obj} then P.Nothing else P.Just $ default_Linking{linking_metadata = linking_metadata obj}
    , if obj == default_Linking{linking_linkList = linking_linkList obj} then P.Nothing else P.Just $ default_Linking{linking_linkList = linking_linkList obj}
    ]
from_Linking :: Linking -> T.ThriftVal
from_Linking record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v22 -> P.Just (1, ("metadata",Metadata_Types.from_AnnotationMetadata _v22))) $ linking_metadata record
  , (\_v22 -> P.Just (2, ("linkList",T.TList (T.T_STRUCT typemap_Link) $ P.map (\_v24 -> from_Link _v24) $ Vector.toList _v22))) $ linking_linkList record
  ]
write_Linking :: (T.Protocol p, T.Transport t) => p t -> Linking -> P.IO ()
write_Linking oprot record = T.writeVal oprot $ from_Linking record
encode_Linking :: (T.Protocol p, T.Transport t) => p t -> Linking -> LBS.ByteString
encode_Linking oprot record = T.serializeVal oprot $ from_Linking record
to_Linking :: T.ThriftVal -> Linking
to_Linking (T.TStruct fields) = Linking{
  linking_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val26) -> (case _val26 of {T.TStruct _val27 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val27)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  linking_linkList = P.maybe (P.error "Missing required field: linkList") (\(_,_val26) -> (case _val26 of {T.TList _ _val28 -> (Vector.fromList $ P.map (\_v29 -> (case _v29 of {T.TStruct _val30 -> (to_Link (T.TStruct _val30)); _ -> P.error "wrong type"})) _val28); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Linking _ = P.error "not a struct"
read_Linking :: (T.Transport t, T.Protocol p) => p t -> P.IO Linking
read_Linking iprot = to_Linking <$> T.readVal iprot (T.T_STRUCT typemap_Linking)
decode_Linking :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Linking
decode_Linking iprot bs = to_Linking $ T.deserializeVal iprot (T.T_STRUCT typemap_Linking) bs
typemap_Linking :: T.TypeMap
typemap_Linking = Map.fromList [(1,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(2,("linkList",(T.T_LIST (T.T_STRUCT typemap_Link))))]
default_Linking :: Linking
default_Linking = Linking{
  linking_metadata = Metadata_Types.default_AnnotationMetadata,
  linking_linkList = Vector.empty}
