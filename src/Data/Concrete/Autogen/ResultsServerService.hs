{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.ResultsServerService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Services_Types as Services_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Search_Types as Search_Types
import Data.Concrete.Autogen.Communication_Types as Communication_Types


import qualified Data.Concrete.Autogen.Service as Service
import Data.Concrete.Autogen.Results_Types as Results_Types
import qualified Data.Concrete.Autogen.ResultsServerService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data RegisterSearchResult_args = RegisterSearchResult_args  { registerSearchResult_args_result :: Search_Types.SearchResult
  , registerSearchResult_args_taskType :: Services_Types.AnnotationTaskType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterSearchResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerSearchResult_args_result record   `H.hashWithSalt` registerSearchResult_args_taskType record  
instance QC.Arbitrary RegisterSearchResult_args where 
  arbitrary = M.liftM RegisterSearchResult_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterSearchResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterSearchResult_args{registerSearchResult_args_result = registerSearchResult_args_result obj} then P.Nothing else P.Just $ default_RegisterSearchResult_args{registerSearchResult_args_result = registerSearchResult_args_result obj}
    , if obj == default_RegisterSearchResult_args{registerSearchResult_args_taskType = registerSearchResult_args_taskType obj} then P.Nothing else P.Just $ default_RegisterSearchResult_args{registerSearchResult_args_taskType = registerSearchResult_args_taskType obj}
    ]
from_RegisterSearchResult_args :: RegisterSearchResult_args -> T.ThriftVal
from_RegisterSearchResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("result",Search_Types.from_SearchResult _v2))) $ registerSearchResult_args_result record
  , (\_v2 -> P.Just (2, ("taskType",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ registerSearchResult_args_taskType record
  ]
write_RegisterSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> RegisterSearchResult_args -> P.IO ()
write_RegisterSearchResult_args oprot record = T.writeVal oprot $ from_RegisterSearchResult_args record
encode_RegisterSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> RegisterSearchResult_args -> LBS.ByteString
encode_RegisterSearchResult_args oprot record = T.serializeVal oprot $ from_RegisterSearchResult_args record
to_RegisterSearchResult_args :: T.ThriftVal -> RegisterSearchResult_args
to_RegisterSearchResult_args (T.TStruct fields) = RegisterSearchResult_args{
  registerSearchResult_args_result = P.maybe (registerSearchResult_args_result default_RegisterSearchResult_args) (\(_,_val4) -> (case _val4 of {T.TStruct _val5 -> (Search_Types.to_SearchResult (T.TStruct _val5)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerSearchResult_args_taskType = P.maybe (registerSearchResult_args_taskType default_RegisterSearchResult_args) (\(_,_val4) -> (case _val4 of {T.TI32 _val6 -> P.toEnum $ P.fromIntegral _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterSearchResult_args _ = P.error "not a struct"
read_RegisterSearchResult_args :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterSearchResult_args
read_RegisterSearchResult_args iprot = to_RegisterSearchResult_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterSearchResult_args)
decode_RegisterSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterSearchResult_args
decode_RegisterSearchResult_args iprot bs = to_RegisterSearchResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterSearchResult_args) bs
typemap_RegisterSearchResult_args :: T.TypeMap
typemap_RegisterSearchResult_args = Map.fromList [(1,("result",(T.T_STRUCT Search_Types.typemap_SearchResult))),(2,("taskType",T.T_I32))]
default_RegisterSearchResult_args :: RegisterSearchResult_args
default_RegisterSearchResult_args = RegisterSearchResult_args{
  registerSearchResult_args_result = Search_Types.default_SearchResult,
  registerSearchResult_args_taskType = (P.toEnum 0)}
data RegisterSearchResult_result = RegisterSearchResult_result  { registerSearchResult_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterSearchResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerSearchResult_result_ex record  
instance QC.Arbitrary RegisterSearchResult_result where 
  arbitrary = M.liftM RegisterSearchResult_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterSearchResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterSearchResult_result{registerSearchResult_result_ex = registerSearchResult_result_ex obj} then P.Nothing else P.Just $ default_RegisterSearchResult_result{registerSearchResult_result_ex = registerSearchResult_result_ex obj}
    ]
from_RegisterSearchResult_result :: RegisterSearchResult_result -> T.ThriftVal
from_RegisterSearchResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9 -> (1, ("ex",Services_Types.from_ServicesException _v9))) <$> registerSearchResult_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9 -> (1, ("ex",Services_Types.from_ServicesException _v9))) <$> registerSearchResult_result_ex record
    ]
    )
write_RegisterSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> RegisterSearchResult_result -> P.IO ()
write_RegisterSearchResult_result oprot record = T.writeVal oprot $ from_RegisterSearchResult_result record
encode_RegisterSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> RegisterSearchResult_result -> LBS.ByteString
encode_RegisterSearchResult_result oprot record = T.serializeVal oprot $ from_RegisterSearchResult_result record
to_RegisterSearchResult_result :: T.ThriftVal -> RegisterSearchResult_result
to_RegisterSearchResult_result (T.TStruct fields) = RegisterSearchResult_result{
  registerSearchResult_result_ex = P.maybe (P.Nothing) (\(_,_val11) -> P.Just (case _val11 of {T.TStruct _val12 -> (Services_Types.to_ServicesException (T.TStruct _val12)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterSearchResult_result _ = P.error "not a struct"
read_RegisterSearchResult_result :: (T.Transport t, T.Protocol p) => p t -> P.IO RegisterSearchResult_result
read_RegisterSearchResult_result iprot = to_RegisterSearchResult_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterSearchResult_result)
decode_RegisterSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> RegisterSearchResult_result
decode_RegisterSearchResult_result iprot bs = to_RegisterSearchResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterSearchResult_result) bs
typemap_RegisterSearchResult_result :: T.TypeMap
typemap_RegisterSearchResult_result = Map.fromList [(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_RegisterSearchResult_result :: RegisterSearchResult_result
default_RegisterSearchResult_result = RegisterSearchResult_result{
  registerSearchResult_result_ex = P.Nothing}
data GetSearchResults_args = GetSearchResults_args  { getSearchResults_args_taskType :: Services_Types.AnnotationTaskType
  , getSearchResults_args_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResults_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResults_args_taskType record   `H.hashWithSalt` getSearchResults_args_limit record  
instance QC.Arbitrary GetSearchResults_args where 
  arbitrary = M.liftM GetSearchResults_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSearchResults_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResults_args{getSearchResults_args_taskType = getSearchResults_args_taskType obj} then P.Nothing else P.Just $ default_GetSearchResults_args{getSearchResults_args_taskType = getSearchResults_args_taskType obj}
    , if obj == default_GetSearchResults_args{getSearchResults_args_limit = getSearchResults_args_limit obj} then P.Nothing else P.Just $ default_GetSearchResults_args{getSearchResults_args_limit = getSearchResults_args_limit obj}
    ]
from_GetSearchResults_args :: GetSearchResults_args -> T.ThriftVal
from_GetSearchResults_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v15 -> P.Just (1, ("taskType",T.TI32 $ P.fromIntegral $ P.fromEnum _v15))) $ getSearchResults_args_taskType record
  , (\_v15 -> P.Just (2, ("limit",T.TI32 _v15))) $ getSearchResults_args_limit record
  ]
write_GetSearchResults_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResults_args -> P.IO ()
write_GetSearchResults_args oprot record = T.writeVal oprot $ from_GetSearchResults_args record
encode_GetSearchResults_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResults_args -> LBS.ByteString
encode_GetSearchResults_args oprot record = T.serializeVal oprot $ from_GetSearchResults_args record
to_GetSearchResults_args :: T.ThriftVal -> GetSearchResults_args
to_GetSearchResults_args (T.TStruct fields) = GetSearchResults_args{
  getSearchResults_args_taskType = P.maybe (getSearchResults_args_taskType default_GetSearchResults_args) (\(_,_val17) -> (case _val17 of {T.TI32 _val18 -> P.toEnum $ P.fromIntegral _val18; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSearchResults_args_limit = P.maybe (getSearchResults_args_limit default_GetSearchResults_args) (\(_,_val17) -> (case _val17 of {T.TI32 _val19 -> _val19; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSearchResults_args _ = P.error "not a struct"
read_GetSearchResults_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResults_args
read_GetSearchResults_args iprot = to_GetSearchResults_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResults_args)
decode_GetSearchResults_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResults_args
decode_GetSearchResults_args iprot bs = to_GetSearchResults_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResults_args) bs
typemap_GetSearchResults_args :: T.TypeMap
typemap_GetSearchResults_args = Map.fromList [(1,("taskType",T.T_I32)),(2,("limit",T.T_I32))]
default_GetSearchResults_args :: GetSearchResults_args
default_GetSearchResults_args = GetSearchResults_args{
  getSearchResults_args_taskType = (P.toEnum 0),
  getSearchResults_args_limit = 0}
data GetSearchResults_result = GetSearchResults_result  { getSearchResults_result_success :: (Vector.Vector Search_Types.SearchResult)
  , getSearchResults_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResults_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResults_result_success record   `H.hashWithSalt` getSearchResults_result_ex record  
instance QC.Arbitrary GetSearchResults_result where 
  arbitrary = M.liftM GetSearchResults_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSearchResults_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResults_result{getSearchResults_result_success = getSearchResults_result_success obj} then P.Nothing else P.Just $ default_GetSearchResults_result{getSearchResults_result_success = getSearchResults_result_success obj}
    , if obj == default_GetSearchResults_result{getSearchResults_result_ex = getSearchResults_result_ex obj} then P.Nothing else P.Just $ default_GetSearchResults_result{getSearchResults_result_ex = getSearchResults_result_ex obj}
    ]
from_GetSearchResults_result :: GetSearchResults_result -> T.ThriftVal
from_GetSearchResults_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v22 -> (1, ("ex",Services_Types.from_ServicesException _v22))) <$> getSearchResults_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v22 -> P.Just (0, ("success",T.TList (T.T_STRUCT Search_Types.typemap_SearchResult) $ P.map (\_v24 -> Search_Types.from_SearchResult _v24) $ Vector.toList _v22))) $ getSearchResults_result_success record
    , (\_v22 -> (1, ("ex",Services_Types.from_ServicesException _v22))) <$> getSearchResults_result_ex record
    ]
    )
write_GetSearchResults_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResults_result -> P.IO ()
write_GetSearchResults_result oprot record = T.writeVal oprot $ from_GetSearchResults_result record
encode_GetSearchResults_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResults_result -> LBS.ByteString
encode_GetSearchResults_result oprot record = T.serializeVal oprot $ from_GetSearchResults_result record
to_GetSearchResults_result :: T.ThriftVal -> GetSearchResults_result
to_GetSearchResults_result (T.TStruct fields) = GetSearchResults_result{
  getSearchResults_result_success = P.maybe (getSearchResults_result_success default_GetSearchResults_result) (\(_,_val26) -> (case _val26 of {T.TList _ _val27 -> (Vector.fromList $ P.map (\_v28 -> (case _v28 of {T.TStruct _val29 -> (Search_Types.to_SearchResult (T.TStruct _val29)); _ -> P.error "wrong type"})) _val27); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSearchResults_result_ex = P.maybe (P.Nothing) (\(_,_val26) -> P.Just (case _val26 of {T.TStruct _val30 -> (Services_Types.to_ServicesException (T.TStruct _val30)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSearchResults_result _ = P.error "not a struct"
read_GetSearchResults_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResults_result
read_GetSearchResults_result iprot = to_GetSearchResults_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResults_result)
decode_GetSearchResults_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResults_result
decode_GetSearchResults_result iprot bs = to_GetSearchResults_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResults_result) bs
typemap_GetSearchResults_result :: T.TypeMap
typemap_GetSearchResults_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Search_Types.typemap_SearchResult)))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_GetSearchResults_result :: GetSearchResults_result
default_GetSearchResults_result = GetSearchResults_result{
  getSearchResults_result_success = Vector.empty,
  getSearchResults_result_ex = P.Nothing}
data GetSearchResultsByUser_args = GetSearchResultsByUser_args  { getSearchResultsByUser_args_taskType :: Services_Types.AnnotationTaskType
  , getSearchResultsByUser_args_userId :: LT.Text
  , getSearchResultsByUser_args_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResultsByUser_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResultsByUser_args_taskType record   `H.hashWithSalt` getSearchResultsByUser_args_userId record   `H.hashWithSalt` getSearchResultsByUser_args_limit record  
instance QC.Arbitrary GetSearchResultsByUser_args where 
  arbitrary = M.liftM GetSearchResultsByUser_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSearchResultsByUser_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResultsByUser_args{getSearchResultsByUser_args_taskType = getSearchResultsByUser_args_taskType obj} then P.Nothing else P.Just $ default_GetSearchResultsByUser_args{getSearchResultsByUser_args_taskType = getSearchResultsByUser_args_taskType obj}
    , if obj == default_GetSearchResultsByUser_args{getSearchResultsByUser_args_userId = getSearchResultsByUser_args_userId obj} then P.Nothing else P.Just $ default_GetSearchResultsByUser_args{getSearchResultsByUser_args_userId = getSearchResultsByUser_args_userId obj}
    , if obj == default_GetSearchResultsByUser_args{getSearchResultsByUser_args_limit = getSearchResultsByUser_args_limit obj} then P.Nothing else P.Just $ default_GetSearchResultsByUser_args{getSearchResultsByUser_args_limit = getSearchResultsByUser_args_limit obj}
    ]
from_GetSearchResultsByUser_args :: GetSearchResultsByUser_args -> T.ThriftVal
from_GetSearchResultsByUser_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v33 -> P.Just (1, ("taskType",T.TI32 $ P.fromIntegral $ P.fromEnum _v33))) $ getSearchResultsByUser_args_taskType record
  , (\_v33 -> P.Just (2, ("userId",T.TString $ E.encodeUtf8 _v33))) $ getSearchResultsByUser_args_userId record
  , (\_v33 -> P.Just (3, ("limit",T.TI32 _v33))) $ getSearchResultsByUser_args_limit record
  ]
write_GetSearchResultsByUser_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResultsByUser_args -> P.IO ()
write_GetSearchResultsByUser_args oprot record = T.writeVal oprot $ from_GetSearchResultsByUser_args record
encode_GetSearchResultsByUser_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResultsByUser_args -> LBS.ByteString
encode_GetSearchResultsByUser_args oprot record = T.serializeVal oprot $ from_GetSearchResultsByUser_args record
to_GetSearchResultsByUser_args :: T.ThriftVal -> GetSearchResultsByUser_args
to_GetSearchResultsByUser_args (T.TStruct fields) = GetSearchResultsByUser_args{
  getSearchResultsByUser_args_taskType = P.maybe (getSearchResultsByUser_args_taskType default_GetSearchResultsByUser_args) (\(_,_val35) -> (case _val35 of {T.TI32 _val36 -> P.toEnum $ P.fromIntegral _val36; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSearchResultsByUser_args_userId = P.maybe (getSearchResultsByUser_args_userId default_GetSearchResultsByUser_args) (\(_,_val35) -> (case _val35 of {T.TString _val37 -> E.decodeUtf8 _val37; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSearchResultsByUser_args_limit = P.maybe (getSearchResultsByUser_args_limit default_GetSearchResultsByUser_args) (\(_,_val35) -> (case _val35 of {T.TI32 _val38 -> _val38; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSearchResultsByUser_args _ = P.error "not a struct"
read_GetSearchResultsByUser_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResultsByUser_args
read_GetSearchResultsByUser_args iprot = to_GetSearchResultsByUser_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResultsByUser_args)
decode_GetSearchResultsByUser_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResultsByUser_args
decode_GetSearchResultsByUser_args iprot bs = to_GetSearchResultsByUser_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResultsByUser_args) bs
typemap_GetSearchResultsByUser_args :: T.TypeMap
typemap_GetSearchResultsByUser_args = Map.fromList [(1,("taskType",T.T_I32)),(2,("userId",T.T_STRING)),(3,("limit",T.T_I32))]
default_GetSearchResultsByUser_args :: GetSearchResultsByUser_args
default_GetSearchResultsByUser_args = GetSearchResultsByUser_args{
  getSearchResultsByUser_args_taskType = (P.toEnum 0),
  getSearchResultsByUser_args_userId = "",
  getSearchResultsByUser_args_limit = 0}
data GetSearchResultsByUser_result = GetSearchResultsByUser_result  { getSearchResultsByUser_result_success :: (Vector.Vector Search_Types.SearchResult)
  , getSearchResultsByUser_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResultsByUser_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResultsByUser_result_success record   `H.hashWithSalt` getSearchResultsByUser_result_ex record  
instance QC.Arbitrary GetSearchResultsByUser_result where 
  arbitrary = M.liftM GetSearchResultsByUser_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSearchResultsByUser_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResultsByUser_result{getSearchResultsByUser_result_success = getSearchResultsByUser_result_success obj} then P.Nothing else P.Just $ default_GetSearchResultsByUser_result{getSearchResultsByUser_result_success = getSearchResultsByUser_result_success obj}
    , if obj == default_GetSearchResultsByUser_result{getSearchResultsByUser_result_ex = getSearchResultsByUser_result_ex obj} then P.Nothing else P.Just $ default_GetSearchResultsByUser_result{getSearchResultsByUser_result_ex = getSearchResultsByUser_result_ex obj}
    ]
from_GetSearchResultsByUser_result :: GetSearchResultsByUser_result -> T.ThriftVal
from_GetSearchResultsByUser_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v41 -> (1, ("ex",Services_Types.from_ServicesException _v41))) <$> getSearchResultsByUser_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v41 -> P.Just (0, ("success",T.TList (T.T_STRUCT Search_Types.typemap_SearchResult) $ P.map (\_v43 -> Search_Types.from_SearchResult _v43) $ Vector.toList _v41))) $ getSearchResultsByUser_result_success record
    , (\_v41 -> (1, ("ex",Services_Types.from_ServicesException _v41))) <$> getSearchResultsByUser_result_ex record
    ]
    )
write_GetSearchResultsByUser_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResultsByUser_result -> P.IO ()
write_GetSearchResultsByUser_result oprot record = T.writeVal oprot $ from_GetSearchResultsByUser_result record
encode_GetSearchResultsByUser_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResultsByUser_result -> LBS.ByteString
encode_GetSearchResultsByUser_result oprot record = T.serializeVal oprot $ from_GetSearchResultsByUser_result record
to_GetSearchResultsByUser_result :: T.ThriftVal -> GetSearchResultsByUser_result
to_GetSearchResultsByUser_result (T.TStruct fields) = GetSearchResultsByUser_result{
  getSearchResultsByUser_result_success = P.maybe (getSearchResultsByUser_result_success default_GetSearchResultsByUser_result) (\(_,_val45) -> (case _val45 of {T.TList _ _val46 -> (Vector.fromList $ P.map (\_v47 -> (case _v47 of {T.TStruct _val48 -> (Search_Types.to_SearchResult (T.TStruct _val48)); _ -> P.error "wrong type"})) _val46); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSearchResultsByUser_result_ex = P.maybe (P.Nothing) (\(_,_val45) -> P.Just (case _val45 of {T.TStruct _val49 -> (Services_Types.to_ServicesException (T.TStruct _val49)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSearchResultsByUser_result _ = P.error "not a struct"
read_GetSearchResultsByUser_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResultsByUser_result
read_GetSearchResultsByUser_result iprot = to_GetSearchResultsByUser_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResultsByUser_result)
decode_GetSearchResultsByUser_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResultsByUser_result
decode_GetSearchResultsByUser_result iprot bs = to_GetSearchResultsByUser_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResultsByUser_result) bs
typemap_GetSearchResultsByUser_result :: T.TypeMap
typemap_GetSearchResultsByUser_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Search_Types.typemap_SearchResult)))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_GetSearchResultsByUser_result :: GetSearchResultsByUser_result
default_GetSearchResultsByUser_result = GetSearchResultsByUser_result{
  getSearchResultsByUser_result_success = Vector.empty,
  getSearchResultsByUser_result_ex = P.Nothing}
data GetLatestSearchResult_args = GetLatestSearchResult_args  { getLatestSearchResult_args_userId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLatestSearchResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLatestSearchResult_args_userId record  
instance QC.Arbitrary GetLatestSearchResult_args where 
  arbitrary = M.liftM GetLatestSearchResult_args (QC.arbitrary)
  shrink obj | obj == default_GetLatestSearchResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLatestSearchResult_args{getLatestSearchResult_args_userId = getLatestSearchResult_args_userId obj} then P.Nothing else P.Just $ default_GetLatestSearchResult_args{getLatestSearchResult_args_userId = getLatestSearchResult_args_userId obj}
    ]
from_GetLatestSearchResult_args :: GetLatestSearchResult_args -> T.ThriftVal
from_GetLatestSearchResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v52 -> P.Just (1, ("userId",T.TString $ E.encodeUtf8 _v52))) $ getLatestSearchResult_args_userId record
  ]
write_GetLatestSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> GetLatestSearchResult_args -> P.IO ()
write_GetLatestSearchResult_args oprot record = T.writeVal oprot $ from_GetLatestSearchResult_args record
encode_GetLatestSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> GetLatestSearchResult_args -> LBS.ByteString
encode_GetLatestSearchResult_args oprot record = T.serializeVal oprot $ from_GetLatestSearchResult_args record
to_GetLatestSearchResult_args :: T.ThriftVal -> GetLatestSearchResult_args
to_GetLatestSearchResult_args (T.TStruct fields) = GetLatestSearchResult_args{
  getLatestSearchResult_args_userId = P.maybe (getLatestSearchResult_args_userId default_GetLatestSearchResult_args) (\(_,_val54) -> (case _val54 of {T.TString _val55 -> E.decodeUtf8 _val55; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLatestSearchResult_args _ = P.error "not a struct"
read_GetLatestSearchResult_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetLatestSearchResult_args
read_GetLatestSearchResult_args iprot = to_GetLatestSearchResult_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLatestSearchResult_args)
decode_GetLatestSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetLatestSearchResult_args
decode_GetLatestSearchResult_args iprot bs = to_GetLatestSearchResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLatestSearchResult_args) bs
typemap_GetLatestSearchResult_args :: T.TypeMap
typemap_GetLatestSearchResult_args = Map.fromList [(1,("userId",T.T_STRING))]
default_GetLatestSearchResult_args :: GetLatestSearchResult_args
default_GetLatestSearchResult_args = GetLatestSearchResult_args{
  getLatestSearchResult_args_userId = ""}
data GetLatestSearchResult_result = GetLatestSearchResult_result  { getLatestSearchResult_result_success :: Search_Types.SearchResult
  , getLatestSearchResult_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLatestSearchResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLatestSearchResult_result_success record   `H.hashWithSalt` getLatestSearchResult_result_ex record  
instance QC.Arbitrary GetLatestSearchResult_result where 
  arbitrary = M.liftM GetLatestSearchResult_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLatestSearchResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLatestSearchResult_result{getLatestSearchResult_result_success = getLatestSearchResult_result_success obj} then P.Nothing else P.Just $ default_GetLatestSearchResult_result{getLatestSearchResult_result_success = getLatestSearchResult_result_success obj}
    , if obj == default_GetLatestSearchResult_result{getLatestSearchResult_result_ex = getLatestSearchResult_result_ex obj} then P.Nothing else P.Just $ default_GetLatestSearchResult_result{getLatestSearchResult_result_ex = getLatestSearchResult_result_ex obj}
    ]
from_GetLatestSearchResult_result :: GetLatestSearchResult_result -> T.ThriftVal
from_GetLatestSearchResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v58 -> (1, ("ex",Services_Types.from_ServicesException _v58))) <$> getLatestSearchResult_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v58 -> P.Just (0, ("success",Search_Types.from_SearchResult _v58))) $ getLatestSearchResult_result_success record
    , (\_v58 -> (1, ("ex",Services_Types.from_ServicesException _v58))) <$> getLatestSearchResult_result_ex record
    ]
    )
write_GetLatestSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> GetLatestSearchResult_result -> P.IO ()
write_GetLatestSearchResult_result oprot record = T.writeVal oprot $ from_GetLatestSearchResult_result record
encode_GetLatestSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> GetLatestSearchResult_result -> LBS.ByteString
encode_GetLatestSearchResult_result oprot record = T.serializeVal oprot $ from_GetLatestSearchResult_result record
to_GetLatestSearchResult_result :: T.ThriftVal -> GetLatestSearchResult_result
to_GetLatestSearchResult_result (T.TStruct fields) = GetLatestSearchResult_result{
  getLatestSearchResult_result_success = P.maybe (getLatestSearchResult_result_success default_GetLatestSearchResult_result) (\(_,_val60) -> (case _val60 of {T.TStruct _val61 -> (Search_Types.to_SearchResult (T.TStruct _val61)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLatestSearchResult_result_ex = P.maybe (P.Nothing) (\(_,_val60) -> P.Just (case _val60 of {T.TStruct _val62 -> (Services_Types.to_ServicesException (T.TStruct _val62)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLatestSearchResult_result _ = P.error "not a struct"
read_GetLatestSearchResult_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetLatestSearchResult_result
read_GetLatestSearchResult_result iprot = to_GetLatestSearchResult_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLatestSearchResult_result)
decode_GetLatestSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetLatestSearchResult_result
decode_GetLatestSearchResult_result iprot bs = to_GetLatestSearchResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLatestSearchResult_result) bs
typemap_GetLatestSearchResult_result :: T.TypeMap
typemap_GetLatestSearchResult_result = Map.fromList [(0,("success",(T.T_STRUCT Search_Types.typemap_SearchResult))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_GetLatestSearchResult_result :: GetLatestSearchResult_result
default_GetLatestSearchResult_result = GetLatestSearchResult_result{
  getLatestSearchResult_result_success = Search_Types.default_SearchResult,
  getLatestSearchResult_result_ex = P.Nothing}
data GetSearchResult_args = GetSearchResult_args  { getSearchResult_args_searchResultId :: Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResult_args_searchResultId record  
instance QC.Arbitrary GetSearchResult_args where 
  arbitrary = M.liftM GetSearchResult_args (QC.arbitrary)
  shrink obj | obj == default_GetSearchResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResult_args{getSearchResult_args_searchResultId = getSearchResult_args_searchResultId obj} then P.Nothing else P.Just $ default_GetSearchResult_args{getSearchResult_args_searchResultId = getSearchResult_args_searchResultId obj}
    ]
from_GetSearchResult_args :: GetSearchResult_args -> T.ThriftVal
from_GetSearchResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v65 -> P.Just (1, ("searchResultId",Uuid_Types.from_UUID _v65))) $ getSearchResult_args_searchResultId record
  ]
write_GetSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResult_args -> P.IO ()
write_GetSearchResult_args oprot record = T.writeVal oprot $ from_GetSearchResult_args record
encode_GetSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> GetSearchResult_args -> LBS.ByteString
encode_GetSearchResult_args oprot record = T.serializeVal oprot $ from_GetSearchResult_args record
to_GetSearchResult_args :: T.ThriftVal -> GetSearchResult_args
to_GetSearchResult_args (T.TStruct fields) = GetSearchResult_args{
  getSearchResult_args_searchResultId = P.maybe (getSearchResult_args_searchResultId default_GetSearchResult_args) (\(_,_val67) -> (case _val67 of {T.TStruct _val68 -> (Uuid_Types.to_UUID (T.TStruct _val68)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSearchResult_args _ = P.error "not a struct"
read_GetSearchResult_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResult_args
read_GetSearchResult_args iprot = to_GetSearchResult_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResult_args)
decode_GetSearchResult_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResult_args
decode_GetSearchResult_args iprot bs = to_GetSearchResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResult_args) bs
typemap_GetSearchResult_args :: T.TypeMap
typemap_GetSearchResult_args = Map.fromList [(1,("searchResultId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_GetSearchResult_args :: GetSearchResult_args
default_GetSearchResult_args = GetSearchResult_args{
  getSearchResult_args_searchResultId = Uuid_Types.default_UUID}
data GetSearchResult_result = GetSearchResult_result  { getSearchResult_result_success :: Search_Types.SearchResult
  , getSearchResult_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearchResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearchResult_result_success record   `H.hashWithSalt` getSearchResult_result_ex record  
instance QC.Arbitrary GetSearchResult_result where 
  arbitrary = M.liftM GetSearchResult_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSearchResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearchResult_result{getSearchResult_result_success = getSearchResult_result_success obj} then P.Nothing else P.Just $ default_GetSearchResult_result{getSearchResult_result_success = getSearchResult_result_success obj}
    , if obj == default_GetSearchResult_result{getSearchResult_result_ex = getSearchResult_result_ex obj} then P.Nothing else P.Just $ default_GetSearchResult_result{getSearchResult_result_ex = getSearchResult_result_ex obj}
    ]
from_GetSearchResult_result :: GetSearchResult_result -> T.ThriftVal
from_GetSearchResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v71 -> (1, ("ex",Services_Types.from_ServicesException _v71))) <$> getSearchResult_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v71 -> P.Just (0, ("success",Search_Types.from_SearchResult _v71))) $ getSearchResult_result_success record
    , (\_v71 -> (1, ("ex",Services_Types.from_ServicesException _v71))) <$> getSearchResult_result_ex record
    ]
    )
write_GetSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResult_result -> P.IO ()
write_GetSearchResult_result oprot record = T.writeVal oprot $ from_GetSearchResult_result record
encode_GetSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> GetSearchResult_result -> LBS.ByteString
encode_GetSearchResult_result oprot record = T.serializeVal oprot $ from_GetSearchResult_result record
to_GetSearchResult_result :: T.ThriftVal -> GetSearchResult_result
to_GetSearchResult_result (T.TStruct fields) = GetSearchResult_result{
  getSearchResult_result_success = P.maybe (getSearchResult_result_success default_GetSearchResult_result) (\(_,_val73) -> (case _val73 of {T.TStruct _val74 -> (Search_Types.to_SearchResult (T.TStruct _val74)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSearchResult_result_ex = P.maybe (P.Nothing) (\(_,_val73) -> P.Just (case _val73 of {T.TStruct _val75 -> (Services_Types.to_ServicesException (T.TStruct _val75)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSearchResult_result _ = P.error "not a struct"
read_GetSearchResult_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetSearchResult_result
read_GetSearchResult_result iprot = to_GetSearchResult_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSearchResult_result)
decode_GetSearchResult_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetSearchResult_result
decode_GetSearchResult_result iprot bs = to_GetSearchResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearchResult_result) bs
typemap_GetSearchResult_result :: T.TypeMap
typemap_GetSearchResult_result = Map.fromList [(0,("success",(T.T_STRUCT Search_Types.typemap_SearchResult))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_GetSearchResult_result :: GetSearchResult_result
default_GetSearchResult_result = GetSearchResult_result{
  getSearchResult_result_success = Search_Types.default_SearchResult,
  getSearchResult_result_ex = P.Nothing}
data StartSession_args = StartSession_args  { startSession_args_searchResultId :: Uuid_Types.UUID
  , startSession_args_taskType :: Services_Types.AnnotationTaskType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startSession_args_searchResultId record   `H.hashWithSalt` startSession_args_taskType record  
instance QC.Arbitrary StartSession_args where 
  arbitrary = M.liftM StartSession_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartSession_args{startSession_args_searchResultId = startSession_args_searchResultId obj} then P.Nothing else P.Just $ default_StartSession_args{startSession_args_searchResultId = startSession_args_searchResultId obj}
    , if obj == default_StartSession_args{startSession_args_taskType = startSession_args_taskType obj} then P.Nothing else P.Just $ default_StartSession_args{startSession_args_taskType = startSession_args_taskType obj}
    ]
from_StartSession_args :: StartSession_args -> T.ThriftVal
from_StartSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v78 -> P.Just (1, ("searchResultId",Uuid_Types.from_UUID _v78))) $ startSession_args_searchResultId record
  , (\_v78 -> P.Just (2, ("taskType",T.TI32 $ P.fromIntegral $ P.fromEnum _v78))) $ startSession_args_taskType record
  ]
write_StartSession_args :: (T.Protocol p, T.Transport t) => p t -> StartSession_args -> P.IO ()
write_StartSession_args oprot record = T.writeVal oprot $ from_StartSession_args record
encode_StartSession_args :: (T.Protocol p, T.Transport t) => p t -> StartSession_args -> LBS.ByteString
encode_StartSession_args oprot record = T.serializeVal oprot $ from_StartSession_args record
to_StartSession_args :: T.ThriftVal -> StartSession_args
to_StartSession_args (T.TStruct fields) = StartSession_args{
  startSession_args_searchResultId = P.maybe (startSession_args_searchResultId default_StartSession_args) (\(_,_val80) -> (case _val80 of {T.TStruct _val81 -> (Uuid_Types.to_UUID (T.TStruct _val81)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  startSession_args_taskType = P.maybe (startSession_args_taskType default_StartSession_args) (\(_,_val80) -> (case _val80 of {T.TI32 _val82 -> P.toEnum $ P.fromIntegral _val82; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StartSession_args _ = P.error "not a struct"
read_StartSession_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StartSession_args
read_StartSession_args iprot = to_StartSession_args <$> T.readVal iprot (T.T_STRUCT typemap_StartSession_args)
decode_StartSession_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartSession_args
decode_StartSession_args iprot bs = to_StartSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartSession_args) bs
typemap_StartSession_args :: T.TypeMap
typemap_StartSession_args = Map.fromList [(1,("searchResultId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("taskType",T.T_I32))]
default_StartSession_args :: StartSession_args
default_StartSession_args = StartSession_args{
  startSession_args_searchResultId = Uuid_Types.default_UUID,
  startSession_args_taskType = (P.toEnum 0)}
data StartSession_result = StartSession_result  { startSession_result_success :: Uuid_Types.UUID
  , startSession_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startSession_result_success record   `H.hashWithSalt` startSession_result_ex record  
instance QC.Arbitrary StartSession_result where 
  arbitrary = M.liftM StartSession_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StartSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartSession_result{startSession_result_success = startSession_result_success obj} then P.Nothing else P.Just $ default_StartSession_result{startSession_result_success = startSession_result_success obj}
    , if obj == default_StartSession_result{startSession_result_ex = startSession_result_ex obj} then P.Nothing else P.Just $ default_StartSession_result{startSession_result_ex = startSession_result_ex obj}
    ]
from_StartSession_result :: StartSession_result -> T.ThriftVal
from_StartSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v85 -> (1, ("ex",Services_Types.from_ServicesException _v85))) <$> startSession_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v85 -> P.Just (0, ("success",Uuid_Types.from_UUID _v85))) $ startSession_result_success record
    , (\_v85 -> (1, ("ex",Services_Types.from_ServicesException _v85))) <$> startSession_result_ex record
    ]
    )
write_StartSession_result :: (T.Protocol p, T.Transport t) => p t -> StartSession_result -> P.IO ()
write_StartSession_result oprot record = T.writeVal oprot $ from_StartSession_result record
encode_StartSession_result :: (T.Protocol p, T.Transport t) => p t -> StartSession_result -> LBS.ByteString
encode_StartSession_result oprot record = T.serializeVal oprot $ from_StartSession_result record
to_StartSession_result :: T.ThriftVal -> StartSession_result
to_StartSession_result (T.TStruct fields) = StartSession_result{
  startSession_result_success = P.maybe (startSession_result_success default_StartSession_result) (\(_,_val87) -> (case _val87 of {T.TStruct _val88 -> (Uuid_Types.to_UUID (T.TStruct _val88)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  startSession_result_ex = P.maybe (P.Nothing) (\(_,_val87) -> P.Just (case _val87 of {T.TStruct _val89 -> (Services_Types.to_ServicesException (T.TStruct _val89)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartSession_result _ = P.error "not a struct"
read_StartSession_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StartSession_result
read_StartSession_result iprot = to_StartSession_result <$> T.readVal iprot (T.T_STRUCT typemap_StartSession_result)
decode_StartSession_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StartSession_result
decode_StartSession_result iprot bs = to_StartSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartSession_result) bs
typemap_StartSession_result :: T.TypeMap
typemap_StartSession_result = Map.fromList [(0,("success",(T.T_STRUCT Uuid_Types.typemap_UUID))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_StartSession_result :: StartSession_result
default_StartSession_result = StartSession_result{
  startSession_result_success = Uuid_Types.default_UUID,
  startSession_result_ex = P.Nothing}
data StopSession_args = StopSession_args  { stopSession_args_sessionId :: Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StopSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` stopSession_args_sessionId record  
instance QC.Arbitrary StopSession_args where 
  arbitrary = M.liftM StopSession_args (QC.arbitrary)
  shrink obj | obj == default_StopSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StopSession_args{stopSession_args_sessionId = stopSession_args_sessionId obj} then P.Nothing else P.Just $ default_StopSession_args{stopSession_args_sessionId = stopSession_args_sessionId obj}
    ]
from_StopSession_args :: StopSession_args -> T.ThriftVal
from_StopSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v92 -> P.Just (1, ("sessionId",Uuid_Types.from_UUID _v92))) $ stopSession_args_sessionId record
  ]
write_StopSession_args :: (T.Protocol p, T.Transport t) => p t -> StopSession_args -> P.IO ()
write_StopSession_args oprot record = T.writeVal oprot $ from_StopSession_args record
encode_StopSession_args :: (T.Protocol p, T.Transport t) => p t -> StopSession_args -> LBS.ByteString
encode_StopSession_args oprot record = T.serializeVal oprot $ from_StopSession_args record
to_StopSession_args :: T.ThriftVal -> StopSession_args
to_StopSession_args (T.TStruct fields) = StopSession_args{
  stopSession_args_sessionId = P.maybe (stopSession_args_sessionId default_StopSession_args) (\(_,_val94) -> (case _val94 of {T.TStruct _val95 -> (Uuid_Types.to_UUID (T.TStruct _val95)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StopSession_args _ = P.error "not a struct"
read_StopSession_args :: (T.Transport t, T.Protocol p) => p t -> P.IO StopSession_args
read_StopSession_args iprot = to_StopSession_args <$> T.readVal iprot (T.T_STRUCT typemap_StopSession_args)
decode_StopSession_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StopSession_args
decode_StopSession_args iprot bs = to_StopSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StopSession_args) bs
typemap_StopSession_args :: T.TypeMap
typemap_StopSession_args = Map.fromList [(1,("sessionId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_StopSession_args :: StopSession_args
default_StopSession_args = StopSession_args{
  stopSession_args_sessionId = Uuid_Types.default_UUID}
data StopSession_result = StopSession_result  { stopSession_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StopSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` stopSession_result_ex record  
instance QC.Arbitrary StopSession_result where 
  arbitrary = M.liftM StopSession_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StopSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StopSession_result{stopSession_result_ex = stopSession_result_ex obj} then P.Nothing else P.Just $ default_StopSession_result{stopSession_result_ex = stopSession_result_ex obj}
    ]
from_StopSession_result :: StopSession_result -> T.ThriftVal
from_StopSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v98 -> (1, ("ex",Services_Types.from_ServicesException _v98))) <$> stopSession_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v98 -> (1, ("ex",Services_Types.from_ServicesException _v98))) <$> stopSession_result_ex record
    ]
    )
write_StopSession_result :: (T.Protocol p, T.Transport t) => p t -> StopSession_result -> P.IO ()
write_StopSession_result oprot record = T.writeVal oprot $ from_StopSession_result record
encode_StopSession_result :: (T.Protocol p, T.Transport t) => p t -> StopSession_result -> LBS.ByteString
encode_StopSession_result oprot record = T.serializeVal oprot $ from_StopSession_result record
to_StopSession_result :: T.ThriftVal -> StopSession_result
to_StopSession_result (T.TStruct fields) = StopSession_result{
  stopSession_result_ex = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TStruct _val101 -> (Services_Types.to_ServicesException (T.TStruct _val101)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StopSession_result _ = P.error "not a struct"
read_StopSession_result :: (T.Transport t, T.Protocol p) => p t -> P.IO StopSession_result
read_StopSession_result iprot = to_StopSession_result <$> T.readVal iprot (T.T_STRUCT typemap_StopSession_result)
decode_StopSession_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> StopSession_result
decode_StopSession_result iprot bs = to_StopSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StopSession_result) bs
typemap_StopSession_result :: T.TypeMap
typemap_StopSession_result = Map.fromList [(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_StopSession_result :: StopSession_result
default_StopSession_result = StopSession_result{
  stopSession_result_ex = P.Nothing}
data GetNextChunk_args = GetNextChunk_args  { getNextChunk_args_sessionId :: Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextChunk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextChunk_args_sessionId record  
instance QC.Arbitrary GetNextChunk_args where 
  arbitrary = M.liftM GetNextChunk_args (QC.arbitrary)
  shrink obj | obj == default_GetNextChunk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextChunk_args{getNextChunk_args_sessionId = getNextChunk_args_sessionId obj} then P.Nothing else P.Just $ default_GetNextChunk_args{getNextChunk_args_sessionId = getNextChunk_args_sessionId obj}
    ]
from_GetNextChunk_args :: GetNextChunk_args -> T.ThriftVal
from_GetNextChunk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v104 -> P.Just (1, ("sessionId",Uuid_Types.from_UUID _v104))) $ getNextChunk_args_sessionId record
  ]
write_GetNextChunk_args :: (T.Protocol p, T.Transport t) => p t -> GetNextChunk_args -> P.IO ()
write_GetNextChunk_args oprot record = T.writeVal oprot $ from_GetNextChunk_args record
encode_GetNextChunk_args :: (T.Protocol p, T.Transport t) => p t -> GetNextChunk_args -> LBS.ByteString
encode_GetNextChunk_args oprot record = T.serializeVal oprot $ from_GetNextChunk_args record
to_GetNextChunk_args :: T.ThriftVal -> GetNextChunk_args
to_GetNextChunk_args (T.TStruct fields) = GetNextChunk_args{
  getNextChunk_args_sessionId = P.maybe (getNextChunk_args_sessionId default_GetNextChunk_args) (\(_,_val106) -> (case _val106 of {T.TStruct _val107 -> (Uuid_Types.to_UUID (T.TStruct _val107)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNextChunk_args _ = P.error "not a struct"
read_GetNextChunk_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetNextChunk_args
read_GetNextChunk_args iprot = to_GetNextChunk_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNextChunk_args)
decode_GetNextChunk_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetNextChunk_args
decode_GetNextChunk_args iprot bs = to_GetNextChunk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextChunk_args) bs
typemap_GetNextChunk_args :: T.TypeMap
typemap_GetNextChunk_args = Map.fromList [(1,("sessionId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_GetNextChunk_args :: GetNextChunk_args
default_GetNextChunk_args = GetNextChunk_args{
  getNextChunk_args_sessionId = Uuid_Types.default_UUID}
data GetNextChunk_result = GetNextChunk_result  { getNextChunk_result_success :: (Vector.Vector Services_Types.AnnotationUnitIdentifier)
  , getNextChunk_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextChunk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextChunk_result_success record   `H.hashWithSalt` getNextChunk_result_ex record  
instance QC.Arbitrary GetNextChunk_result where 
  arbitrary = M.liftM GetNextChunk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNextChunk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextChunk_result{getNextChunk_result_success = getNextChunk_result_success obj} then P.Nothing else P.Just $ default_GetNextChunk_result{getNextChunk_result_success = getNextChunk_result_success obj}
    , if obj == default_GetNextChunk_result{getNextChunk_result_ex = getNextChunk_result_ex obj} then P.Nothing else P.Just $ default_GetNextChunk_result{getNextChunk_result_ex = getNextChunk_result_ex obj}
    ]
from_GetNextChunk_result :: GetNextChunk_result -> T.ThriftVal
from_GetNextChunk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v110 -> (1, ("ex",Services_Types.from_ServicesException _v110))) <$> getNextChunk_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v110 -> P.Just (0, ("success",T.TList (T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier) $ P.map (\_v112 -> Services_Types.from_AnnotationUnitIdentifier _v112) $ Vector.toList _v110))) $ getNextChunk_result_success record
    , (\_v110 -> (1, ("ex",Services_Types.from_ServicesException _v110))) <$> getNextChunk_result_ex record
    ]
    )
write_GetNextChunk_result :: (T.Protocol p, T.Transport t) => p t -> GetNextChunk_result -> P.IO ()
write_GetNextChunk_result oprot record = T.writeVal oprot $ from_GetNextChunk_result record
encode_GetNextChunk_result :: (T.Protocol p, T.Transport t) => p t -> GetNextChunk_result -> LBS.ByteString
encode_GetNextChunk_result oprot record = T.serializeVal oprot $ from_GetNextChunk_result record
to_GetNextChunk_result :: T.ThriftVal -> GetNextChunk_result
to_GetNextChunk_result (T.TStruct fields) = GetNextChunk_result{
  getNextChunk_result_success = P.maybe (getNextChunk_result_success default_GetNextChunk_result) (\(_,_val114) -> (case _val114 of {T.TList _ _val115 -> (Vector.fromList $ P.map (\_v116 -> (case _v116 of {T.TStruct _val117 -> (Services_Types.to_AnnotationUnitIdentifier (T.TStruct _val117)); _ -> P.error "wrong type"})) _val115); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNextChunk_result_ex = P.maybe (P.Nothing) (\(_,_val114) -> P.Just (case _val114 of {T.TStruct _val118 -> (Services_Types.to_ServicesException (T.TStruct _val118)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNextChunk_result _ = P.error "not a struct"
read_GetNextChunk_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetNextChunk_result
read_GetNextChunk_result iprot = to_GetNextChunk_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNextChunk_result)
decode_GetNextChunk_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetNextChunk_result
decode_GetNextChunk_result iprot bs = to_GetNextChunk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextChunk_result) bs
typemap_GetNextChunk_result :: T.TypeMap
typemap_GetNextChunk_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier)))),(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_GetNextChunk_result :: GetNextChunk_result
default_GetNextChunk_result = GetNextChunk_result{
  getNextChunk_result_success = Vector.empty,
  getNextChunk_result_ex = P.Nothing}
data SubmitAnnotation_args = SubmitAnnotation_args  { submitAnnotation_args_sessionId :: Uuid_Types.UUID
  , submitAnnotation_args_unitId :: Services_Types.AnnotationUnitIdentifier
  , submitAnnotation_args_communication :: Communication_Types.Communication
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SubmitAnnotation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` submitAnnotation_args_sessionId record   `H.hashWithSalt` submitAnnotation_args_unitId record   `H.hashWithSalt` submitAnnotation_args_communication record  
instance QC.Arbitrary SubmitAnnotation_args where 
  arbitrary = M.liftM SubmitAnnotation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SubmitAnnotation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SubmitAnnotation_args{submitAnnotation_args_sessionId = submitAnnotation_args_sessionId obj} then P.Nothing else P.Just $ default_SubmitAnnotation_args{submitAnnotation_args_sessionId = submitAnnotation_args_sessionId obj}
    , if obj == default_SubmitAnnotation_args{submitAnnotation_args_unitId = submitAnnotation_args_unitId obj} then P.Nothing else P.Just $ default_SubmitAnnotation_args{submitAnnotation_args_unitId = submitAnnotation_args_unitId obj}
    , if obj == default_SubmitAnnotation_args{submitAnnotation_args_communication = submitAnnotation_args_communication obj} then P.Nothing else P.Just $ default_SubmitAnnotation_args{submitAnnotation_args_communication = submitAnnotation_args_communication obj}
    ]
from_SubmitAnnotation_args :: SubmitAnnotation_args -> T.ThriftVal
from_SubmitAnnotation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v121 -> P.Just (1, ("sessionId",Uuid_Types.from_UUID _v121))) $ submitAnnotation_args_sessionId record
  , (\_v121 -> P.Just (2, ("unitId",Services_Types.from_AnnotationUnitIdentifier _v121))) $ submitAnnotation_args_unitId record
  , (\_v121 -> P.Just (3, ("communication",Communication_Types.from_Communication _v121))) $ submitAnnotation_args_communication record
  ]
write_SubmitAnnotation_args :: (T.Protocol p, T.Transport t) => p t -> SubmitAnnotation_args -> P.IO ()
write_SubmitAnnotation_args oprot record = T.writeVal oprot $ from_SubmitAnnotation_args record
encode_SubmitAnnotation_args :: (T.Protocol p, T.Transport t) => p t -> SubmitAnnotation_args -> LBS.ByteString
encode_SubmitAnnotation_args oprot record = T.serializeVal oprot $ from_SubmitAnnotation_args record
to_SubmitAnnotation_args :: T.ThriftVal -> SubmitAnnotation_args
to_SubmitAnnotation_args (T.TStruct fields) = SubmitAnnotation_args{
  submitAnnotation_args_sessionId = P.maybe (submitAnnotation_args_sessionId default_SubmitAnnotation_args) (\(_,_val123) -> (case _val123 of {T.TStruct _val124 -> (Uuid_Types.to_UUID (T.TStruct _val124)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  submitAnnotation_args_unitId = P.maybe (submitAnnotation_args_unitId default_SubmitAnnotation_args) (\(_,_val123) -> (case _val123 of {T.TStruct _val125 -> (Services_Types.to_AnnotationUnitIdentifier (T.TStruct _val125)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  submitAnnotation_args_communication = P.maybe (submitAnnotation_args_communication default_SubmitAnnotation_args) (\(_,_val123) -> (case _val123 of {T.TStruct _val126 -> (Communication_Types.to_Communication (T.TStruct _val126)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SubmitAnnotation_args _ = P.error "not a struct"
read_SubmitAnnotation_args :: (T.Transport t, T.Protocol p) => p t -> P.IO SubmitAnnotation_args
read_SubmitAnnotation_args iprot = to_SubmitAnnotation_args <$> T.readVal iprot (T.T_STRUCT typemap_SubmitAnnotation_args)
decode_SubmitAnnotation_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SubmitAnnotation_args
decode_SubmitAnnotation_args iprot bs = to_SubmitAnnotation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SubmitAnnotation_args) bs
typemap_SubmitAnnotation_args :: T.TypeMap
typemap_SubmitAnnotation_args = Map.fromList [(1,("sessionId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("unitId",(T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier))),(3,("communication",(T.T_STRUCT Communication_Types.typemap_Communication)))]
default_SubmitAnnotation_args :: SubmitAnnotation_args
default_SubmitAnnotation_args = SubmitAnnotation_args{
  submitAnnotation_args_sessionId = Uuid_Types.default_UUID,
  submitAnnotation_args_unitId = Services_Types.default_AnnotationUnitIdentifier,
  submitAnnotation_args_communication = Communication_Types.default_Communication}
data SubmitAnnotation_result = SubmitAnnotation_result  { submitAnnotation_result_ex :: P.Maybe Services_Types.ServicesException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SubmitAnnotation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` submitAnnotation_result_ex record  
instance QC.Arbitrary SubmitAnnotation_result where 
  arbitrary = M.liftM SubmitAnnotation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SubmitAnnotation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SubmitAnnotation_result{submitAnnotation_result_ex = submitAnnotation_result_ex obj} then P.Nothing else P.Just $ default_SubmitAnnotation_result{submitAnnotation_result_ex = submitAnnotation_result_ex obj}
    ]
from_SubmitAnnotation_result :: SubmitAnnotation_result -> T.ThriftVal
from_SubmitAnnotation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v129 -> (1, ("ex",Services_Types.from_ServicesException _v129))) <$> submitAnnotation_result_ex record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v129 -> (1, ("ex",Services_Types.from_ServicesException _v129))) <$> submitAnnotation_result_ex record
    ]
    )
write_SubmitAnnotation_result :: (T.Protocol p, T.Transport t) => p t -> SubmitAnnotation_result -> P.IO ()
write_SubmitAnnotation_result oprot record = T.writeVal oprot $ from_SubmitAnnotation_result record
encode_SubmitAnnotation_result :: (T.Protocol p, T.Transport t) => p t -> SubmitAnnotation_result -> LBS.ByteString
encode_SubmitAnnotation_result oprot record = T.serializeVal oprot $ from_SubmitAnnotation_result record
to_SubmitAnnotation_result :: T.ThriftVal -> SubmitAnnotation_result
to_SubmitAnnotation_result (T.TStruct fields) = SubmitAnnotation_result{
  submitAnnotation_result_ex = P.maybe (P.Nothing) (\(_,_val131) -> P.Just (case _val131 of {T.TStruct _val132 -> (Services_Types.to_ServicesException (T.TStruct _val132)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SubmitAnnotation_result _ = P.error "not a struct"
read_SubmitAnnotation_result :: (T.Transport t, T.Protocol p) => p t -> P.IO SubmitAnnotation_result
read_SubmitAnnotation_result iprot = to_SubmitAnnotation_result <$> T.readVal iprot (T.T_STRUCT typemap_SubmitAnnotation_result)
decode_SubmitAnnotation_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SubmitAnnotation_result
decode_SubmitAnnotation_result iprot bs = to_SubmitAnnotation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SubmitAnnotation_result) bs
typemap_SubmitAnnotation_result :: T.TypeMap
typemap_SubmitAnnotation_result = Map.fromList [(1,("ex",(T.T_STRUCT Services_Types.typemap_ServicesException)))]
default_SubmitAnnotation_result :: SubmitAnnotation_result
default_SubmitAnnotation_result = SubmitAnnotation_result{
  submitAnnotation_result_ex = P.Nothing}
process_registerSearchResult (seqid, iprot, oprot, handler) = do
  args <- read_RegisterSearchResult_args iprot
  (X.catch
    (X.catch
      (do
        Iface.registerSearchResult handler (registerSearchResult_args_result args) (registerSearchResult_args_taskType args)
        let res = default_RegisterSearchResult_result
        T.writeMessageBegin oprot ("registerSearchResult", T.M_REPLY, seqid)
        write_RegisterSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_RegisterSearchResult_result{registerSearchResult_result_ex = P.Just e}
        T.writeMessageBegin oprot ("registerSearchResult", T.M_REPLY, seqid)
        write_RegisterSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("registerSearchResult", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getSearchResults (seqid, iprot, oprot, handler) = do
  args <- read_GetSearchResults_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSearchResults handler (getSearchResults_args_taskType args) (getSearchResults_args_limit args)
        let res = default_GetSearchResults_result{getSearchResults_result_success = val}
        T.writeMessageBegin oprot ("getSearchResults", T.M_REPLY, seqid)
        write_GetSearchResults_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetSearchResults_result{getSearchResults_result_ex = P.Just e}
        T.writeMessageBegin oprot ("getSearchResults", T.M_REPLY, seqid)
        write_GetSearchResults_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getSearchResults", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getSearchResultsByUser (seqid, iprot, oprot, handler) = do
  args <- read_GetSearchResultsByUser_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSearchResultsByUser handler (getSearchResultsByUser_args_taskType args) (getSearchResultsByUser_args_userId args) (getSearchResultsByUser_args_limit args)
        let res = default_GetSearchResultsByUser_result{getSearchResultsByUser_result_success = val}
        T.writeMessageBegin oprot ("getSearchResultsByUser", T.M_REPLY, seqid)
        write_GetSearchResultsByUser_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetSearchResultsByUser_result{getSearchResultsByUser_result_ex = P.Just e}
        T.writeMessageBegin oprot ("getSearchResultsByUser", T.M_REPLY, seqid)
        write_GetSearchResultsByUser_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getSearchResultsByUser", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getLatestSearchResult (seqid, iprot, oprot, handler) = do
  args <- read_GetLatestSearchResult_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLatestSearchResult handler (getLatestSearchResult_args_userId args)
        let res = default_GetLatestSearchResult_result{getLatestSearchResult_result_success = val}
        T.writeMessageBegin oprot ("getLatestSearchResult", T.M_REPLY, seqid)
        write_GetLatestSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetLatestSearchResult_result{getLatestSearchResult_result_ex = P.Just e}
        T.writeMessageBegin oprot ("getLatestSearchResult", T.M_REPLY, seqid)
        write_GetLatestSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getLatestSearchResult", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getSearchResult (seqid, iprot, oprot, handler) = do
  args <- read_GetSearchResult_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSearchResult handler (getSearchResult_args_searchResultId args)
        let res = default_GetSearchResult_result{getSearchResult_result_success = val}
        T.writeMessageBegin oprot ("getSearchResult", T.M_REPLY, seqid)
        write_GetSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetSearchResult_result{getSearchResult_result_ex = P.Just e}
        T.writeMessageBegin oprot ("getSearchResult", T.M_REPLY, seqid)
        write_GetSearchResult_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getSearchResult", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_startSession (seqid, iprot, oprot, handler) = do
  args <- read_StartSession_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.startSession handler (startSession_args_searchResultId args) (startSession_args_taskType args)
        let res = default_StartSession_result{startSession_result_success = val}
        T.writeMessageBegin oprot ("startSession", T.M_REPLY, seqid)
        write_StartSession_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_StartSession_result{startSession_result_ex = P.Just e}
        T.writeMessageBegin oprot ("startSession", T.M_REPLY, seqid)
        write_StartSession_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("startSession", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_stopSession (seqid, iprot, oprot, handler) = do
  args <- read_StopSession_args iprot
  (X.catch
    (X.catch
      (do
        Iface.stopSession handler (stopSession_args_sessionId args)
        let res = default_StopSession_result
        T.writeMessageBegin oprot ("stopSession", T.M_REPLY, seqid)
        write_StopSession_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_StopSession_result{stopSession_result_ex = P.Just e}
        T.writeMessageBegin oprot ("stopSession", T.M_REPLY, seqid)
        write_StopSession_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("stopSession", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getNextChunk (seqid, iprot, oprot, handler) = do
  args <- read_GetNextChunk_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNextChunk handler (getNextChunk_args_sessionId args)
        let res = default_GetNextChunk_result{getNextChunk_result_success = val}
        T.writeMessageBegin oprot ("getNextChunk", T.M_REPLY, seqid)
        write_GetNextChunk_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetNextChunk_result{getNextChunk_result_ex = P.Just e}
        T.writeMessageBegin oprot ("getNextChunk", T.M_REPLY, seqid)
        write_GetNextChunk_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getNextChunk", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_submitAnnotation (seqid, iprot, oprot, handler) = do
  args <- read_SubmitAnnotation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.submitAnnotation handler (submitAnnotation_args_sessionId args) (submitAnnotation_args_unitId args) (submitAnnotation_args_communication args)
        let res = default_SubmitAnnotation_result
        T.writeMessageBegin oprot ("submitAnnotation", T.M_REPLY, seqid)
        write_SubmitAnnotation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_SubmitAnnotation_result{submitAnnotation_result_ex = P.Just e}
        T.writeMessageBegin oprot ("submitAnnotation", T.M_REPLY, seqid)
        write_SubmitAnnotation_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("submitAnnotation", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "registerSearchResult" -> process_registerSearchResult (seqid,iprot,oprot,handler)
  "getSearchResults" -> process_getSearchResults (seqid,iprot,oprot,handler)
  "getSearchResultsByUser" -> process_getSearchResultsByUser (seqid,iprot,oprot,handler)
  "getLatestSearchResult" -> process_getLatestSearchResult (seqid,iprot,oprot,handler)
  "getSearchResult" -> process_getSearchResult (seqid,iprot,oprot,handler)
  "startSession" -> process_startSession (seqid,iprot,oprot,handler)
  "stopSession" -> process_stopSession (seqid,iprot,oprot,handler)
  "getNextChunk" -> process_getNextChunk (seqid,iprot,oprot,handler)
  "submitAnnotation" -> process_submitAnnotation (seqid,iprot,oprot,handler)
  _ -> Service.proc_ handler (iprot,oprot) (name,typ,seqid)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
