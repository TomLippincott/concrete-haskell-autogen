{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Communication_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Language_Types as Language_Types
import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Entities_Types as Entities_Types
import Data.Concrete.Autogen.Situations_Types as Situations_Types
import Data.Concrete.Autogen.Audio_Types as Audio_Types
import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Cluster_Types as Cluster_Types


data CommunicationTagging = CommunicationTagging  { communicationTagging_uuid :: Uuid_Types.UUID
  , communicationTagging_metadata :: Metadata_Types.AnnotationMetadata
  , communicationTagging_taggingType :: LT.Text
  , communicationTagging_tagList :: P.Maybe (Vector.Vector LT.Text)
  , communicationTagging_confidenceList :: P.Maybe (Vector.Vector P.Double)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommunicationTagging where
  hashWithSalt salt record = salt   `H.hashWithSalt` communicationTagging_uuid record   `H.hashWithSalt` communicationTagging_metadata record   `H.hashWithSalt` communicationTagging_taggingType record   `H.hashWithSalt` communicationTagging_tagList record   `H.hashWithSalt` communicationTagging_confidenceList record  
instance QC.Arbitrary CommunicationTagging where 
  arbitrary = M.liftM CommunicationTagging (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommunicationTagging = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommunicationTagging{communicationTagging_uuid = communicationTagging_uuid obj} then P.Nothing else P.Just $ default_CommunicationTagging{communicationTagging_uuid = communicationTagging_uuid obj}
    , if obj == default_CommunicationTagging{communicationTagging_metadata = communicationTagging_metadata obj} then P.Nothing else P.Just $ default_CommunicationTagging{communicationTagging_metadata = communicationTagging_metadata obj}
    , if obj == default_CommunicationTagging{communicationTagging_taggingType = communicationTagging_taggingType obj} then P.Nothing else P.Just $ default_CommunicationTagging{communicationTagging_taggingType = communicationTagging_taggingType obj}
    , if obj == default_CommunicationTagging{communicationTagging_tagList = communicationTagging_tagList obj} then P.Nothing else P.Just $ default_CommunicationTagging{communicationTagging_tagList = communicationTagging_tagList obj}
    , if obj == default_CommunicationTagging{communicationTagging_confidenceList = communicationTagging_confidenceList obj} then P.Nothing else P.Just $ default_CommunicationTagging{communicationTagging_confidenceList = communicationTagging_confidenceList obj}
    ]
from_CommunicationTagging :: CommunicationTagging -> T.ThriftVal
from_CommunicationTagging record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v2))) $ communicationTagging_uuid record
  , (\_v2 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v2))) $ communicationTagging_metadata record
  , (\_v2 -> P.Just (3, ("taggingType",T.TString $ E.encodeUtf8 _v2))) $ communicationTagging_taggingType record
  , (\_v2 -> (4, ("tagList",T.TList T.T_STRING $ P.map (\_v4 -> T.TString $ E.encodeUtf8 _v4) $ Vector.toList _v2))) <$> communicationTagging_tagList record
  , (\_v2 -> (5, ("confidenceList",T.TList T.T_DOUBLE $ P.map (\_v6 -> T.TDouble _v6) $ Vector.toList _v2))) <$> communicationTagging_confidenceList record
  ]
write_CommunicationTagging :: (T.Protocol p, T.Transport t) => p t -> CommunicationTagging -> P.IO ()
write_CommunicationTagging oprot record = T.writeVal oprot $ from_CommunicationTagging record
encode_CommunicationTagging :: (T.Protocol p, T.Transport t) => p t -> CommunicationTagging -> LBS.ByteString
encode_CommunicationTagging oprot record = T.serializeVal oprot $ from_CommunicationTagging record
to_CommunicationTagging :: T.ThriftVal -> CommunicationTagging
to_CommunicationTagging (T.TStruct fields) = CommunicationTagging{
  communicationTagging_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val8) -> (case _val8 of {T.TStruct _val9 -> (Uuid_Types.to_UUID (T.TStruct _val9)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  communicationTagging_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val8) -> (case _val8 of {T.TStruct _val10 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val10)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  communicationTagging_taggingType = P.maybe (P.error "Missing required field: taggingType") (\(_,_val8) -> (case _val8 of {T.TString _val11 -> E.decodeUtf8 _val11; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  communicationTagging_tagList = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TList _ _val12 -> (Vector.fromList $ P.map (\_v13 -> (case _v13 of {T.TString _val14 -> E.decodeUtf8 _val14; _ -> P.error "wrong type"})) _val12); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  communicationTagging_confidenceList = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TList _ _val15 -> (Vector.fromList $ P.map (\_v16 -> (case _v16 of {T.TDouble _val17 -> _val17; _ -> P.error "wrong type"})) _val15); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CommunicationTagging _ = P.error "not a struct"
read_CommunicationTagging :: (T.Transport t, T.Protocol p) => p t -> P.IO CommunicationTagging
read_CommunicationTagging iprot = to_CommunicationTagging <$> T.readVal iprot (T.T_STRUCT typemap_CommunicationTagging)
decode_CommunicationTagging :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CommunicationTagging
decode_CommunicationTagging iprot bs = to_CommunicationTagging $ T.deserializeVal iprot (T.T_STRUCT typemap_CommunicationTagging) bs
typemap_CommunicationTagging :: T.TypeMap
typemap_CommunicationTagging = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("taggingType",T.T_STRING)),(4,("tagList",(T.T_LIST T.T_STRING))),(5,("confidenceList",(T.T_LIST T.T_DOUBLE)))]
default_CommunicationTagging :: CommunicationTagging
default_CommunicationTagging = CommunicationTagging{
  communicationTagging_uuid = Uuid_Types.default_UUID,
  communicationTagging_metadata = Metadata_Types.default_AnnotationMetadata,
  communicationTagging_taggingType = "",
  communicationTagging_tagList = P.Nothing,
  communicationTagging_confidenceList = P.Nothing}
data Communication = Communication  { communication_id :: LT.Text
  , communication_uuid :: Uuid_Types.UUID
  , communication_type :: LT.Text
  , communication_text :: P.Maybe LT.Text
  , communication_startTime :: P.Maybe I.Int64
  , communication_endTime :: P.Maybe I.Int64
  , communication_communicationTaggingList :: P.Maybe (Vector.Vector CommunicationTagging)
  , communication_metadata :: Metadata_Types.AnnotationMetadata
  , communication_keyValueMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , communication_lidList :: P.Maybe (Vector.Vector Language_Types.LanguageIdentification)
  , communication_sectionList :: P.Maybe (Vector.Vector Structure_Types.Section)
  , communication_entityMentionSetList :: P.Maybe (Vector.Vector Entities_Types.EntityMentionSet)
  , communication_entitySetList :: P.Maybe (Vector.Vector Entities_Types.EntitySet)
  , communication_situationMentionSetList :: P.Maybe (Vector.Vector Situations_Types.SituationMentionSet)
  , communication_situationSetList :: P.Maybe (Vector.Vector Situations_Types.SituationSet)
  , communication_originalText :: P.Maybe LT.Text
  , communication_sound :: P.Maybe Audio_Types.Sound
  , communication_communicationMetadata :: P.Maybe Metadata_Types.CommunicationMetadata
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Communication where
  hashWithSalt salt record = salt   `H.hashWithSalt` communication_id record   `H.hashWithSalt` communication_uuid record   `H.hashWithSalt` communication_type record   `H.hashWithSalt` communication_text record   `H.hashWithSalt` communication_startTime record   `H.hashWithSalt` communication_endTime record   `H.hashWithSalt` communication_communicationTaggingList record   `H.hashWithSalt` communication_metadata record   `H.hashWithSalt` communication_keyValueMap record   `H.hashWithSalt` communication_lidList record   `H.hashWithSalt` communication_sectionList record   `H.hashWithSalt` communication_entityMentionSetList record   `H.hashWithSalt` communication_entitySetList record   `H.hashWithSalt` communication_situationMentionSetList record   `H.hashWithSalt` communication_situationSetList record   `H.hashWithSalt` communication_originalText record   `H.hashWithSalt` communication_sound record   `H.hashWithSalt` communication_communicationMetadata record  
instance QC.Arbitrary Communication where 
  arbitrary = M.liftM Communication (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Communication = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Communication{communication_id = communication_id obj} then P.Nothing else P.Just $ default_Communication{communication_id = communication_id obj}
    , if obj == default_Communication{communication_uuid = communication_uuid obj} then P.Nothing else P.Just $ default_Communication{communication_uuid = communication_uuid obj}
    , if obj == default_Communication{communication_type = communication_type obj} then P.Nothing else P.Just $ default_Communication{communication_type = communication_type obj}
    , if obj == default_Communication{communication_text = communication_text obj} then P.Nothing else P.Just $ default_Communication{communication_text = communication_text obj}
    , if obj == default_Communication{communication_startTime = communication_startTime obj} then P.Nothing else P.Just $ default_Communication{communication_startTime = communication_startTime obj}
    , if obj == default_Communication{communication_endTime = communication_endTime obj} then P.Nothing else P.Just $ default_Communication{communication_endTime = communication_endTime obj}
    , if obj == default_Communication{communication_communicationTaggingList = communication_communicationTaggingList obj} then P.Nothing else P.Just $ default_Communication{communication_communicationTaggingList = communication_communicationTaggingList obj}
    , if obj == default_Communication{communication_metadata = communication_metadata obj} then P.Nothing else P.Just $ default_Communication{communication_metadata = communication_metadata obj}
    , if obj == default_Communication{communication_keyValueMap = communication_keyValueMap obj} then P.Nothing else P.Just $ default_Communication{communication_keyValueMap = communication_keyValueMap obj}
    , if obj == default_Communication{communication_lidList = communication_lidList obj} then P.Nothing else P.Just $ default_Communication{communication_lidList = communication_lidList obj}
    , if obj == default_Communication{communication_sectionList = communication_sectionList obj} then P.Nothing else P.Just $ default_Communication{communication_sectionList = communication_sectionList obj}
    , if obj == default_Communication{communication_entityMentionSetList = communication_entityMentionSetList obj} then P.Nothing else P.Just $ default_Communication{communication_entityMentionSetList = communication_entityMentionSetList obj}
    , if obj == default_Communication{communication_entitySetList = communication_entitySetList obj} then P.Nothing else P.Just $ default_Communication{communication_entitySetList = communication_entitySetList obj}
    , if obj == default_Communication{communication_situationMentionSetList = communication_situationMentionSetList obj} then P.Nothing else P.Just $ default_Communication{communication_situationMentionSetList = communication_situationMentionSetList obj}
    , if obj == default_Communication{communication_situationSetList = communication_situationSetList obj} then P.Nothing else P.Just $ default_Communication{communication_situationSetList = communication_situationSetList obj}
    , if obj == default_Communication{communication_originalText = communication_originalText obj} then P.Nothing else P.Just $ default_Communication{communication_originalText = communication_originalText obj}
    , if obj == default_Communication{communication_sound = communication_sound obj} then P.Nothing else P.Just $ default_Communication{communication_sound = communication_sound obj}
    , if obj == default_Communication{communication_communicationMetadata = communication_communicationMetadata obj} then P.Nothing else P.Just $ default_Communication{communication_communicationMetadata = communication_communicationMetadata obj}
    ]
from_Communication :: Communication -> T.ThriftVal
from_Communication record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v20 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v20))) $ communication_id record
  , (\_v20 -> P.Just (2, ("uuid",Uuid_Types.from_UUID _v20))) $ communication_uuid record
  , (\_v20 -> P.Just (3, ("type",T.TString $ E.encodeUtf8 _v20))) $ communication_type record
  , (\_v20 -> (4, ("text",T.TString $ E.encodeUtf8 _v20))) <$> communication_text record
  , (\_v20 -> (5, ("startTime",T.TI64 _v20))) <$> communication_startTime record
  , (\_v20 -> (6, ("endTime",T.TI64 _v20))) <$> communication_endTime record
  , (\_v20 -> (7, ("communicationTaggingList",T.TList (T.T_STRUCT typemap_CommunicationTagging) $ P.map (\_v22 -> from_CommunicationTagging _v22) $ Vector.toList _v20))) <$> communication_communicationTaggingList record
  , (\_v20 -> P.Just (8, ("metadata",Metadata_Types.from_AnnotationMetadata _v20))) $ communication_metadata record
  , (\_v20 -> (9, ("keyValueMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k23,_v24) -> (T.TString $ E.encodeUtf8 _k23, T.TString $ E.encodeUtf8 _v24)) $ Map.toList _v20))) <$> communication_keyValueMap record
  , (\_v20 -> (10, ("lidList",T.TList (T.T_STRUCT Language_Types.typemap_LanguageIdentification) $ P.map (\_v26 -> Language_Types.from_LanguageIdentification _v26) $ Vector.toList _v20))) <$> communication_lidList record
  , (\_v20 -> (11, ("sectionList",T.TList (T.T_STRUCT Structure_Types.typemap_Section) $ P.map (\_v28 -> Structure_Types.from_Section _v28) $ Vector.toList _v20))) <$> communication_sectionList record
  , (\_v20 -> (12, ("entityMentionSetList",T.TList (T.T_STRUCT Entities_Types.typemap_EntityMentionSet) $ P.map (\_v30 -> Entities_Types.from_EntityMentionSet _v30) $ Vector.toList _v20))) <$> communication_entityMentionSetList record
  , (\_v20 -> (13, ("entitySetList",T.TList (T.T_STRUCT Entities_Types.typemap_EntitySet) $ P.map (\_v32 -> Entities_Types.from_EntitySet _v32) $ Vector.toList _v20))) <$> communication_entitySetList record
  , (\_v20 -> (14, ("situationMentionSetList",T.TList (T.T_STRUCT Situations_Types.typemap_SituationMentionSet) $ P.map (\_v34 -> Situations_Types.from_SituationMentionSet _v34) $ Vector.toList _v20))) <$> communication_situationMentionSetList record
  , (\_v20 -> (15, ("situationSetList",T.TList (T.T_STRUCT Situations_Types.typemap_SituationSet) $ P.map (\_v36 -> Situations_Types.from_SituationSet _v36) $ Vector.toList _v20))) <$> communication_situationSetList record
  , (\_v20 -> (16, ("originalText",T.TString $ E.encodeUtf8 _v20))) <$> communication_originalText record
  , (\_v20 -> (20, ("sound",Audio_Types.from_Sound _v20))) <$> communication_sound record
  , (\_v20 -> (21, ("communicationMetadata",Metadata_Types.from_CommunicationMetadata _v20))) <$> communication_communicationMetadata record
  ]
write_Communication :: (T.Protocol p, T.Transport t) => p t -> Communication -> P.IO ()
write_Communication oprot record = T.writeVal oprot $ from_Communication record
encode_Communication :: (T.Protocol p, T.Transport t) => p t -> Communication -> LBS.ByteString
encode_Communication oprot record = T.serializeVal oprot $ from_Communication record
to_Communication :: T.ThriftVal -> Communication
to_Communication (T.TStruct fields) = Communication{
  communication_id = P.maybe (P.error "Missing required field: id") (\(_,_val38) -> (case _val38 of {T.TString _val39 -> E.decodeUtf8 _val39; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  communication_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val38) -> (case _val38 of {T.TStruct _val40 -> (Uuid_Types.to_UUID (T.TStruct _val40)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  communication_type = P.maybe (P.error "Missing required field: type") (\(_,_val38) -> (case _val38 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  communication_text = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  communication_startTime = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TI64 _val43 -> _val43; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  communication_endTime = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TI64 _val44 -> _val44; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  communication_communicationTaggingList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val45 -> (Vector.fromList $ P.map (\_v46 -> (case _v46 of {T.TStruct _val47 -> (to_CommunicationTagging (T.TStruct _val47)); _ -> P.error "wrong type"})) _val45); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  communication_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val38) -> (case _val38 of {T.TStruct _val48 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val48)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  communication_keyValueMap = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TMap _ _ _val49 -> (Map.fromList $ P.map (\(_k51,_v50) -> ((case _k51 of {T.TString _val52 -> E.decodeUtf8 _val52; _ -> P.error "wrong type"}),(case _v50 of {T.TString _val53 -> E.decodeUtf8 _val53; _ -> P.error "wrong type"}))) _val49); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  communication_lidList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val54 -> (Vector.fromList $ P.map (\_v55 -> (case _v55 of {T.TStruct _val56 -> (Language_Types.to_LanguageIdentification (T.TStruct _val56)); _ -> P.error "wrong type"})) _val54); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  communication_sectionList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val57 -> (Vector.fromList $ P.map (\_v58 -> (case _v58 of {T.TStruct _val59 -> (Structure_Types.to_Section (T.TStruct _val59)); _ -> P.error "wrong type"})) _val57); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  communication_entityMentionSetList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val60 -> (Vector.fromList $ P.map (\_v61 -> (case _v61 of {T.TStruct _val62 -> (Entities_Types.to_EntityMentionSet (T.TStruct _val62)); _ -> P.error "wrong type"})) _val60); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  communication_entitySetList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val63 -> (Vector.fromList $ P.map (\_v64 -> (case _v64 of {T.TStruct _val65 -> (Entities_Types.to_EntitySet (T.TStruct _val65)); _ -> P.error "wrong type"})) _val63); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  communication_situationMentionSetList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val66 -> (Vector.fromList $ P.map (\_v67 -> (case _v67 of {T.TStruct _val68 -> (Situations_Types.to_SituationMentionSet (T.TStruct _val68)); _ -> P.error "wrong type"})) _val66); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  communication_situationSetList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val69 -> (Vector.fromList $ P.map (\_v70 -> (case _v70 of {T.TStruct _val71 -> (Situations_Types.to_SituationSet (T.TStruct _val71)); _ -> P.error "wrong type"})) _val69); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  communication_originalText = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val72 -> E.decodeUtf8 _val72; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  communication_sound = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TStruct _val73 -> (Audio_Types.to_Sound (T.TStruct _val73)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  communication_communicationMetadata = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TStruct _val74 -> (Metadata_Types.to_CommunicationMetadata (T.TStruct _val74)); _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_Communication _ = P.error "not a struct"
read_Communication :: (T.Transport t, T.Protocol p) => p t -> P.IO Communication
read_Communication iprot = to_Communication <$> T.readVal iprot (T.T_STRUCT typemap_Communication)
decode_Communication :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Communication
decode_Communication iprot bs = to_Communication $ T.deserializeVal iprot (T.T_STRUCT typemap_Communication) bs
typemap_Communication :: T.TypeMap
typemap_Communication = Map.fromList [(1,("id",T.T_STRING)),(2,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("type",T.T_STRING)),(4,("text",T.T_STRING)),(5,("startTime",T.T_I64)),(6,("endTime",T.T_I64)),(7,("communicationTaggingList",(T.T_LIST (T.T_STRUCT typemap_CommunicationTagging)))),(8,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(9,("keyValueMap",(T.T_MAP T.T_STRING T.T_STRING))),(10,("lidList",(T.T_LIST (T.T_STRUCT Language_Types.typemap_LanguageIdentification)))),(11,("sectionList",(T.T_LIST (T.T_STRUCT Structure_Types.typemap_Section)))),(12,("entityMentionSetList",(T.T_LIST (T.T_STRUCT Entities_Types.typemap_EntityMentionSet)))),(13,("entitySetList",(T.T_LIST (T.T_STRUCT Entities_Types.typemap_EntitySet)))),(14,("situationMentionSetList",(T.T_LIST (T.T_STRUCT Situations_Types.typemap_SituationMentionSet)))),(15,("situationSetList",(T.T_LIST (T.T_STRUCT Situations_Types.typemap_SituationSet)))),(16,("originalText",T.T_STRING)),(20,("sound",(T.T_STRUCT Audio_Types.typemap_Sound))),(21,("communicationMetadata",(T.T_STRUCT Metadata_Types.typemap_CommunicationMetadata)))]
default_Communication :: Communication
default_Communication = Communication{
  communication_id = "",
  communication_uuid = Uuid_Types.default_UUID,
  communication_type = "",
  communication_text = P.Nothing,
  communication_startTime = P.Nothing,
  communication_endTime = P.Nothing,
  communication_communicationTaggingList = P.Nothing,
  communication_metadata = Metadata_Types.default_AnnotationMetadata,
  communication_keyValueMap = P.Nothing,
  communication_lidList = P.Nothing,
  communication_sectionList = P.Nothing,
  communication_entityMentionSetList = P.Nothing,
  communication_entitySetList = P.Nothing,
  communication_situationMentionSetList = P.Nothing,
  communication_situationSetList = P.Nothing,
  communication_originalText = P.Nothing,
  communication_sound = P.Nothing,
  communication_communicationMetadata = P.Nothing}
data CommunicationSet = CommunicationSet  { communicationSet_communicationIdList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  , communicationSet_corpus :: P.Maybe LT.Text
  , communicationSet_entityMentionClusterList :: P.Maybe (Vector.Vector Cluster_Types.Clustering)
  , communicationSet_entityClusterList :: P.Maybe (Vector.Vector Cluster_Types.Clustering)
  , communicationSet_situationMentionClusterList :: P.Maybe (Vector.Vector Cluster_Types.Clustering)
  , communicationSet_situationClusterList :: P.Maybe (Vector.Vector Cluster_Types.Clustering)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommunicationSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` communicationSet_communicationIdList record   `H.hashWithSalt` communicationSet_corpus record   `H.hashWithSalt` communicationSet_entityMentionClusterList record   `H.hashWithSalt` communicationSet_entityClusterList record   `H.hashWithSalt` communicationSet_situationMentionClusterList record   `H.hashWithSalt` communicationSet_situationClusterList record  
instance QC.Arbitrary CommunicationSet where 
  arbitrary = M.liftM CommunicationSet (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommunicationSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommunicationSet{communicationSet_communicationIdList = communicationSet_communicationIdList obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_communicationIdList = communicationSet_communicationIdList obj}
    , if obj == default_CommunicationSet{communicationSet_corpus = communicationSet_corpus obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_corpus = communicationSet_corpus obj}
    , if obj == default_CommunicationSet{communicationSet_entityMentionClusterList = communicationSet_entityMentionClusterList obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_entityMentionClusterList = communicationSet_entityMentionClusterList obj}
    , if obj == default_CommunicationSet{communicationSet_entityClusterList = communicationSet_entityClusterList obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_entityClusterList = communicationSet_entityClusterList obj}
    , if obj == default_CommunicationSet{communicationSet_situationMentionClusterList = communicationSet_situationMentionClusterList obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_situationMentionClusterList = communicationSet_situationMentionClusterList obj}
    , if obj == default_CommunicationSet{communicationSet_situationClusterList = communicationSet_situationClusterList obj} then P.Nothing else P.Just $ default_CommunicationSet{communicationSet_situationClusterList = communicationSet_situationClusterList obj}
    ]
from_CommunicationSet :: CommunicationSet -> T.ThriftVal
from_CommunicationSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v77 -> (1, ("communicationIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v79 -> Uuid_Types.from_UUID _v79) $ Vector.toList _v77))) <$> communicationSet_communicationIdList record
  , (\_v77 -> (2, ("corpus",T.TString $ E.encodeUtf8 _v77))) <$> communicationSet_corpus record
  , (\_v77 -> (3, ("entityMentionClusterList",T.TList (T.T_STRUCT Cluster_Types.typemap_Clustering) $ P.map (\_v81 -> Cluster_Types.from_Clustering _v81) $ Vector.toList _v77))) <$> communicationSet_entityMentionClusterList record
  , (\_v77 -> (4, ("entityClusterList",T.TList (T.T_STRUCT Cluster_Types.typemap_Clustering) $ P.map (\_v83 -> Cluster_Types.from_Clustering _v83) $ Vector.toList _v77))) <$> communicationSet_entityClusterList record
  , (\_v77 -> (5, ("situationMentionClusterList",T.TList (T.T_STRUCT Cluster_Types.typemap_Clustering) $ P.map (\_v85 -> Cluster_Types.from_Clustering _v85) $ Vector.toList _v77))) <$> communicationSet_situationMentionClusterList record
  , (\_v77 -> (6, ("situationClusterList",T.TList (T.T_STRUCT Cluster_Types.typemap_Clustering) $ P.map (\_v87 -> Cluster_Types.from_Clustering _v87) $ Vector.toList _v77))) <$> communicationSet_situationClusterList record
  ]
write_CommunicationSet :: (T.Protocol p, T.Transport t) => p t -> CommunicationSet -> P.IO ()
write_CommunicationSet oprot record = T.writeVal oprot $ from_CommunicationSet record
encode_CommunicationSet :: (T.Protocol p, T.Transport t) => p t -> CommunicationSet -> LBS.ByteString
encode_CommunicationSet oprot record = T.serializeVal oprot $ from_CommunicationSet record
to_CommunicationSet :: T.ThriftVal -> CommunicationSet
to_CommunicationSet (T.TStruct fields) = CommunicationSet{
  communicationSet_communicationIdList = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TList _ _val90 -> (Vector.fromList $ P.map (\_v91 -> (case _v91 of {T.TStruct _val92 -> (Uuid_Types.to_UUID (T.TStruct _val92)); _ -> P.error "wrong type"})) _val90); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  communicationSet_corpus = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TString _val93 -> E.decodeUtf8 _val93; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  communicationSet_entityMentionClusterList = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TList _ _val94 -> (Vector.fromList $ P.map (\_v95 -> (case _v95 of {T.TStruct _val96 -> (Cluster_Types.to_Clustering (T.TStruct _val96)); _ -> P.error "wrong type"})) _val94); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  communicationSet_entityClusterList = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TList _ _val97 -> (Vector.fromList $ P.map (\_v98 -> (case _v98 of {T.TStruct _val99 -> (Cluster_Types.to_Clustering (T.TStruct _val99)); _ -> P.error "wrong type"})) _val97); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  communicationSet_situationMentionClusterList = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TList _ _val100 -> (Vector.fromList $ P.map (\_v101 -> (case _v101 of {T.TStruct _val102 -> (Cluster_Types.to_Clustering (T.TStruct _val102)); _ -> P.error "wrong type"})) _val100); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  communicationSet_situationClusterList = P.maybe (P.Nothing) (\(_,_val89) -> P.Just (case _val89 of {T.TList _ _val103 -> (Vector.fromList $ P.map (\_v104 -> (case _v104 of {T.TStruct _val105 -> (Cluster_Types.to_Clustering (T.TStruct _val105)); _ -> P.error "wrong type"})) _val103); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_CommunicationSet _ = P.error "not a struct"
read_CommunicationSet :: (T.Transport t, T.Protocol p) => p t -> P.IO CommunicationSet
read_CommunicationSet iprot = to_CommunicationSet <$> T.readVal iprot (T.T_STRUCT typemap_CommunicationSet)
decode_CommunicationSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CommunicationSet
decode_CommunicationSet iprot bs = to_CommunicationSet $ T.deserializeVal iprot (T.T_STRUCT typemap_CommunicationSet) bs
typemap_CommunicationSet :: T.TypeMap
typemap_CommunicationSet = Map.fromList [(1,("communicationIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(2,("corpus",T.T_STRING)),(3,("entityMentionClusterList",(T.T_LIST (T.T_STRUCT Cluster_Types.typemap_Clustering)))),(4,("entityClusterList",(T.T_LIST (T.T_STRUCT Cluster_Types.typemap_Clustering)))),(5,("situationMentionClusterList",(T.T_LIST (T.T_STRUCT Cluster_Types.typemap_Clustering)))),(6,("situationClusterList",(T.T_LIST (T.T_STRUCT Cluster_Types.typemap_Clustering))))]
default_CommunicationSet :: CommunicationSet
default_CommunicationSet = CommunicationSet{
  communicationSet_communicationIdList = P.Nothing,
  communicationSet_corpus = P.Nothing,
  communicationSet_entityMentionClusterList = P.Nothing,
  communicationSet_entityClusterList = P.Nothing,
  communicationSet_situationMentionClusterList = P.Nothing,
  communicationSet_situationClusterList = P.Nothing}
