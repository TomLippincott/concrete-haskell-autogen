{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Learn_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Services_Types as Services_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Communication_Types as Communication_Types


data AnnotationTask = AnnotationTask  { annotationTask_type :: Services_Types.AnnotationTaskType
  , annotationTask_language :: P.Maybe LT.Text
  , annotationTask_unitType :: Services_Types.AnnotationUnitType
  , annotationTask_units :: (Vector.Vector Services_Types.AnnotationUnitIdentifier)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AnnotationTask where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotationTask_type record   `H.hashWithSalt` annotationTask_language record   `H.hashWithSalt` annotationTask_unitType record   `H.hashWithSalt` annotationTask_units record  
instance QC.Arbitrary AnnotationTask where 
  arbitrary = M.liftM AnnotationTask (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AnnotationTask = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AnnotationTask{annotationTask_type = annotationTask_type obj} then P.Nothing else P.Just $ default_AnnotationTask{annotationTask_type = annotationTask_type obj}
    , if obj == default_AnnotationTask{annotationTask_language = annotationTask_language obj} then P.Nothing else P.Just $ default_AnnotationTask{annotationTask_language = annotationTask_language obj}
    , if obj == default_AnnotationTask{annotationTask_unitType = annotationTask_unitType obj} then P.Nothing else P.Just $ default_AnnotationTask{annotationTask_unitType = annotationTask_unitType obj}
    , if obj == default_AnnotationTask{annotationTask_units = annotationTask_units obj} then P.Nothing else P.Just $ default_AnnotationTask{annotationTask_units = annotationTask_units obj}
    ]
from_AnnotationTask :: AnnotationTask -> T.ThriftVal
from_AnnotationTask record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ annotationTask_type record
  , (\_v2 -> (2, ("language",T.TString $ E.encodeUtf8 _v2))) <$> annotationTask_language record
  , (\_v2 -> P.Just (3, ("unitType",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ annotationTask_unitType record
  , (\_v2 -> P.Just (4, ("units",T.TList (T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier) $ P.map (\_v4 -> Services_Types.from_AnnotationUnitIdentifier _v4) $ Vector.toList _v2))) $ annotationTask_units record
  ]
write_AnnotationTask :: (T.Protocol p, T.Transport t) => p t -> AnnotationTask -> P.IO ()
write_AnnotationTask oprot record = T.writeVal oprot $ from_AnnotationTask record
encode_AnnotationTask :: (T.Protocol p, T.Transport t) => p t -> AnnotationTask -> LBS.ByteString
encode_AnnotationTask oprot record = T.serializeVal oprot $ from_AnnotationTask record
to_AnnotationTask :: T.ThriftVal -> AnnotationTask
to_AnnotationTask (T.TStruct fields) = AnnotationTask{
  annotationTask_type = P.maybe (P.error "Missing required field: type") (\(_,_val6) -> (case _val6 of {T.TI32 _val7 -> P.toEnum $ P.fromIntegral _val7; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  annotationTask_language = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TString _val8 -> E.decodeUtf8 _val8; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  annotationTask_unitType = P.maybe (P.error "Missing required field: unitType") (\(_,_val6) -> (case _val6 of {T.TI32 _val9 -> P.toEnum $ P.fromIntegral _val9; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  annotationTask_units = P.maybe (P.error "Missing required field: units") (\(_,_val6) -> (case _val6 of {T.TList _ _val10 -> (Vector.fromList $ P.map (\_v11 -> (case _v11 of {T.TStruct _val12 -> (Services_Types.to_AnnotationUnitIdentifier (T.TStruct _val12)); _ -> P.error "wrong type"})) _val10); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_AnnotationTask _ = P.error "not a struct"
read_AnnotationTask :: (T.Transport t, T.Protocol p) => p t -> P.IO AnnotationTask
read_AnnotationTask iprot = to_AnnotationTask <$> T.readVal iprot (T.T_STRUCT typemap_AnnotationTask)
decode_AnnotationTask :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> AnnotationTask
decode_AnnotationTask iprot bs = to_AnnotationTask $ T.deserializeVal iprot (T.T_STRUCT typemap_AnnotationTask) bs
typemap_AnnotationTask :: T.TypeMap
typemap_AnnotationTask = Map.fromList [(1,("type",T.T_I32)),(2,("language",T.T_STRING)),(3,("unitType",T.T_I32)),(4,("units",(T.T_LIST (T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier))))]
default_AnnotationTask :: AnnotationTask
default_AnnotationTask = AnnotationTask{
  annotationTask_type = (P.toEnum 0),
  annotationTask_language = P.Nothing,
  annotationTask_unitType = (P.toEnum 0),
  annotationTask_units = Vector.empty}
data Annotation = Annotation  { annotation_id :: Services_Types.AnnotationUnitIdentifier
  , annotation_communication :: Communication_Types.Communication
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Annotation where
  hashWithSalt salt record = salt   `H.hashWithSalt` annotation_id record   `H.hashWithSalt` annotation_communication record  
instance QC.Arbitrary Annotation where 
  arbitrary = M.liftM Annotation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Annotation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Annotation{annotation_id = annotation_id obj} then P.Nothing else P.Just $ default_Annotation{annotation_id = annotation_id obj}
    , if obj == default_Annotation{annotation_communication = annotation_communication obj} then P.Nothing else P.Just $ default_Annotation{annotation_communication = annotation_communication obj}
    ]
from_Annotation :: Annotation -> T.ThriftVal
from_Annotation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v15 -> P.Just (1, ("id",Services_Types.from_AnnotationUnitIdentifier _v15))) $ annotation_id record
  , (\_v15 -> P.Just (2, ("communication",Communication_Types.from_Communication _v15))) $ annotation_communication record
  ]
write_Annotation :: (T.Protocol p, T.Transport t) => p t -> Annotation -> P.IO ()
write_Annotation oprot record = T.writeVal oprot $ from_Annotation record
encode_Annotation :: (T.Protocol p, T.Transport t) => p t -> Annotation -> LBS.ByteString
encode_Annotation oprot record = T.serializeVal oprot $ from_Annotation record
to_Annotation :: T.ThriftVal -> Annotation
to_Annotation (T.TStruct fields) = Annotation{
  annotation_id = P.maybe (P.error "Missing required field: id") (\(_,_val17) -> (case _val17 of {T.TStruct _val18 -> (Services_Types.to_AnnotationUnitIdentifier (T.TStruct _val18)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  annotation_communication = P.maybe (P.error "Missing required field: communication") (\(_,_val17) -> (case _val17 of {T.TStruct _val19 -> (Communication_Types.to_Communication (T.TStruct _val19)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Annotation _ = P.error "not a struct"
read_Annotation :: (T.Transport t, T.Protocol p) => p t -> P.IO Annotation
read_Annotation iprot = to_Annotation <$> T.readVal iprot (T.T_STRUCT typemap_Annotation)
decode_Annotation :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Annotation
decode_Annotation iprot bs = to_Annotation $ T.deserializeVal iprot (T.T_STRUCT typemap_Annotation) bs
typemap_Annotation :: T.TypeMap
typemap_Annotation = Map.fromList [(1,("id",(T.T_STRUCT Services_Types.typemap_AnnotationUnitIdentifier))),(2,("communication",(T.T_STRUCT Communication_Types.typemap_Communication)))]
default_Annotation :: Annotation
default_Annotation = Annotation{
  annotation_id = Services_Types.default_AnnotationUnitIdentifier,
  annotation_communication = Communication_Types.default_Communication}
