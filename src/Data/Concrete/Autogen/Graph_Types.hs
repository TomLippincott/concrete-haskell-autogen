{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Graph_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types


data EdgeKind = DIRECTED|UNDIRECTED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum EdgeKind where
  fromEnum t = case t of
    DIRECTED -> 1
    UNDIRECTED -> 2
  toEnum t = case t of
    1 -> DIRECTED
    2 -> UNDIRECTED
    _ -> X.throw T.ThriftException
instance H.Hashable EdgeKind where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary EdgeKind where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Node = Node  { node_id :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Node where
  hashWithSalt salt record = salt   `H.hashWithSalt` node_id record  
instance QC.Arbitrary Node where 
  arbitrary = M.liftM Node (QC.arbitrary)
  shrink obj | obj == default_Node = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Node{node_id = node_id obj} then P.Nothing else P.Just $ default_Node{node_id = node_id obj}
    ]
from_Node :: Node -> T.ThriftVal
from_Node record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("id",T.TI64 _v2))) $ node_id record
  ]
write_Node :: (T.Protocol p, T.Transport t) => p t -> Node -> P.IO ()
write_Node oprot record = T.writeVal oprot $ from_Node record
encode_Node :: (T.Protocol p, T.Transport t) => p t -> Node -> LBS.ByteString
encode_Node oprot record = T.serializeVal oprot $ from_Node record
to_Node :: T.ThriftVal -> Node
to_Node (T.TStruct fields) = Node{
  node_id = P.maybe (P.error "Missing required field: id") (\(_,_val4) -> (case _val4 of {T.TI64 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Node _ = P.error "not a struct"
read_Node :: (T.Transport t, T.Protocol p) => p t -> P.IO Node
read_Node iprot = to_Node <$> T.readVal iprot (T.T_STRUCT typemap_Node)
decode_Node :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Node
decode_Node iprot bs = to_Node $ T.deserializeVal iprot (T.T_STRUCT typemap_Node) bs
typemap_Node :: T.TypeMap
typemap_Node = Map.fromList [(1,("id",T.T_I64))]
default_Node :: Node
default_Node = Node{
  node_id = 0}
data Edge = Edge  { edge_id :: I.Int64
  , edge_kind :: EdgeKind
  , edge_sources :: (Set.HashSet Node)
  , edge_targets :: (Set.HashSet Node)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Edge where
  hashWithSalt salt record = salt   `H.hashWithSalt` edge_id record   `H.hashWithSalt` edge_kind record   `H.hashWithSalt` edge_sources record   `H.hashWithSalt` edge_targets record  
instance QC.Arbitrary Edge where 
  arbitrary = M.liftM Edge (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Edge = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Edge{edge_id = edge_id obj} then P.Nothing else P.Just $ default_Edge{edge_id = edge_id obj}
    , if obj == default_Edge{edge_kind = edge_kind obj} then P.Nothing else P.Just $ default_Edge{edge_kind = edge_kind obj}
    , if obj == default_Edge{edge_sources = edge_sources obj} then P.Nothing else P.Just $ default_Edge{edge_sources = edge_sources obj}
    , if obj == default_Edge{edge_targets = edge_targets obj} then P.Nothing else P.Just $ default_Edge{edge_targets = edge_targets obj}
    ]
from_Edge :: Edge -> T.ThriftVal
from_Edge record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8 -> P.Just (1, ("id",T.TI64 _v8))) $ edge_id record
  , (\_v8 -> P.Just (2, ("kind",T.TI32 $ P.fromIntegral $ P.fromEnum _v8))) $ edge_kind record
  , (\_v8 -> P.Just (3, ("sources",T.TSet (T.T_STRUCT typemap_Node) $ P.map (\_v10 -> from_Node _v10) $ Set.toList _v8))) $ edge_sources record
  , (\_v8 -> P.Just (4, ("targets",T.TSet (T.T_STRUCT typemap_Node) $ P.map (\_v12 -> from_Node _v12) $ Set.toList _v8))) $ edge_targets record
  ]
write_Edge :: (T.Protocol p, T.Transport t) => p t -> Edge -> P.IO ()
write_Edge oprot record = T.writeVal oprot $ from_Edge record
encode_Edge :: (T.Protocol p, T.Transport t) => p t -> Edge -> LBS.ByteString
encode_Edge oprot record = T.serializeVal oprot $ from_Edge record
to_Edge :: T.ThriftVal -> Edge
to_Edge (T.TStruct fields) = Edge{
  edge_id = P.maybe (P.error "Missing required field: id") (\(_,_val14) -> (case _val14 of {T.TI64 _val15 -> _val15; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  edge_kind = P.maybe (P.error "Missing required field: kind") (\(_,_val14) -> (case _val14 of {T.TI32 _val16 -> P.toEnum $ P.fromIntegral _val16; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  edge_sources = P.maybe (P.error "Missing required field: sources") (\(_,_val14) -> (case _val14 of {T.TSet _ _val17 -> (Set.fromList $ P.map (\_v18 -> (case _v18 of {T.TStruct _val19 -> (to_Node (T.TStruct _val19)); _ -> P.error "wrong type"})) _val17); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  edge_targets = P.maybe (P.error "Missing required field: targets") (\(_,_val14) -> (case _val14 of {T.TSet _ _val20 -> (Set.fromList $ P.map (\_v21 -> (case _v21 of {T.TStruct _val22 -> (to_Node (T.TStruct _val22)); _ -> P.error "wrong type"})) _val20); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Edge _ = P.error "not a struct"
read_Edge :: (T.Transport t, T.Protocol p) => p t -> P.IO Edge
read_Edge iprot = to_Edge <$> T.readVal iprot (T.T_STRUCT typemap_Edge)
decode_Edge :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Edge
decode_Edge iprot bs = to_Edge $ T.deserializeVal iprot (T.T_STRUCT typemap_Edge) bs
typemap_Edge :: T.TypeMap
typemap_Edge = Map.fromList [(1,("id",T.T_I64)),(2,("kind",T.T_I32)),(3,("sources",(T.T_SET (T.T_STRUCT typemap_Node)))),(4,("targets",(T.T_SET (T.T_STRUCT typemap_Node))))]
default_Edge :: Edge
default_Edge = Edge{
  edge_id = 0,
  edge_kind = (P.toEnum 0),
  edge_sources = Set.empty,
  edge_targets = Set.empty}
data GraphProperty = GraphProperty  { graphProperty_objectId :: I.Int64
  , graphProperty_tagList :: (Vector.Vector LT.Text)
  , graphProperty_confidenceList :: P.Maybe (Vector.Vector P.Double)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GraphProperty where
  hashWithSalt salt record = salt   `H.hashWithSalt` graphProperty_objectId record   `H.hashWithSalt` graphProperty_tagList record   `H.hashWithSalt` graphProperty_confidenceList record  
instance QC.Arbitrary GraphProperty where 
  arbitrary = M.liftM GraphProperty (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GraphProperty = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GraphProperty{graphProperty_objectId = graphProperty_objectId obj} then P.Nothing else P.Just $ default_GraphProperty{graphProperty_objectId = graphProperty_objectId obj}
    , if obj == default_GraphProperty{graphProperty_tagList = graphProperty_tagList obj} then P.Nothing else P.Just $ default_GraphProperty{graphProperty_tagList = graphProperty_tagList obj}
    , if obj == default_GraphProperty{graphProperty_confidenceList = graphProperty_confidenceList obj} then P.Nothing else P.Just $ default_GraphProperty{graphProperty_confidenceList = graphProperty_confidenceList obj}
    ]
from_GraphProperty :: GraphProperty -> T.ThriftVal
from_GraphProperty record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v25 -> P.Just (1, ("objectId",T.TI64 _v25))) $ graphProperty_objectId record
  , (\_v25 -> P.Just (2, ("tagList",T.TList T.T_STRING $ P.map (\_v27 -> T.TString $ E.encodeUtf8 _v27) $ Vector.toList _v25))) $ graphProperty_tagList record
  , (\_v25 -> (3, ("confidenceList",T.TList T.T_DOUBLE $ P.map (\_v29 -> T.TDouble _v29) $ Vector.toList _v25))) <$> graphProperty_confidenceList record
  ]
write_GraphProperty :: (T.Protocol p, T.Transport t) => p t -> GraphProperty -> P.IO ()
write_GraphProperty oprot record = T.writeVal oprot $ from_GraphProperty record
encode_GraphProperty :: (T.Protocol p, T.Transport t) => p t -> GraphProperty -> LBS.ByteString
encode_GraphProperty oprot record = T.serializeVal oprot $ from_GraphProperty record
to_GraphProperty :: T.ThriftVal -> GraphProperty
to_GraphProperty (T.TStruct fields) = GraphProperty{
  graphProperty_objectId = P.maybe (P.error "Missing required field: objectId") (\(_,_val31) -> (case _val31 of {T.TI64 _val32 -> _val32; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  graphProperty_tagList = P.maybe (P.error "Missing required field: tagList") (\(_,_val31) -> (case _val31 of {T.TList _ _val33 -> (Vector.fromList $ P.map (\_v34 -> (case _v34 of {T.TString _val35 -> E.decodeUtf8 _val35; _ -> P.error "wrong type"})) _val33); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  graphProperty_confidenceList = P.maybe (P.Nothing) (\(_,_val31) -> P.Just (case _val31 of {T.TList _ _val36 -> (Vector.fromList $ P.map (\_v37 -> (case _v37 of {T.TDouble _val38 -> _val38; _ -> P.error "wrong type"})) _val36); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GraphProperty _ = P.error "not a struct"
read_GraphProperty :: (T.Transport t, T.Protocol p) => p t -> P.IO GraphProperty
read_GraphProperty iprot = to_GraphProperty <$> T.readVal iprot (T.T_STRUCT typemap_GraphProperty)
decode_GraphProperty :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GraphProperty
decode_GraphProperty iprot bs = to_GraphProperty $ T.deserializeVal iprot (T.T_STRUCT typemap_GraphProperty) bs
typemap_GraphProperty :: T.TypeMap
typemap_GraphProperty = Map.fromList [(1,("objectId",T.T_I64)),(2,("tagList",(T.T_LIST T.T_STRING))),(3,("confidenceList",(T.T_LIST T.T_DOUBLE)))]
default_GraphProperty :: GraphProperty
default_GraphProperty = GraphProperty{
  graphProperty_objectId = 0,
  graphProperty_tagList = Vector.empty,
  graphProperty_confidenceList = P.Nothing}
data GraphPropertyAssignment = GraphPropertyAssignment  { graphPropertyAssignment_uuid :: Uuid_Types.UUID
  , graphPropertyAssignment_type :: LT.Text
  , graphPropertyAssignment_propertyList :: (Vector.Vector GraphProperty)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GraphPropertyAssignment where
  hashWithSalt salt record = salt   `H.hashWithSalt` graphPropertyAssignment_uuid record   `H.hashWithSalt` graphPropertyAssignment_type record   `H.hashWithSalt` graphPropertyAssignment_propertyList record  
instance QC.Arbitrary GraphPropertyAssignment where 
  arbitrary = M.liftM GraphPropertyAssignment (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GraphPropertyAssignment = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GraphPropertyAssignment{graphPropertyAssignment_uuid = graphPropertyAssignment_uuid obj} then P.Nothing else P.Just $ default_GraphPropertyAssignment{graphPropertyAssignment_uuid = graphPropertyAssignment_uuid obj}
    , if obj == default_GraphPropertyAssignment{graphPropertyAssignment_type = graphPropertyAssignment_type obj} then P.Nothing else P.Just $ default_GraphPropertyAssignment{graphPropertyAssignment_type = graphPropertyAssignment_type obj}
    , if obj == default_GraphPropertyAssignment{graphPropertyAssignment_propertyList = graphPropertyAssignment_propertyList obj} then P.Nothing else P.Just $ default_GraphPropertyAssignment{graphPropertyAssignment_propertyList = graphPropertyAssignment_propertyList obj}
    ]
from_GraphPropertyAssignment :: GraphPropertyAssignment -> T.ThriftVal
from_GraphPropertyAssignment record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v41 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v41))) $ graphPropertyAssignment_uuid record
  , (\_v41 -> P.Just (2, ("type",T.TString $ E.encodeUtf8 _v41))) $ graphPropertyAssignment_type record
  , (\_v41 -> P.Just (3, ("propertyList",T.TList (T.T_STRUCT typemap_GraphProperty) $ P.map (\_v43 -> from_GraphProperty _v43) $ Vector.toList _v41))) $ graphPropertyAssignment_propertyList record
  ]
write_GraphPropertyAssignment :: (T.Protocol p, T.Transport t) => p t -> GraphPropertyAssignment -> P.IO ()
write_GraphPropertyAssignment oprot record = T.writeVal oprot $ from_GraphPropertyAssignment record
encode_GraphPropertyAssignment :: (T.Protocol p, T.Transport t) => p t -> GraphPropertyAssignment -> LBS.ByteString
encode_GraphPropertyAssignment oprot record = T.serializeVal oprot $ from_GraphPropertyAssignment record
to_GraphPropertyAssignment :: T.ThriftVal -> GraphPropertyAssignment
to_GraphPropertyAssignment (T.TStruct fields) = GraphPropertyAssignment{
  graphPropertyAssignment_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val45) -> (case _val45 of {T.TStruct _val46 -> (Uuid_Types.to_UUID (T.TStruct _val46)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  graphPropertyAssignment_type = P.maybe (P.error "Missing required field: type") (\(_,_val45) -> (case _val45 of {T.TString _val47 -> E.decodeUtf8 _val47; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  graphPropertyAssignment_propertyList = P.maybe (P.error "Missing required field: propertyList") (\(_,_val45) -> (case _val45 of {T.TList _ _val48 -> (Vector.fromList $ P.map (\_v49 -> (case _v49 of {T.TStruct _val50 -> (to_GraphProperty (T.TStruct _val50)); _ -> P.error "wrong type"})) _val48); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GraphPropertyAssignment _ = P.error "not a struct"
read_GraphPropertyAssignment :: (T.Transport t, T.Protocol p) => p t -> P.IO GraphPropertyAssignment
read_GraphPropertyAssignment iprot = to_GraphPropertyAssignment <$> T.readVal iprot (T.T_STRUCT typemap_GraphPropertyAssignment)
decode_GraphPropertyAssignment :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GraphPropertyAssignment
decode_GraphPropertyAssignment iprot bs = to_GraphPropertyAssignment $ T.deserializeVal iprot (T.T_STRUCT typemap_GraphPropertyAssignment) bs
typemap_GraphPropertyAssignment :: T.TypeMap
typemap_GraphPropertyAssignment = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("type",T.T_STRING)),(3,("propertyList",(T.T_LIST (T.T_STRUCT typemap_GraphProperty))))]
default_GraphPropertyAssignment :: GraphPropertyAssignment
default_GraphPropertyAssignment = GraphPropertyAssignment{
  graphPropertyAssignment_uuid = Uuid_Types.default_UUID,
  graphPropertyAssignment_type = "",
  graphPropertyAssignment_propertyList = Vector.empty}
data GraphAssociation = GraphAssociation  { graphAssociation_objectId :: I.Int64
  , graphAssociation_externalEntityId :: Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GraphAssociation where
  hashWithSalt salt record = salt   `H.hashWithSalt` graphAssociation_objectId record   `H.hashWithSalt` graphAssociation_externalEntityId record  
instance QC.Arbitrary GraphAssociation where 
  arbitrary = M.liftM GraphAssociation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GraphAssociation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GraphAssociation{graphAssociation_objectId = graphAssociation_objectId obj} then P.Nothing else P.Just $ default_GraphAssociation{graphAssociation_objectId = graphAssociation_objectId obj}
    , if obj == default_GraphAssociation{graphAssociation_externalEntityId = graphAssociation_externalEntityId obj} then P.Nothing else P.Just $ default_GraphAssociation{graphAssociation_externalEntityId = graphAssociation_externalEntityId obj}
    ]
from_GraphAssociation :: GraphAssociation -> T.ThriftVal
from_GraphAssociation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v53 -> P.Just (1, ("objectId",T.TI64 _v53))) $ graphAssociation_objectId record
  , (\_v53 -> P.Just (2, ("externalEntityId",Uuid_Types.from_UUID _v53))) $ graphAssociation_externalEntityId record
  ]
write_GraphAssociation :: (T.Protocol p, T.Transport t) => p t -> GraphAssociation -> P.IO ()
write_GraphAssociation oprot record = T.writeVal oprot $ from_GraphAssociation record
encode_GraphAssociation :: (T.Protocol p, T.Transport t) => p t -> GraphAssociation -> LBS.ByteString
encode_GraphAssociation oprot record = T.serializeVal oprot $ from_GraphAssociation record
to_GraphAssociation :: T.ThriftVal -> GraphAssociation
to_GraphAssociation (T.TStruct fields) = GraphAssociation{
  graphAssociation_objectId = P.maybe (P.error "Missing required field: objectId") (\(_,_val55) -> (case _val55 of {T.TI64 _val56 -> _val56; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  graphAssociation_externalEntityId = P.maybe (P.error "Missing required field: externalEntityId") (\(_,_val55) -> (case _val55 of {T.TStruct _val57 -> (Uuid_Types.to_UUID (T.TStruct _val57)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GraphAssociation _ = P.error "not a struct"
read_GraphAssociation :: (T.Transport t, T.Protocol p) => p t -> P.IO GraphAssociation
read_GraphAssociation iprot = to_GraphAssociation <$> T.readVal iprot (T.T_STRUCT typemap_GraphAssociation)
decode_GraphAssociation :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GraphAssociation
decode_GraphAssociation iprot bs = to_GraphAssociation $ T.deserializeVal iprot (T.T_STRUCT typemap_GraphAssociation) bs
typemap_GraphAssociation :: T.TypeMap
typemap_GraphAssociation = Map.fromList [(1,("objectId",T.T_I64)),(2,("externalEntityId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_GraphAssociation :: GraphAssociation
default_GraphAssociation = GraphAssociation{
  graphAssociation_objectId = 0,
  graphAssociation_externalEntityId = Uuid_Types.default_UUID}
data GraphView = GraphView  { graphView_uuid :: Uuid_Types.UUID
  , graphView_nodeSetIDSet :: (Set.HashSet Uuid_Types.UUID)
  , graphView_edgeSetIDSet :: (Set.HashSet Uuid_Types.UUID)
  , graphView_metadata :: P.Maybe Metadata_Types.AnnotationMetadata
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GraphView where
  hashWithSalt salt record = salt   `H.hashWithSalt` graphView_uuid record   `H.hashWithSalt` graphView_nodeSetIDSet record   `H.hashWithSalt` graphView_edgeSetIDSet record   `H.hashWithSalt` graphView_metadata record  
instance QC.Arbitrary GraphView where 
  arbitrary = M.liftM GraphView (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GraphView = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GraphView{graphView_uuid = graphView_uuid obj} then P.Nothing else P.Just $ default_GraphView{graphView_uuid = graphView_uuid obj}
    , if obj == default_GraphView{graphView_nodeSetIDSet = graphView_nodeSetIDSet obj} then P.Nothing else P.Just $ default_GraphView{graphView_nodeSetIDSet = graphView_nodeSetIDSet obj}
    , if obj == default_GraphView{graphView_edgeSetIDSet = graphView_edgeSetIDSet obj} then P.Nothing else P.Just $ default_GraphView{graphView_edgeSetIDSet = graphView_edgeSetIDSet obj}
    , if obj == default_GraphView{graphView_metadata = graphView_metadata obj} then P.Nothing else P.Just $ default_GraphView{graphView_metadata = graphView_metadata obj}
    ]
from_GraphView :: GraphView -> T.ThriftVal
from_GraphView record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v60 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v60))) $ graphView_uuid record
  , (\_v60 -> P.Just (2, ("nodeSetIDSet",T.TSet (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v62 -> Uuid_Types.from_UUID _v62) $ Set.toList _v60))) $ graphView_nodeSetIDSet record
  , (\_v60 -> P.Just (3, ("edgeSetIDSet",T.TSet (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v64 -> Uuid_Types.from_UUID _v64) $ Set.toList _v60))) $ graphView_edgeSetIDSet record
  , (\_v60 -> (4, ("metadata",Metadata_Types.from_AnnotationMetadata _v60))) <$> graphView_metadata record
  ]
write_GraphView :: (T.Protocol p, T.Transport t) => p t -> GraphView -> P.IO ()
write_GraphView oprot record = T.writeVal oprot $ from_GraphView record
encode_GraphView :: (T.Protocol p, T.Transport t) => p t -> GraphView -> LBS.ByteString
encode_GraphView oprot record = T.serializeVal oprot $ from_GraphView record
to_GraphView :: T.ThriftVal -> GraphView
to_GraphView (T.TStruct fields) = GraphView{
  graphView_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val66) -> (case _val66 of {T.TStruct _val67 -> (Uuid_Types.to_UUID (T.TStruct _val67)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  graphView_nodeSetIDSet = P.maybe (P.error "Missing required field: nodeSetIDSet") (\(_,_val66) -> (case _val66 of {T.TSet _ _val68 -> (Set.fromList $ P.map (\_v69 -> (case _v69 of {T.TStruct _val70 -> (Uuid_Types.to_UUID (T.TStruct _val70)); _ -> P.error "wrong type"})) _val68); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  graphView_edgeSetIDSet = P.maybe (P.error "Missing required field: edgeSetIDSet") (\(_,_val66) -> (case _val66 of {T.TSet _ _val71 -> (Set.fromList $ P.map (\_v72 -> (case _v72 of {T.TStruct _val73 -> (Uuid_Types.to_UUID (T.TStruct _val73)); _ -> P.error "wrong type"})) _val71); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  graphView_metadata = P.maybe (P.Nothing) (\(_,_val66) -> P.Just (case _val66 of {T.TStruct _val74 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val74)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GraphView _ = P.error "not a struct"
read_GraphView :: (T.Transport t, T.Protocol p) => p t -> P.IO GraphView
read_GraphView iprot = to_GraphView <$> T.readVal iprot (T.T_STRUCT typemap_GraphView)
decode_GraphView :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GraphView
decode_GraphView iprot bs = to_GraphView $ T.deserializeVal iprot (T.T_STRUCT typemap_GraphView) bs
typemap_GraphView :: T.TypeMap
typemap_GraphView = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("nodeSetIDSet",(T.T_SET (T.T_STRUCT Uuid_Types.typemap_UUID)))),(3,("edgeSetIDSet",(T.T_SET (T.T_STRUCT Uuid_Types.typemap_UUID)))),(4,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata)))]
default_GraphView :: GraphView
default_GraphView = GraphView{
  graphView_uuid = Uuid_Types.default_UUID,
  graphView_nodeSetIDSet = Set.empty,
  graphView_edgeSetIDSet = Set.empty,
  graphView_metadata = P.Nothing}
data NodeSet = NodeSet  { nodeSet_uuid :: Uuid_Types.UUID
  , nodeSet_nodes :: (Set.HashSet Node)
  , nodeSet_metadata :: P.Maybe Metadata_Types.AnnotationMetadata
  , nodeSet_propertyAssignmentSet :: P.Maybe (Set.HashSet GraphPropertyAssignment)
  , nodeSet_associationSet :: P.Maybe (Set.HashSet GraphAssociation)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NodeSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` nodeSet_uuid record   `H.hashWithSalt` nodeSet_nodes record   `H.hashWithSalt` nodeSet_metadata record   `H.hashWithSalt` nodeSet_propertyAssignmentSet record   `H.hashWithSalt` nodeSet_associationSet record  
instance QC.Arbitrary NodeSet where 
  arbitrary = M.liftM NodeSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NodeSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NodeSet{nodeSet_uuid = nodeSet_uuid obj} then P.Nothing else P.Just $ default_NodeSet{nodeSet_uuid = nodeSet_uuid obj}
    , if obj == default_NodeSet{nodeSet_nodes = nodeSet_nodes obj} then P.Nothing else P.Just $ default_NodeSet{nodeSet_nodes = nodeSet_nodes obj}
    , if obj == default_NodeSet{nodeSet_metadata = nodeSet_metadata obj} then P.Nothing else P.Just $ default_NodeSet{nodeSet_metadata = nodeSet_metadata obj}
    , if obj == default_NodeSet{nodeSet_propertyAssignmentSet = nodeSet_propertyAssignmentSet obj} then P.Nothing else P.Just $ default_NodeSet{nodeSet_propertyAssignmentSet = nodeSet_propertyAssignmentSet obj}
    , if obj == default_NodeSet{nodeSet_associationSet = nodeSet_associationSet obj} then P.Nothing else P.Just $ default_NodeSet{nodeSet_associationSet = nodeSet_associationSet obj}
    ]
from_NodeSet :: NodeSet -> T.ThriftVal
from_NodeSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v77 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v77))) $ nodeSet_uuid record
  , (\_v77 -> P.Just (2, ("nodes",T.TSet (T.T_STRUCT typemap_Node) $ P.map (\_v79 -> from_Node _v79) $ Set.toList _v77))) $ nodeSet_nodes record
  , (\_v77 -> (3, ("metadata",Metadata_Types.from_AnnotationMetadata _v77))) <$> nodeSet_metadata record
  , (\_v77 -> (4, ("propertyAssignmentSet",T.TSet (T.T_STRUCT typemap_GraphPropertyAssignment) $ P.map (\_v81 -> from_GraphPropertyAssignment _v81) $ Set.toList _v77))) <$> nodeSet_propertyAssignmentSet record
  , (\_v77 -> (5, ("associationSet",T.TSet (T.T_STRUCT typemap_GraphAssociation) $ P.map (\_v83 -> from_GraphAssociation _v83) $ Set.toList _v77))) <$> nodeSet_associationSet record
  ]
write_NodeSet :: (T.Protocol p, T.Transport t) => p t -> NodeSet -> P.IO ()
write_NodeSet oprot record = T.writeVal oprot $ from_NodeSet record
encode_NodeSet :: (T.Protocol p, T.Transport t) => p t -> NodeSet -> LBS.ByteString
encode_NodeSet oprot record = T.serializeVal oprot $ from_NodeSet record
to_NodeSet :: T.ThriftVal -> NodeSet
to_NodeSet (T.TStruct fields) = NodeSet{
  nodeSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val85) -> (case _val85 of {T.TStruct _val86 -> (Uuid_Types.to_UUID (T.TStruct _val86)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  nodeSet_nodes = P.maybe (P.error "Missing required field: nodes") (\(_,_val85) -> (case _val85 of {T.TSet _ _val87 -> (Set.fromList $ P.map (\_v88 -> (case _v88 of {T.TStruct _val89 -> (to_Node (T.TStruct _val89)); _ -> P.error "wrong type"})) _val87); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  nodeSet_metadata = P.maybe (P.Nothing) (\(_,_val85) -> P.Just (case _val85 of {T.TStruct _val90 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val90)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  nodeSet_propertyAssignmentSet = P.maybe (P.Nothing) (\(_,_val85) -> P.Just (case _val85 of {T.TSet _ _val91 -> (Set.fromList $ P.map (\_v92 -> (case _v92 of {T.TStruct _val93 -> (to_GraphPropertyAssignment (T.TStruct _val93)); _ -> P.error "wrong type"})) _val91); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  nodeSet_associationSet = P.maybe (P.Nothing) (\(_,_val85) -> P.Just (case _val85 of {T.TSet _ _val94 -> (Set.fromList $ P.map (\_v95 -> (case _v95 of {T.TStruct _val96 -> (to_GraphAssociation (T.TStruct _val96)); _ -> P.error "wrong type"})) _val94); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NodeSet _ = P.error "not a struct"
read_NodeSet :: (T.Transport t, T.Protocol p) => p t -> P.IO NodeSet
read_NodeSet iprot = to_NodeSet <$> T.readVal iprot (T.T_STRUCT typemap_NodeSet)
decode_NodeSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> NodeSet
decode_NodeSet iprot bs = to_NodeSet $ T.deserializeVal iprot (T.T_STRUCT typemap_NodeSet) bs
typemap_NodeSet :: T.TypeMap
typemap_NodeSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("nodes",(T.T_SET (T.T_STRUCT typemap_Node)))),(3,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(4,("propertyAssignmentSet",(T.T_SET (T.T_STRUCT typemap_GraphPropertyAssignment)))),(5,("associationSet",(T.T_SET (T.T_STRUCT typemap_GraphAssociation))))]
default_NodeSet :: NodeSet
default_NodeSet = NodeSet{
  nodeSet_uuid = Uuid_Types.default_UUID,
  nodeSet_nodes = Set.empty,
  nodeSet_metadata = P.Nothing,
  nodeSet_propertyAssignmentSet = P.Nothing,
  nodeSet_associationSet = P.Nothing}
data EdgeSet = EdgeSet  { edgeSet_uuid :: Uuid_Types.UUID
  , edgeSet_edges :: (Set.HashSet Edge)
  , edgeSet_metadata :: P.Maybe Metadata_Types.AnnotationMetadata
  , edgeSet_propertyAssignmentSet :: P.Maybe (Set.HashSet GraphPropertyAssignment)
  , edgeSet_associationSet :: P.Maybe (Set.HashSet GraphAssociation)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EdgeSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` edgeSet_uuid record   `H.hashWithSalt` edgeSet_edges record   `H.hashWithSalt` edgeSet_metadata record   `H.hashWithSalt` edgeSet_propertyAssignmentSet record   `H.hashWithSalt` edgeSet_associationSet record  
instance QC.Arbitrary EdgeSet where 
  arbitrary = M.liftM EdgeSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EdgeSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EdgeSet{edgeSet_uuid = edgeSet_uuid obj} then P.Nothing else P.Just $ default_EdgeSet{edgeSet_uuid = edgeSet_uuid obj}
    , if obj == default_EdgeSet{edgeSet_edges = edgeSet_edges obj} then P.Nothing else P.Just $ default_EdgeSet{edgeSet_edges = edgeSet_edges obj}
    , if obj == default_EdgeSet{edgeSet_metadata = edgeSet_metadata obj} then P.Nothing else P.Just $ default_EdgeSet{edgeSet_metadata = edgeSet_metadata obj}
    , if obj == default_EdgeSet{edgeSet_propertyAssignmentSet = edgeSet_propertyAssignmentSet obj} then P.Nothing else P.Just $ default_EdgeSet{edgeSet_propertyAssignmentSet = edgeSet_propertyAssignmentSet obj}
    , if obj == default_EdgeSet{edgeSet_associationSet = edgeSet_associationSet obj} then P.Nothing else P.Just $ default_EdgeSet{edgeSet_associationSet = edgeSet_associationSet obj}
    ]
from_EdgeSet :: EdgeSet -> T.ThriftVal
from_EdgeSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v99 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v99))) $ edgeSet_uuid record
  , (\_v99 -> P.Just (2, ("edges",T.TSet (T.T_STRUCT typemap_Edge) $ P.map (\_v101 -> from_Edge _v101) $ Set.toList _v99))) $ edgeSet_edges record
  , (\_v99 -> (3, ("metadata",Metadata_Types.from_AnnotationMetadata _v99))) <$> edgeSet_metadata record
  , (\_v99 -> (4, ("propertyAssignmentSet",T.TSet (T.T_STRUCT typemap_GraphPropertyAssignment) $ P.map (\_v103 -> from_GraphPropertyAssignment _v103) $ Set.toList _v99))) <$> edgeSet_propertyAssignmentSet record
  , (\_v99 -> (5, ("associationSet",T.TSet (T.T_STRUCT typemap_GraphAssociation) $ P.map (\_v105 -> from_GraphAssociation _v105) $ Set.toList _v99))) <$> edgeSet_associationSet record
  ]
write_EdgeSet :: (T.Protocol p, T.Transport t) => p t -> EdgeSet -> P.IO ()
write_EdgeSet oprot record = T.writeVal oprot $ from_EdgeSet record
encode_EdgeSet :: (T.Protocol p, T.Transport t) => p t -> EdgeSet -> LBS.ByteString
encode_EdgeSet oprot record = T.serializeVal oprot $ from_EdgeSet record
to_EdgeSet :: T.ThriftVal -> EdgeSet
to_EdgeSet (T.TStruct fields) = EdgeSet{
  edgeSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val107) -> (case _val107 of {T.TStruct _val108 -> (Uuid_Types.to_UUID (T.TStruct _val108)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  edgeSet_edges = P.maybe (P.error "Missing required field: edges") (\(_,_val107) -> (case _val107 of {T.TSet _ _val109 -> (Set.fromList $ P.map (\_v110 -> (case _v110 of {T.TStruct _val111 -> (to_Edge (T.TStruct _val111)); _ -> P.error "wrong type"})) _val109); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  edgeSet_metadata = P.maybe (P.Nothing) (\(_,_val107) -> P.Just (case _val107 of {T.TStruct _val112 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val112)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  edgeSet_propertyAssignmentSet = P.maybe (P.Nothing) (\(_,_val107) -> P.Just (case _val107 of {T.TSet _ _val113 -> (Set.fromList $ P.map (\_v114 -> (case _v114 of {T.TStruct _val115 -> (to_GraphPropertyAssignment (T.TStruct _val115)); _ -> P.error "wrong type"})) _val113); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  edgeSet_associationSet = P.maybe (P.Nothing) (\(_,_val107) -> P.Just (case _val107 of {T.TSet _ _val116 -> (Set.fromList $ P.map (\_v117 -> (case _v117 of {T.TStruct _val118 -> (to_GraphAssociation (T.TStruct _val118)); _ -> P.error "wrong type"})) _val116); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_EdgeSet _ = P.error "not a struct"
read_EdgeSet :: (T.Transport t, T.Protocol p) => p t -> P.IO EdgeSet
read_EdgeSet iprot = to_EdgeSet <$> T.readVal iprot (T.T_STRUCT typemap_EdgeSet)
decode_EdgeSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EdgeSet
decode_EdgeSet iprot bs = to_EdgeSet $ T.deserializeVal iprot (T.T_STRUCT typemap_EdgeSet) bs
typemap_EdgeSet :: T.TypeMap
typemap_EdgeSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("edges",(T.T_SET (T.T_STRUCT typemap_Edge)))),(3,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(4,("propertyAssignmentSet",(T.T_SET (T.T_STRUCT typemap_GraphPropertyAssignment)))),(5,("associationSet",(T.T_SET (T.T_STRUCT typemap_GraphAssociation))))]
default_EdgeSet :: EdgeSet
default_EdgeSet = EdgeSet{
  edgeSet_uuid = Uuid_Types.default_UUID,
  edgeSet_edges = Set.empty,
  edgeSet_metadata = P.Nothing,
  edgeSet_propertyAssignmentSet = P.Nothing,
  edgeSet_associationSet = P.Nothing}
data MultiGraph = MultiGraph  { multiGraph_uuid :: Uuid_Types.UUID
  , multiGraph_graphViews :: (Set.HashSet GraphView)
  , multiGraph_nodeSets :: (Set.HashSet NodeSet)
  , multiGraph_edgeSets :: (Set.HashSet EdgeSet)
  , multiGraph_metadata :: P.Maybe Metadata_Types.AnnotationMetadata
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MultiGraph where
  hashWithSalt salt record = salt   `H.hashWithSalt` multiGraph_uuid record   `H.hashWithSalt` multiGraph_graphViews record   `H.hashWithSalt` multiGraph_nodeSets record   `H.hashWithSalt` multiGraph_edgeSets record   `H.hashWithSalt` multiGraph_metadata record  
instance QC.Arbitrary MultiGraph where 
  arbitrary = M.liftM MultiGraph (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MultiGraph = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MultiGraph{multiGraph_uuid = multiGraph_uuid obj} then P.Nothing else P.Just $ default_MultiGraph{multiGraph_uuid = multiGraph_uuid obj}
    , if obj == default_MultiGraph{multiGraph_graphViews = multiGraph_graphViews obj} then P.Nothing else P.Just $ default_MultiGraph{multiGraph_graphViews = multiGraph_graphViews obj}
    , if obj == default_MultiGraph{multiGraph_nodeSets = multiGraph_nodeSets obj} then P.Nothing else P.Just $ default_MultiGraph{multiGraph_nodeSets = multiGraph_nodeSets obj}
    , if obj == default_MultiGraph{multiGraph_edgeSets = multiGraph_edgeSets obj} then P.Nothing else P.Just $ default_MultiGraph{multiGraph_edgeSets = multiGraph_edgeSets obj}
    , if obj == default_MultiGraph{multiGraph_metadata = multiGraph_metadata obj} then P.Nothing else P.Just $ default_MultiGraph{multiGraph_metadata = multiGraph_metadata obj}
    ]
from_MultiGraph :: MultiGraph -> T.ThriftVal
from_MultiGraph record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v121 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v121))) $ multiGraph_uuid record
  , (\_v121 -> P.Just (2, ("graphViews",T.TSet (T.T_STRUCT typemap_GraphView) $ P.map (\_v123 -> from_GraphView _v123) $ Set.toList _v121))) $ multiGraph_graphViews record
  , (\_v121 -> P.Just (3, ("nodeSets",T.TSet (T.T_STRUCT typemap_NodeSet) $ P.map (\_v125 -> from_NodeSet _v125) $ Set.toList _v121))) $ multiGraph_nodeSets record
  , (\_v121 -> P.Just (4, ("edgeSets",T.TSet (T.T_STRUCT typemap_EdgeSet) $ P.map (\_v127 -> from_EdgeSet _v127) $ Set.toList _v121))) $ multiGraph_edgeSets record
  , (\_v121 -> (5, ("metadata",Metadata_Types.from_AnnotationMetadata _v121))) <$> multiGraph_metadata record
  ]
write_MultiGraph :: (T.Protocol p, T.Transport t) => p t -> MultiGraph -> P.IO ()
write_MultiGraph oprot record = T.writeVal oprot $ from_MultiGraph record
encode_MultiGraph :: (T.Protocol p, T.Transport t) => p t -> MultiGraph -> LBS.ByteString
encode_MultiGraph oprot record = T.serializeVal oprot $ from_MultiGraph record
to_MultiGraph :: T.ThriftVal -> MultiGraph
to_MultiGraph (T.TStruct fields) = MultiGraph{
  multiGraph_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val129) -> (case _val129 of {T.TStruct _val130 -> (Uuid_Types.to_UUID (T.TStruct _val130)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  multiGraph_graphViews = P.maybe (P.error "Missing required field: graphViews") (\(_,_val129) -> (case _val129 of {T.TSet _ _val131 -> (Set.fromList $ P.map (\_v132 -> (case _v132 of {T.TStruct _val133 -> (to_GraphView (T.TStruct _val133)); _ -> P.error "wrong type"})) _val131); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  multiGraph_nodeSets = P.maybe (P.error "Missing required field: nodeSets") (\(_,_val129) -> (case _val129 of {T.TSet _ _val134 -> (Set.fromList $ P.map (\_v135 -> (case _v135 of {T.TStruct _val136 -> (to_NodeSet (T.TStruct _val136)); _ -> P.error "wrong type"})) _val134); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  multiGraph_edgeSets = P.maybe (P.error "Missing required field: edgeSets") (\(_,_val129) -> (case _val129 of {T.TSet _ _val137 -> (Set.fromList $ P.map (\_v138 -> (case _v138 of {T.TStruct _val139 -> (to_EdgeSet (T.TStruct _val139)); _ -> P.error "wrong type"})) _val137); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  multiGraph_metadata = P.maybe (P.Nothing) (\(_,_val129) -> P.Just (case _val129 of {T.TStruct _val140 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val140)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_MultiGraph _ = P.error "not a struct"
read_MultiGraph :: (T.Transport t, T.Protocol p) => p t -> P.IO MultiGraph
read_MultiGraph iprot = to_MultiGraph <$> T.readVal iprot (T.T_STRUCT typemap_MultiGraph)
decode_MultiGraph :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> MultiGraph
decode_MultiGraph iprot bs = to_MultiGraph $ T.deserializeVal iprot (T.T_STRUCT typemap_MultiGraph) bs
typemap_MultiGraph :: T.TypeMap
typemap_MultiGraph = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("graphViews",(T.T_SET (T.T_STRUCT typemap_GraphView)))),(3,("nodeSets",(T.T_SET (T.T_STRUCT typemap_NodeSet)))),(4,("edgeSets",(T.T_SET (T.T_STRUCT typemap_EdgeSet)))),(5,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata)))]
default_MultiGraph :: MultiGraph
default_MultiGraph = MultiGraph{
  multiGraph_uuid = Uuid_Types.default_UUID,
  multiGraph_graphViews = Set.empty,
  multiGraph_nodeSets = Set.empty,
  multiGraph_edgeSets = Set.empty,
  multiGraph_metadata = P.Nothing}
