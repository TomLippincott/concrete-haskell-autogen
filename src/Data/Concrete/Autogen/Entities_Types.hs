{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Entities_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Linking_Types as Linking_Types


data Entity = Entity  { entity_uuid :: Uuid_Types.UUID
  , entity_id :: P.Maybe LT.Text
  , entity_mentionIdList :: (Vector.Vector Uuid_Types.UUID)
  , entity_rawMentionList :: P.Maybe (Vector.Vector Structure_Types.TokenRefSequence)
  , entity_type :: P.Maybe LT.Text
  , entity_confidence :: P.Maybe P.Double
  , entity_canonicalName :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Entity where
  hashWithSalt salt record = salt   `H.hashWithSalt` entity_uuid record   `H.hashWithSalt` entity_id record   `H.hashWithSalt` entity_mentionIdList record   `H.hashWithSalt` entity_rawMentionList record   `H.hashWithSalt` entity_type record   `H.hashWithSalt` entity_confidence record   `H.hashWithSalt` entity_canonicalName record  
instance QC.Arbitrary Entity where 
  arbitrary = M.liftM Entity (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Entity = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Entity{entity_uuid = entity_uuid obj} then P.Nothing else P.Just $ default_Entity{entity_uuid = entity_uuid obj}
    , if obj == default_Entity{entity_id = entity_id obj} then P.Nothing else P.Just $ default_Entity{entity_id = entity_id obj}
    , if obj == default_Entity{entity_mentionIdList = entity_mentionIdList obj} then P.Nothing else P.Just $ default_Entity{entity_mentionIdList = entity_mentionIdList obj}
    , if obj == default_Entity{entity_rawMentionList = entity_rawMentionList obj} then P.Nothing else P.Just $ default_Entity{entity_rawMentionList = entity_rawMentionList obj}
    , if obj == default_Entity{entity_type = entity_type obj} then P.Nothing else P.Just $ default_Entity{entity_type = entity_type obj}
    , if obj == default_Entity{entity_confidence = entity_confidence obj} then P.Nothing else P.Just $ default_Entity{entity_confidence = entity_confidence obj}
    , if obj == default_Entity{entity_canonicalName = entity_canonicalName obj} then P.Nothing else P.Just $ default_Entity{entity_canonicalName = entity_canonicalName obj}
    ]
from_Entity :: Entity -> T.ThriftVal
from_Entity record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v2))) $ entity_uuid record
  , (\_v2 -> P.Just (2, ("mentionIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v4 -> Uuid_Types.from_UUID _v4) $ Vector.toList _v2))) $ entity_mentionIdList record
  , (\_v2 -> (3, ("type",T.TString $ E.encodeUtf8 _v2))) <$> entity_type record
  , (\_v2 -> (4, ("confidence",T.TDouble _v2))) <$> entity_confidence record
  , (\_v2 -> (5, ("canonicalName",T.TString $ E.encodeUtf8 _v2))) <$> entity_canonicalName record
  , (\_v2 -> (6, ("id",T.TString $ E.encodeUtf8 _v2))) <$> entity_id record
  , (\_v2 -> (7, ("rawMentionList",T.TList (T.T_STRUCT Structure_Types.typemap_TokenRefSequence) $ P.map (\_v6 -> Structure_Types.from_TokenRefSequence _v6) $ Vector.toList _v2))) <$> entity_rawMentionList record
  ]
write_Entity :: (T.Protocol p, T.Transport t) => p t -> Entity -> P.IO ()
write_Entity oprot record = T.writeVal oprot $ from_Entity record
encode_Entity :: (T.Protocol p, T.Transport t) => p t -> Entity -> LBS.ByteString
encode_Entity oprot record = T.serializeVal oprot $ from_Entity record
to_Entity :: T.ThriftVal -> Entity
to_Entity (T.TStruct fields) = Entity{
  entity_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val8) -> (case _val8 of {T.TStruct _val9 -> (Uuid_Types.to_UUID (T.TStruct _val9)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entity_id = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TString _val10 -> E.decodeUtf8 _val10; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  entity_mentionIdList = P.maybe (P.error "Missing required field: mentionIdList") (\(_,_val8) -> (case _val8 of {T.TList _ _val11 -> (Vector.fromList $ P.map (\_v12 -> (case _v12 of {T.TStruct _val13 -> (Uuid_Types.to_UUID (T.TStruct _val13)); _ -> P.error "wrong type"})) _val11); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entity_rawMentionList = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TList _ _val14 -> (Vector.fromList $ P.map (\_v15 -> (case _v15 of {T.TStruct _val16 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val16)); _ -> P.error "wrong type"})) _val14); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  entity_type = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TString _val17 -> E.decodeUtf8 _val17; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entity_confidence = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TDouble _val18 -> _val18; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entity_canonicalName = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TString _val19 -> E.decodeUtf8 _val19; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Entity _ = P.error "not a struct"
read_Entity :: (T.Transport t, T.Protocol p) => p t -> P.IO Entity
read_Entity iprot = to_Entity <$> T.readVal iprot (T.T_STRUCT typemap_Entity)
decode_Entity :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Entity
decode_Entity iprot bs = to_Entity $ T.deserializeVal iprot (T.T_STRUCT typemap_Entity) bs
typemap_Entity :: T.TypeMap
typemap_Entity = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("mentionIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(3,("type",T.T_STRING)),(4,("confidence",T.T_DOUBLE)),(5,("canonicalName",T.T_STRING)),(6,("id",T.T_STRING)),(7,("rawMentionList",(T.T_LIST (T.T_STRUCT Structure_Types.typemap_TokenRefSequence))))]
default_Entity :: Entity
default_Entity = Entity{
  entity_uuid = Uuid_Types.default_UUID,
  entity_mentionIdList = Vector.empty,
  entity_type = P.Nothing,
  entity_confidence = P.Nothing,
  entity_canonicalName = P.Nothing,
  entity_id = P.Nothing,
  entity_rawMentionList = P.Nothing}
data EntitySet = EntitySet  { entitySet_uuid :: Uuid_Types.UUID
  , entitySet_metadata :: Metadata_Types.AnnotationMetadata
  , entitySet_entityList :: (Vector.Vector Entity)
  , entitySet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  , entitySet_mentionSetId :: P.Maybe Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntitySet where
  hashWithSalt salt record = salt   `H.hashWithSalt` entitySet_uuid record   `H.hashWithSalt` entitySet_metadata record   `H.hashWithSalt` entitySet_entityList record   `H.hashWithSalt` entitySet_linkingList record   `H.hashWithSalt` entitySet_mentionSetId record  
instance QC.Arbitrary EntitySet where 
  arbitrary = M.liftM EntitySet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntitySet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntitySet{entitySet_uuid = entitySet_uuid obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_uuid = entitySet_uuid obj}
    , if obj == default_EntitySet{entitySet_metadata = entitySet_metadata obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_metadata = entitySet_metadata obj}
    , if obj == default_EntitySet{entitySet_entityList = entitySet_entityList obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_entityList = entitySet_entityList obj}
    , if obj == default_EntitySet{entitySet_linkingList = entitySet_linkingList obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_linkingList = entitySet_linkingList obj}
    , if obj == default_EntitySet{entitySet_mentionSetId = entitySet_mentionSetId obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_mentionSetId = entitySet_mentionSetId obj}
    ]
from_EntitySet :: EntitySet -> T.ThriftVal
from_EntitySet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v22 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v22))) $ entitySet_uuid record
  , (\_v22 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v22))) $ entitySet_metadata record
  , (\_v22 -> P.Just (3, ("entityList",T.TList (T.T_STRUCT typemap_Entity) $ P.map (\_v24 -> from_Entity _v24) $ Vector.toList _v22))) $ entitySet_entityList record
  , (\_v22 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v26 -> Linking_Types.from_Linking _v26) $ Vector.toList _v22))) <$> entitySet_linkingList record
  , (\_v22 -> (5, ("mentionSetId",Uuid_Types.from_UUID _v22))) <$> entitySet_mentionSetId record
  ]
write_EntitySet :: (T.Protocol p, T.Transport t) => p t -> EntitySet -> P.IO ()
write_EntitySet oprot record = T.writeVal oprot $ from_EntitySet record
encode_EntitySet :: (T.Protocol p, T.Transport t) => p t -> EntitySet -> LBS.ByteString
encode_EntitySet oprot record = T.serializeVal oprot $ from_EntitySet record
to_EntitySet :: T.ThriftVal -> EntitySet
to_EntitySet (T.TStruct fields) = EntitySet{
  entitySet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val28) -> (case _val28 of {T.TStruct _val29 -> (Uuid_Types.to_UUID (T.TStruct _val29)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entitySet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val28) -> (case _val28 of {T.TStruct _val30 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val30)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entitySet_entityList = P.maybe (P.error "Missing required field: entityList") (\(_,_val28) -> (case _val28 of {T.TList _ _val31 -> (Vector.fromList $ P.map (\_v32 -> (case _v32 of {T.TStruct _val33 -> (to_Entity (T.TStruct _val33)); _ -> P.error "wrong type"})) _val31); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entitySet_linkingList = P.maybe (P.Nothing) (\(_,_val28) -> P.Just (case _val28 of {T.TList _ _val34 -> (Vector.fromList $ P.map (\_v35 -> (case _v35 of {T.TStruct _val36 -> (Linking_Types.to_Linking (T.TStruct _val36)); _ -> P.error "wrong type"})) _val34); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entitySet_mentionSetId = P.maybe (P.Nothing) (\(_,_val28) -> P.Just (case _val28 of {T.TStruct _val37 -> (Uuid_Types.to_UUID (T.TStruct _val37)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_EntitySet _ = P.error "not a struct"
read_EntitySet :: (T.Transport t, T.Protocol p) => p t -> P.IO EntitySet
read_EntitySet iprot = to_EntitySet <$> T.readVal iprot (T.T_STRUCT typemap_EntitySet)
decode_EntitySet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntitySet
decode_EntitySet iprot bs = to_EntitySet $ T.deserializeVal iprot (T.T_STRUCT typemap_EntitySet) bs
typemap_EntitySet :: T.TypeMap
typemap_EntitySet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("entityList",(T.T_LIST (T.T_STRUCT typemap_Entity)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking)))),(5,("mentionSetId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_EntitySet :: EntitySet
default_EntitySet = EntitySet{
  entitySet_uuid = Uuid_Types.default_UUID,
  entitySet_metadata = Metadata_Types.default_AnnotationMetadata,
  entitySet_entityList = Vector.empty,
  entitySet_linkingList = P.Nothing,
  entitySet_mentionSetId = P.Nothing}
data EntityMention = EntityMention  { entityMention_uuid :: Uuid_Types.UUID
  , entityMention_tokens :: Structure_Types.TokenRefSequence
  , entityMention_entityType :: P.Maybe LT.Text
  , entityMention_phraseType :: P.Maybe LT.Text
  , entityMention_confidence :: P.Maybe P.Double
  , entityMention_text :: P.Maybe LT.Text
  , entityMention_childMentionIdList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntityMention where
  hashWithSalt salt record = salt   `H.hashWithSalt` entityMention_uuid record   `H.hashWithSalt` entityMention_tokens record   `H.hashWithSalt` entityMention_entityType record   `H.hashWithSalt` entityMention_phraseType record   `H.hashWithSalt` entityMention_confidence record   `H.hashWithSalt` entityMention_text record   `H.hashWithSalt` entityMention_childMentionIdList record  
instance QC.Arbitrary EntityMention where 
  arbitrary = M.liftM EntityMention (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntityMention = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntityMention{entityMention_uuid = entityMention_uuid obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_uuid = entityMention_uuid obj}
    , if obj == default_EntityMention{entityMention_tokens = entityMention_tokens obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_tokens = entityMention_tokens obj}
    , if obj == default_EntityMention{entityMention_entityType = entityMention_entityType obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_entityType = entityMention_entityType obj}
    , if obj == default_EntityMention{entityMention_phraseType = entityMention_phraseType obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_phraseType = entityMention_phraseType obj}
    , if obj == default_EntityMention{entityMention_confidence = entityMention_confidence obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_confidence = entityMention_confidence obj}
    , if obj == default_EntityMention{entityMention_text = entityMention_text obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_text = entityMention_text obj}
    , if obj == default_EntityMention{entityMention_childMentionIdList = entityMention_childMentionIdList obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_childMentionIdList = entityMention_childMentionIdList obj}
    ]
from_EntityMention :: EntityMention -> T.ThriftVal
from_EntityMention record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v40 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v40))) $ entityMention_uuid record
  , (\_v40 -> P.Just (2, ("tokens",Structure_Types.from_TokenRefSequence _v40))) $ entityMention_tokens record
  , (\_v40 -> (3, ("entityType",T.TString $ E.encodeUtf8 _v40))) <$> entityMention_entityType record
  , (\_v40 -> (4, ("phraseType",T.TString $ E.encodeUtf8 _v40))) <$> entityMention_phraseType record
  , (\_v40 -> (5, ("confidence",T.TDouble _v40))) <$> entityMention_confidence record
  , (\_v40 -> (6, ("text",T.TString $ E.encodeUtf8 _v40))) <$> entityMention_text record
  , (\_v40 -> (7, ("childMentionIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v42 -> Uuid_Types.from_UUID _v42) $ Vector.toList _v40))) <$> entityMention_childMentionIdList record
  ]
write_EntityMention :: (T.Protocol p, T.Transport t) => p t -> EntityMention -> P.IO ()
write_EntityMention oprot record = T.writeVal oprot $ from_EntityMention record
encode_EntityMention :: (T.Protocol p, T.Transport t) => p t -> EntityMention -> LBS.ByteString
encode_EntityMention oprot record = T.serializeVal oprot $ from_EntityMention record
to_EntityMention :: T.ThriftVal -> EntityMention
to_EntityMention (T.TStruct fields) = EntityMention{
  entityMention_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val44) -> (case _val44 of {T.TStruct _val45 -> (Uuid_Types.to_UUID (T.TStruct _val45)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entityMention_tokens = P.maybe (P.error "Missing required field: tokens") (\(_,_val44) -> (case _val44 of {T.TStruct _val46 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val46)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entityMention_entityType = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val47 -> E.decodeUtf8 _val47; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entityMention_phraseType = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val48 -> E.decodeUtf8 _val48; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entityMention_confidence = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TDouble _val49 -> _val49; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  entityMention_text = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TString _val50 -> E.decodeUtf8 _val50; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  entityMention_childMentionIdList = P.maybe (P.Nothing) (\(_,_val44) -> P.Just (case _val44 of {T.TList _ _val51 -> (Vector.fromList $ P.map (\_v52 -> (case _v52 of {T.TStruct _val53 -> (Uuid_Types.to_UUID (T.TStruct _val53)); _ -> P.error "wrong type"})) _val51); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_EntityMention _ = P.error "not a struct"
read_EntityMention :: (T.Transport t, T.Protocol p) => p t -> P.IO EntityMention
read_EntityMention iprot = to_EntityMention <$> T.readVal iprot (T.T_STRUCT typemap_EntityMention)
decode_EntityMention :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntityMention
decode_EntityMention iprot bs = to_EntityMention $ T.deserializeVal iprot (T.T_STRUCT typemap_EntityMention) bs
typemap_EntityMention :: T.TypeMap
typemap_EntityMention = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(3,("entityType",T.T_STRING)),(4,("phraseType",T.T_STRING)),(5,("confidence",T.T_DOUBLE)),(6,("text",T.T_STRING)),(7,("childMentionIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID))))]
default_EntityMention :: EntityMention
default_EntityMention = EntityMention{
  entityMention_uuid = Uuid_Types.default_UUID,
  entityMention_tokens = Structure_Types.default_TokenRefSequence,
  entityMention_entityType = P.Nothing,
  entityMention_phraseType = P.Nothing,
  entityMention_confidence = P.Nothing,
  entityMention_text = P.Nothing,
  entityMention_childMentionIdList = P.Nothing}
data EntityMentionSet = EntityMentionSet  { entityMentionSet_uuid :: Uuid_Types.UUID
  , entityMentionSet_metadata :: Metadata_Types.AnnotationMetadata
  , entityMentionSet_mentionList :: (Vector.Vector EntityMention)
  , entityMentionSet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntityMentionSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` entityMentionSet_uuid record   `H.hashWithSalt` entityMentionSet_metadata record   `H.hashWithSalt` entityMentionSet_mentionList record   `H.hashWithSalt` entityMentionSet_linkingList record  
instance QC.Arbitrary EntityMentionSet where 
  arbitrary = M.liftM EntityMentionSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntityMentionSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntityMentionSet{entityMentionSet_uuid = entityMentionSet_uuid obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_uuid = entityMentionSet_uuid obj}
    , if obj == default_EntityMentionSet{entityMentionSet_metadata = entityMentionSet_metadata obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_metadata = entityMentionSet_metadata obj}
    , if obj == default_EntityMentionSet{entityMentionSet_mentionList = entityMentionSet_mentionList obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_mentionList = entityMentionSet_mentionList obj}
    , if obj == default_EntityMentionSet{entityMentionSet_linkingList = entityMentionSet_linkingList obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_linkingList = entityMentionSet_linkingList obj}
    ]
from_EntityMentionSet :: EntityMentionSet -> T.ThriftVal
from_EntityMentionSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v56 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v56))) $ entityMentionSet_uuid record
  , (\_v56 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v56))) $ entityMentionSet_metadata record
  , (\_v56 -> P.Just (3, ("mentionList",T.TList (T.T_STRUCT typemap_EntityMention) $ P.map (\_v58 -> from_EntityMention _v58) $ Vector.toList _v56))) $ entityMentionSet_mentionList record
  , (\_v56 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v60 -> Linking_Types.from_Linking _v60) $ Vector.toList _v56))) <$> entityMentionSet_linkingList record
  ]
write_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> EntityMentionSet -> P.IO ()
write_EntityMentionSet oprot record = T.writeVal oprot $ from_EntityMentionSet record
encode_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> EntityMentionSet -> LBS.ByteString
encode_EntityMentionSet oprot record = T.serializeVal oprot $ from_EntityMentionSet record
to_EntityMentionSet :: T.ThriftVal -> EntityMentionSet
to_EntityMentionSet (T.TStruct fields) = EntityMentionSet{
  entityMentionSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val62) -> (case _val62 of {T.TStruct _val63 -> (Uuid_Types.to_UUID (T.TStruct _val63)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entityMentionSet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val62) -> (case _val62 of {T.TStruct _val64 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val64)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entityMentionSet_mentionList = P.maybe (P.error "Missing required field: mentionList") (\(_,_val62) -> (case _val62 of {T.TList _ _val65 -> (Vector.fromList $ P.map (\_v66 -> (case _v66 of {T.TStruct _val67 -> (to_EntityMention (T.TStruct _val67)); _ -> P.error "wrong type"})) _val65); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entityMentionSet_linkingList = P.maybe (P.Nothing) (\(_,_val62) -> P.Just (case _val62 of {T.TList _ _val68 -> (Vector.fromList $ P.map (\_v69 -> (case _v69 of {T.TStruct _val70 -> (Linking_Types.to_Linking (T.TStruct _val70)); _ -> P.error "wrong type"})) _val68); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_EntityMentionSet _ = P.error "not a struct"
read_EntityMentionSet :: (T.Transport t, T.Protocol p) => p t -> P.IO EntityMentionSet
read_EntityMentionSet iprot = to_EntityMentionSet <$> T.readVal iprot (T.T_STRUCT typemap_EntityMentionSet)
decode_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntityMentionSet
decode_EntityMentionSet iprot bs = to_EntityMentionSet $ T.deserializeVal iprot (T.T_STRUCT typemap_EntityMentionSet) bs
typemap_EntityMentionSet :: T.TypeMap
typemap_EntityMentionSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("mentionList",(T.T_LIST (T.T_STRUCT typemap_EntityMention)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking))))]
default_EntityMentionSet :: EntityMentionSet
default_EntityMentionSet = EntityMentionSet{
  entityMentionSet_uuid = Uuid_Types.default_UUID,
  entityMentionSet_metadata = Metadata_Types.default_AnnotationMetadata,
  entityMentionSet_mentionList = Vector.empty,
  entityMentionSet_linkingList = P.Nothing}
