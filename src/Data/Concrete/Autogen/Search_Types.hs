{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Data.Concrete.Autogen.Search_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import Data.Concrete.Autogen.Communication_Types as Communication_Types
import Data.Concrete.Autogen.Services_Types as Services_Types
import Data.Concrete.Autogen.Structure_Types as Structure_Types
import Data.Concrete.Autogen.Uuid_Types as Uuid_Types
import Data.Concrete.Autogen.Metadata_Types as Metadata_Types
import Data.Concrete.Autogen.Entities_Types as Entities_Types


data SearchType = COMMUNICATIONS|SECTIONS|SENTENCES|ENTITIES|ENTITY_MENTIONS|SITUATIONS|SITUATION_MENTIONS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SearchType where
  fromEnum t = case t of
    COMMUNICATIONS -> 0
    SECTIONS -> 1
    SENTENCES -> 2
    ENTITIES -> 3
    ENTITY_MENTIONS -> 4
    SITUATIONS -> 5
    SITUATION_MENTIONS -> 6
  toEnum t = case t of
    0 -> COMMUNICATIONS
    1 -> SECTIONS
    2 -> SENTENCES
    3 -> ENTITIES
    4 -> ENTITY_MENTIONS
    5 -> SITUATIONS
    6 -> SITUATION_MENTIONS
    _ -> X.throw T.ThriftException
instance H.Hashable SearchType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SearchType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SearchFeedback = NEGATIVE|NONE|POSITIVE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SearchFeedback where
  fromEnum t = case t of
    NEGATIVE -> -1
    NONE -> 0
    POSITIVE -> 1
  toEnum t = case t of
    -1 -> NEGATIVE
    0 -> NONE
    1 -> POSITIVE
    _ -> X.throw T.ThriftException
instance H.Hashable SearchFeedback where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SearchFeedback where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SearchCapability = SearchCapability  { searchCapability_type :: SearchType
  , searchCapability_lang :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchCapability where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchCapability_type record   `H.hashWithSalt` searchCapability_lang record  
instance QC.Arbitrary SearchCapability where 
  arbitrary = M.liftM SearchCapability (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchCapability = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchCapability{searchCapability_type = searchCapability_type obj} then P.Nothing else P.Just $ default_SearchCapability{searchCapability_type = searchCapability_type obj}
    , if obj == default_SearchCapability{searchCapability_lang = searchCapability_lang obj} then P.Nothing else P.Just $ default_SearchCapability{searchCapability_lang = searchCapability_lang obj}
    ]
from_SearchCapability :: SearchCapability -> T.ThriftVal
from_SearchCapability record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ searchCapability_type record
  , (\_v2 -> P.Just (2, ("lang",T.TString $ E.encodeUtf8 _v2))) $ searchCapability_lang record
  ]
write_SearchCapability :: (T.Protocol p, T.Transport t) => p t -> SearchCapability -> P.IO ()
write_SearchCapability oprot record = T.writeVal oprot $ from_SearchCapability record
encode_SearchCapability :: (T.Protocol p, T.Transport t) => p t -> SearchCapability -> LBS.ByteString
encode_SearchCapability oprot record = T.serializeVal oprot $ from_SearchCapability record
to_SearchCapability :: T.ThriftVal -> SearchCapability
to_SearchCapability (T.TStruct fields) = SearchCapability{
  searchCapability_type = P.maybe (P.error "Missing required field: type") (\(_,_val4) -> (case _val4 of {T.TI32 _val5 -> P.toEnum $ P.fromIntegral _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchCapability_lang = P.maybe (P.error "Missing required field: lang") (\(_,_val4) -> (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SearchCapability _ = P.error "not a struct"
read_SearchCapability :: (T.Transport t, T.Protocol p) => p t -> P.IO SearchCapability
read_SearchCapability iprot = to_SearchCapability <$> T.readVal iprot (T.T_STRUCT typemap_SearchCapability)
decode_SearchCapability :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SearchCapability
decode_SearchCapability iprot bs = to_SearchCapability $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchCapability) bs
typemap_SearchCapability :: T.TypeMap
typemap_SearchCapability = Map.fromList [(1,("type",T.T_I32)),(2,("lang",T.T_STRING))]
default_SearchCapability :: SearchCapability
default_SearchCapability = SearchCapability{
  searchCapability_type = (P.toEnum 0),
  searchCapability_lang = ""}
data SearchQuery = SearchQuery  { searchQuery_terms :: P.Maybe (Vector.Vector LT.Text)
  , searchQuery_questions :: P.Maybe (Vector.Vector LT.Text)
  , searchQuery_communicationId :: P.Maybe LT.Text
  , searchQuery_tokens :: P.Maybe Structure_Types.TokenRefSequence
  , searchQuery_rawQuery :: P.Maybe LT.Text
  , searchQuery_auths :: P.Maybe LT.Text
  , searchQuery_userId :: P.Maybe LT.Text
  , searchQuery_name :: P.Maybe LT.Text
  , searchQuery_labels :: P.Maybe (Vector.Vector LT.Text)
  , searchQuery_type :: SearchType
  , searchQuery_lang :: P.Maybe LT.Text
  , searchQuery_corpus :: P.Maybe LT.Text
  , searchQuery_k :: P.Maybe I.Int32
  , searchQuery_communication :: P.Maybe Communication_Types.Communication
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchQuery where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchQuery_terms record   `H.hashWithSalt` searchQuery_questions record   `H.hashWithSalt` searchQuery_communicationId record   `H.hashWithSalt` searchQuery_tokens record   `H.hashWithSalt` searchQuery_rawQuery record   `H.hashWithSalt` searchQuery_auths record   `H.hashWithSalt` searchQuery_userId record   `H.hashWithSalt` searchQuery_name record   `H.hashWithSalt` searchQuery_labels record   `H.hashWithSalt` searchQuery_type record   `H.hashWithSalt` searchQuery_lang record   `H.hashWithSalt` searchQuery_corpus record   `H.hashWithSalt` searchQuery_k record   `H.hashWithSalt` searchQuery_communication record  
instance QC.Arbitrary SearchQuery where 
  arbitrary = M.liftM SearchQuery (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchQuery = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchQuery{searchQuery_terms = searchQuery_terms obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_terms = searchQuery_terms obj}
    , if obj == default_SearchQuery{searchQuery_questions = searchQuery_questions obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_questions = searchQuery_questions obj}
    , if obj == default_SearchQuery{searchQuery_communicationId = searchQuery_communicationId obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_communicationId = searchQuery_communicationId obj}
    , if obj == default_SearchQuery{searchQuery_tokens = searchQuery_tokens obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_tokens = searchQuery_tokens obj}
    , if obj == default_SearchQuery{searchQuery_rawQuery = searchQuery_rawQuery obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_rawQuery = searchQuery_rawQuery obj}
    , if obj == default_SearchQuery{searchQuery_auths = searchQuery_auths obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_auths = searchQuery_auths obj}
    , if obj == default_SearchQuery{searchQuery_userId = searchQuery_userId obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_userId = searchQuery_userId obj}
    , if obj == default_SearchQuery{searchQuery_name = searchQuery_name obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_name = searchQuery_name obj}
    , if obj == default_SearchQuery{searchQuery_labels = searchQuery_labels obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_labels = searchQuery_labels obj}
    , if obj == default_SearchQuery{searchQuery_type = searchQuery_type obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_type = searchQuery_type obj}
    , if obj == default_SearchQuery{searchQuery_lang = searchQuery_lang obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_lang = searchQuery_lang obj}
    , if obj == default_SearchQuery{searchQuery_corpus = searchQuery_corpus obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_corpus = searchQuery_corpus obj}
    , if obj == default_SearchQuery{searchQuery_k = searchQuery_k obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_k = searchQuery_k obj}
    , if obj == default_SearchQuery{searchQuery_communication = searchQuery_communication obj} then P.Nothing else P.Just $ default_SearchQuery{searchQuery_communication = searchQuery_communication obj}
    ]
from_SearchQuery :: SearchQuery -> T.ThriftVal
from_SearchQuery record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9 -> (1, ("terms",T.TList T.T_STRING $ P.map (\_v11 -> T.TString $ E.encodeUtf8 _v11) $ Vector.toList _v9))) <$> searchQuery_terms record
  , (\_v9 -> (2, ("questions",T.TList T.T_STRING $ P.map (\_v13 -> T.TString $ E.encodeUtf8 _v13) $ Vector.toList _v9))) <$> searchQuery_questions record
  , (\_v9 -> (3, ("communicationId",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_communicationId record
  , (\_v9 -> (4, ("tokens",Structure_Types.from_TokenRefSequence _v9))) <$> searchQuery_tokens record
  , (\_v9 -> (5, ("rawQuery",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_rawQuery record
  , (\_v9 -> (6, ("auths",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_auths record
  , (\_v9 -> (7, ("userId",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_userId record
  , (\_v9 -> (8, ("name",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_name record
  , (\_v9 -> (9, ("labels",T.TList T.T_STRING $ P.map (\_v15 -> T.TString $ E.encodeUtf8 _v15) $ Vector.toList _v9))) <$> searchQuery_labels record
  , (\_v9 -> P.Just (10, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v9))) $ searchQuery_type record
  , (\_v9 -> (11, ("lang",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_lang record
  , (\_v9 -> (12, ("corpus",T.TString $ E.encodeUtf8 _v9))) <$> searchQuery_corpus record
  , (\_v9 -> (13, ("k",T.TI32 _v9))) <$> searchQuery_k record
  , (\_v9 -> (14, ("communication",Communication_Types.from_Communication _v9))) <$> searchQuery_communication record
  ]
write_SearchQuery :: (T.Protocol p, T.Transport t) => p t -> SearchQuery -> P.IO ()
write_SearchQuery oprot record = T.writeVal oprot $ from_SearchQuery record
encode_SearchQuery :: (T.Protocol p, T.Transport t) => p t -> SearchQuery -> LBS.ByteString
encode_SearchQuery oprot record = T.serializeVal oprot $ from_SearchQuery record
to_SearchQuery :: T.ThriftVal -> SearchQuery
to_SearchQuery (T.TStruct fields) = SearchQuery{
  searchQuery_terms = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TList _ _val18 -> (Vector.fromList $ P.map (\_v19 -> (case _v19 of {T.TString _val20 -> E.decodeUtf8 _val20; _ -> P.error "wrong type"})) _val18); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchQuery_questions = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TList _ _val21 -> (Vector.fromList $ P.map (\_v22 -> (case _v22 of {T.TString _val23 -> E.decodeUtf8 _val23; _ -> P.error "wrong type"})) _val21); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchQuery_communicationId = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val24 -> E.decodeUtf8 _val24; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchQuery_tokens = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TStruct _val25 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val25)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  searchQuery_rawQuery = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val26 -> E.decodeUtf8 _val26; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  searchQuery_auths = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val27 -> E.decodeUtf8 _val27; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  searchQuery_userId = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val28 -> E.decodeUtf8 _val28; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  searchQuery_name = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val29 -> E.decodeUtf8 _val29; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  searchQuery_labels = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TList _ _val30 -> (Vector.fromList $ P.map (\_v31 -> (case _v31 of {T.TString _val32 -> E.decodeUtf8 _val32; _ -> P.error "wrong type"})) _val30); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  searchQuery_type = P.maybe (P.error "Missing required field: type") (\(_,_val17) -> (case _val17 of {T.TI32 _val33 -> P.toEnum $ P.fromIntegral _val33; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  searchQuery_lang = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val34 -> E.decodeUtf8 _val34; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  searchQuery_corpus = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TString _val35 -> E.decodeUtf8 _val35; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  searchQuery_k = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TI32 _val36 -> _val36; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  searchQuery_communication = P.maybe (P.Nothing) (\(_,_val17) -> P.Just (case _val17 of {T.TStruct _val37 -> (Communication_Types.to_Communication (T.TStruct _val37)); _ -> P.error "wrong type"})) (Map.lookup (14) fields)
  }
to_SearchQuery _ = P.error "not a struct"
read_SearchQuery :: (T.Transport t, T.Protocol p) => p t -> P.IO SearchQuery
read_SearchQuery iprot = to_SearchQuery <$> T.readVal iprot (T.T_STRUCT typemap_SearchQuery)
decode_SearchQuery :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SearchQuery
decode_SearchQuery iprot bs = to_SearchQuery $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchQuery) bs
typemap_SearchQuery :: T.TypeMap
typemap_SearchQuery = Map.fromList [(1,("terms",(T.T_LIST T.T_STRING))),(2,("questions",(T.T_LIST T.T_STRING))),(3,("communicationId",T.T_STRING)),(4,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(5,("rawQuery",T.T_STRING)),(6,("auths",T.T_STRING)),(7,("userId",T.T_STRING)),(8,("name",T.T_STRING)),(9,("labels",(T.T_LIST T.T_STRING))),(10,("type",T.T_I32)),(11,("lang",T.T_STRING)),(12,("corpus",T.T_STRING)),(13,("k",T.T_I32)),(14,("communication",(T.T_STRUCT Communication_Types.typemap_Communication)))]
default_SearchQuery :: SearchQuery
default_SearchQuery = SearchQuery{
  searchQuery_terms = P.Nothing,
  searchQuery_questions = P.Nothing,
  searchQuery_communicationId = P.Nothing,
  searchQuery_tokens = P.Nothing,
  searchQuery_rawQuery = P.Nothing,
  searchQuery_auths = P.Nothing,
  searchQuery_userId = P.Nothing,
  searchQuery_name = P.Nothing,
  searchQuery_labels = P.Nothing,
  searchQuery_type = (P.toEnum 0),
  searchQuery_lang = P.Nothing,
  searchQuery_corpus = P.Nothing,
  searchQuery_k = P.Nothing,
  searchQuery_communication = P.Nothing}
data SearchResultItem = SearchResultItem  { searchResultItem_communicationId :: P.Maybe LT.Text
  , searchResultItem_sentenceId :: P.Maybe Uuid_Types.UUID
  , searchResultItem_score :: P.Maybe P.Double
  , searchResultItem_tokens :: P.Maybe Structure_Types.TokenRefSequence
  , searchResultItem_entity :: P.Maybe Entities_Types.Entity
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchResultItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchResultItem_communicationId record   `H.hashWithSalt` searchResultItem_sentenceId record   `H.hashWithSalt` searchResultItem_score record   `H.hashWithSalt` searchResultItem_tokens record   `H.hashWithSalt` searchResultItem_entity record  
instance QC.Arbitrary SearchResultItem where 
  arbitrary = M.liftM SearchResultItem (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchResultItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchResultItem{searchResultItem_communicationId = searchResultItem_communicationId obj} then P.Nothing else P.Just $ default_SearchResultItem{searchResultItem_communicationId = searchResultItem_communicationId obj}
    , if obj == default_SearchResultItem{searchResultItem_sentenceId = searchResultItem_sentenceId obj} then P.Nothing else P.Just $ default_SearchResultItem{searchResultItem_sentenceId = searchResultItem_sentenceId obj}
    , if obj == default_SearchResultItem{searchResultItem_score = searchResultItem_score obj} then P.Nothing else P.Just $ default_SearchResultItem{searchResultItem_score = searchResultItem_score obj}
    , if obj == default_SearchResultItem{searchResultItem_tokens = searchResultItem_tokens obj} then P.Nothing else P.Just $ default_SearchResultItem{searchResultItem_tokens = searchResultItem_tokens obj}
    , if obj == default_SearchResultItem{searchResultItem_entity = searchResultItem_entity obj} then P.Nothing else P.Just $ default_SearchResultItem{searchResultItem_entity = searchResultItem_entity obj}
    ]
from_SearchResultItem :: SearchResultItem -> T.ThriftVal
from_SearchResultItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v40 -> (1, ("communicationId",T.TString $ E.encodeUtf8 _v40))) <$> searchResultItem_communicationId record
  , (\_v40 -> (2, ("sentenceId",Uuid_Types.from_UUID _v40))) <$> searchResultItem_sentenceId record
  , (\_v40 -> (3, ("score",T.TDouble _v40))) <$> searchResultItem_score record
  , (\_v40 -> (4, ("tokens",Structure_Types.from_TokenRefSequence _v40))) <$> searchResultItem_tokens record
  , (\_v40 -> (5, ("entity",Entities_Types.from_Entity _v40))) <$> searchResultItem_entity record
  ]
write_SearchResultItem :: (T.Protocol p, T.Transport t) => p t -> SearchResultItem -> P.IO ()
write_SearchResultItem oprot record = T.writeVal oprot $ from_SearchResultItem record
encode_SearchResultItem :: (T.Protocol p, T.Transport t) => p t -> SearchResultItem -> LBS.ByteString
encode_SearchResultItem oprot record = T.serializeVal oprot $ from_SearchResultItem record
to_SearchResultItem :: T.ThriftVal -> SearchResultItem
to_SearchResultItem (T.TStruct fields) = SearchResultItem{
  searchResultItem_communicationId = P.maybe (P.Nothing) (\(_,_val42) -> P.Just (case _val42 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchResultItem_sentenceId = P.maybe (P.Nothing) (\(_,_val42) -> P.Just (case _val42 of {T.TStruct _val44 -> (Uuid_Types.to_UUID (T.TStruct _val44)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchResultItem_score = P.maybe (P.Nothing) (\(_,_val42) -> P.Just (case _val42 of {T.TDouble _val45 -> _val45; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchResultItem_tokens = P.maybe (P.Nothing) (\(_,_val42) -> P.Just (case _val42 of {T.TStruct _val46 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val46)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  searchResultItem_entity = P.maybe (P.Nothing) (\(_,_val42) -> P.Just (case _val42 of {T.TStruct _val47 -> (Entities_Types.to_Entity (T.TStruct _val47)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SearchResultItem _ = P.error "not a struct"
read_SearchResultItem :: (T.Transport t, T.Protocol p) => p t -> P.IO SearchResultItem
read_SearchResultItem iprot = to_SearchResultItem <$> T.readVal iprot (T.T_STRUCT typemap_SearchResultItem)
decode_SearchResultItem :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SearchResultItem
decode_SearchResultItem iprot bs = to_SearchResultItem $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchResultItem) bs
typemap_SearchResultItem :: T.TypeMap
typemap_SearchResultItem = Map.fromList [(1,("communicationId",T.T_STRING)),(2,("sentenceId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("score",T.T_DOUBLE)),(4,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(5,("entity",(T.T_STRUCT Entities_Types.typemap_Entity)))]
default_SearchResultItem :: SearchResultItem
default_SearchResultItem = SearchResultItem{
  searchResultItem_communicationId = P.Nothing,
  searchResultItem_sentenceId = P.Nothing,
  searchResultItem_score = P.Nothing,
  searchResultItem_tokens = P.Nothing,
  searchResultItem_entity = P.Nothing}
data SearchResult = SearchResult  { searchResult_uuid :: Uuid_Types.UUID
  , searchResult_searchQuery :: SearchQuery
  , searchResult_searchResultItems :: P.Maybe (Vector.Vector SearchResultItem)
  , searchResult_metadata :: P.Maybe Metadata_Types.AnnotationMetadata
  , searchResult_lang :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchResult_uuid record   `H.hashWithSalt` searchResult_searchQuery record   `H.hashWithSalt` searchResult_searchResultItems record   `H.hashWithSalt` searchResult_metadata record   `H.hashWithSalt` searchResult_lang record  
instance QC.Arbitrary SearchResult where 
  arbitrary = M.liftM SearchResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchResult{searchResult_uuid = searchResult_uuid obj} then P.Nothing else P.Just $ default_SearchResult{searchResult_uuid = searchResult_uuid obj}
    , if obj == default_SearchResult{searchResult_searchQuery = searchResult_searchQuery obj} then P.Nothing else P.Just $ default_SearchResult{searchResult_searchQuery = searchResult_searchQuery obj}
    , if obj == default_SearchResult{searchResult_searchResultItems = searchResult_searchResultItems obj} then P.Nothing else P.Just $ default_SearchResult{searchResult_searchResultItems = searchResult_searchResultItems obj}
    , if obj == default_SearchResult{searchResult_metadata = searchResult_metadata obj} then P.Nothing else P.Just $ default_SearchResult{searchResult_metadata = searchResult_metadata obj}
    , if obj == default_SearchResult{searchResult_lang = searchResult_lang obj} then P.Nothing else P.Just $ default_SearchResult{searchResult_lang = searchResult_lang obj}
    ]
from_SearchResult :: SearchResult -> T.ThriftVal
from_SearchResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v50 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v50))) $ searchResult_uuid record
  , (\_v50 -> P.Just (2, ("searchQuery",from_SearchQuery _v50))) $ searchResult_searchQuery record
  , (\_v50 -> (3, ("searchResultItems",T.TList (T.T_STRUCT typemap_SearchResultItem) $ P.map (\_v52 -> from_SearchResultItem _v52) $ Vector.toList _v50))) <$> searchResult_searchResultItems record
  , (\_v50 -> (4, ("metadata",Metadata_Types.from_AnnotationMetadata _v50))) <$> searchResult_metadata record
  , (\_v50 -> (5, ("lang",T.TString $ E.encodeUtf8 _v50))) <$> searchResult_lang record
  ]
write_SearchResult :: (T.Protocol p, T.Transport t) => p t -> SearchResult -> P.IO ()
write_SearchResult oprot record = T.writeVal oprot $ from_SearchResult record
encode_SearchResult :: (T.Protocol p, T.Transport t) => p t -> SearchResult -> LBS.ByteString
encode_SearchResult oprot record = T.serializeVal oprot $ from_SearchResult record
to_SearchResult :: T.ThriftVal -> SearchResult
to_SearchResult (T.TStruct fields) = SearchResult{
  searchResult_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val54) -> (case _val54 of {T.TStruct _val55 -> (Uuid_Types.to_UUID (T.TStruct _val55)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchResult_searchQuery = P.maybe (P.error "Missing required field: searchQuery") (\(_,_val54) -> (case _val54 of {T.TStruct _val56 -> (to_SearchQuery (T.TStruct _val56)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchResult_searchResultItems = P.maybe (P.Nothing) (\(_,_val54) -> P.Just (case _val54 of {T.TList _ _val57 -> (Vector.fromList $ P.map (\_v58 -> (case _v58 of {T.TStruct _val59 -> (to_SearchResultItem (T.TStruct _val59)); _ -> P.error "wrong type"})) _val57); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchResult_metadata = P.maybe (P.Nothing) (\(_,_val54) -> P.Just (case _val54 of {T.TStruct _val60 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val60)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  searchResult_lang = P.maybe (P.Nothing) (\(_,_val54) -> P.Just (case _val54 of {T.TString _val61 -> E.decodeUtf8 _val61; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SearchResult _ = P.error "not a struct"
read_SearchResult :: (T.Transport t, T.Protocol p) => p t -> P.IO SearchResult
read_SearchResult iprot = to_SearchResult <$> T.readVal iprot (T.T_STRUCT typemap_SearchResult)
decode_SearchResult :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SearchResult
decode_SearchResult iprot bs = to_SearchResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchResult) bs
typemap_SearchResult :: T.TypeMap
typemap_SearchResult = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("searchQuery",(T.T_STRUCT typemap_SearchQuery))),(3,("searchResultItems",(T.T_LIST (T.T_STRUCT typemap_SearchResultItem)))),(4,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(5,("lang",T.T_STRING))]
default_SearchResult :: SearchResult
default_SearchResult = SearchResult{
  searchResult_uuid = Uuid_Types.default_UUID,
  searchResult_searchQuery = default_SearchQuery,
  searchResult_searchResultItems = P.Nothing,
  searchResult_metadata = P.Nothing,
  searchResult_lang = P.Nothing}
